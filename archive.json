{
  "magic": "E!vIA5L86J2I",
  "timestamp": "2020-05-27T21:48:34.846381+00:00",
  "repo": "tlswg/draft-ietf-tls-esni",
  "labels": [
    {
      "name": "bug",
      "description": "Something isn't working",
      "color": "d73a4a"
    },
    {
      "name": "duplicate",
      "description": "This issue or pull request already exists",
      "color": "cfd3d7"
    },
    {
      "name": "enhancement",
      "description": "New feature or request",
      "color": "a2eeef"
    },
    {
      "name": "help wanted",
      "description": "Extra attention is needed",
      "color": "008672"
    },
    {
      "name": "good first issue",
      "description": "Good for newcomers",
      "color": "7057ff"
    },
    {
      "name": "invalid",
      "description": "This doesn't seem right",
      "color": "e4e669"
    },
    {
      "name": "question",
      "description": "Further information is requested",
      "color": "d876e3"
    },
    {
      "name": "wontfix",
      "description": "This will not be worked on",
      "color": "ffffff"
    },
    {
      "name": "needs WG discussion",
      "description": "",
      "color": "c5def5"
    }
  ],
  "issues": [
    {
      "number": 5,
      "id": "MDU6SXNzdWUzMjI0NjYzMDg=",
      "title": "Add an optional \"fronting SNI\" to the DNS record",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/5",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "In most cases, this can be absent, but it might help with deployment to have SNI in every handshake.  Controlling the value of the SNI used (or more to the point, suggesting a safe value), might give clients a better way to avoid notice.",
      "createdAt": "2018-05-12T00:16:10Z",
      "updatedAt": "2018-05-12T15:35:30Z",
      "closedAt": "2018-05-12T15:35:30Z",
      "comments": [
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed",
          "createdAt": "2018-05-12T15:35:30Z",
          "updatedAt": "2018-05-12T15:35:30Z"
        }
      ]
    },
    {
      "number": 6,
      "id": "MDU6SXNzdWUzMjI0NjY3MjQ=",
      "title": "Do you need the nonce?",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/6",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "You are mixing ClientHello.random in.  That would seem to be sufficient.  From that you can generate the AEAD nonce and key as though this were record protection.\r\n\r\n```\r\nesni_secret = HKDF-Extract(0, Z)\r\nk = HKDF-Expand-Label(esni_secret, \"esni key\", ClientHello.random, L)\r\niv = HKDF-Expand-Label(esni_secret, \"esni key\", ClientHello.random, L)\r\n```\r\n\r\nWe don't need another reason for people to complain about exposing the random number generator state to the network.",
      "createdAt": "2018-05-12T00:20:54Z",
      "updatedAt": "2018-05-12T13:13:33Z",
      "closedAt": "2018-05-12T13:13:33Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "If servers choose to use the same ESNI and semi-static key, not generating and including a nonce could lead to nonce-reuse for 0-RTT data. We talked about just prohibiting this sort of key sharing for servers, though it's good to have a client-side defense against it.",
          "createdAt": "2018-05-12T04:03:57Z",
          "updatedAt": "2018-05-12T04:03:57Z"
        }
      ]
    },
    {
      "number": 7,
      "id": "MDU6SXNzdWUzMjI0NjcyNDA=",
      "title": "Where do the TXT records go?",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/7",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "In DNS, yes, but under what name?  \r\n\r\nI suggest at _esni.<domain>.  Usage of TXT and underscore names is now considered an acceptable way to deploy new features.  It also deploys more reliably than a new RRtype.",
      "createdAt": "2018-05-12T00:26:13Z",
      "updatedAt": "2018-05-12T15:36:25Z",
      "closedAt": "2018-05-12T15:36:25Z",
      "comments": [
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "I would like to note that the use of RRtype would be a no-go for many operators, because you cannot delegate an APEX name.\r\n\r\nMany websites are served by their APEX names. It is common for a web-site publisher to choose different hosting providers for HTTP (i.e. CDN) and DNS. This is especially the case with CDNs relying on anycast.\r\n\r\nThese facts lead to the conclusion that if we choose RRtype as the method, there would often be cases where the DNS record of the ESNIKey and the TLS server would be required to be operated by different entities.\r\n\r\nThis essentially means that there would be high risk of ESNIKey record and the key in TLS server becoming out-of-sync for large amount of deployments.\r\n\r\nHaving such _additional_ risk in operation for a nice-to-have feature like ESNI would be unacceptable for many operators.\r\n\r\nPS. Using TXT records with prefix sounds good to me because we can use CNAME to delegate the ESNIKey when an APEX name is used to serve the website.",
          "createdAt": "2018-05-12T05:42:56Z",
          "updatedAt": "2018-05-12T06:23:23Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "@kazuho: we went with TXT.",
          "createdAt": "2018-05-12T15:36:24Z",
          "updatedAt": "2018-05-12T15:36:24Z"
        }
      ]
    },
    {
      "number": 8,
      "id": "MDU6SXNzdWUzMjI0Njc1NTY=",
      "title": "Explain the DNS layout a little more clearly",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/8",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "When I lookup `hidden.example`, I would expect to have an A (or AAAA) for `hidden.example`, a TXT for `_esni.hidden.example` and nothing more.  \r\n\r\nThe key idea is that all hidden servers that share a front would return the same A records.  You need to say that.",
      "createdAt": "2018-05-12T00:29:21Z",
      "updatedAt": "2018-05-12T15:35:38Z",
      "closedAt": "2018-05-12T15:35:38Z",
      "comments": [
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed",
          "createdAt": "2018-05-12T15:35:38Z",
          "updatedAt": "2018-05-12T15:35:38Z"
        }
      ]
    },
    {
      "number": 10,
      "id": "MDU6SXNzdWUzMjI0ODY4ODQ=",
      "title": "sending certificate chain along with ESNIKeys",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/10",
      "state": "CLOSED",
      "author": "kazuho",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Thank you for working on the draft. I can't be more happy to see someone willing to lead the community towards having a particular ESNI solution.\r\n\r\nConsidering the fact that omitting the certificate chain and the signature was [one of the options discussed in my draft](https://tools.ietf.org/html/draft-kazuho-protected-sni-00#section-5.3) (was originally suggested by @siyengar), I am happy to support the proposal and am willing to implement it.\r\n\r\nOTOH, please let me argue here for sending the certificate-chain along with the ESNIKey.\r\n\r\nWhile I agree that there is no huge difference in terms of security, there are benefits related to performance in sending the certificate chain along with the ESNIKey.\r\n\r\nIn QUIC, we are discussing how many packets a server can send before the client's address is validated. This is because sending packets to an non-validated address is an vector for amplification attacks. We can resolve the issue by sending the certificate chain along with the ESNIKey and using an encrypted variant of Cached Certificate Extension.\r\n\r\nWe also revive the possibility of doing 0-RTT using semi-static key, because the key will be signed by the certificate.\r\n\r\nI think that providing performance improvement might give people more incentive to start using ESNI.",
      "createdAt": "2018-05-12T06:18:51Z",
      "updatedAt": "2018-05-14T13:16:57Z",
      "closedAt": "2018-05-14T13:16:57Z",
      "comments": [
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "@kazuho: you make a good point here (and thanks for doing your original draft; as you can see,  stole a lot of ideas!) and I think it's something we should look into\r\n\r\nI would argue for keeping these two mechanisms separate, for a few reasons:\r\n\r\n1. The cached_info indication would be consumed by the hidden server, not the fronting server, so you have the issues I note in Appendix A.\r\n\r\n2. If we ultimately want to do 0-RTT priming (which seems interesting) we will likely want different keys with different lifetimes.\r\n\r\n3. Not every hidden server may want to support cached_info and so it might make it harder to get wide ESNI deployment.\r\n\r\nIn line with point 3, I think it may be easier to experiment with the simpler mechanism, because we can easily change the semantics to be the ones you propose if we need to, given that the extension is encrypted.\r\n\r\n\r\n\r\n\r\n\r\n",
          "createdAt": "2018-05-12T15:50:10Z",
          "updatedAt": "2018-05-12T15:50:10Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "@ekr Thank you for your comments.\r\n\r\n> I would argue for keeping these two mechanisms separate, for a few reasons:\r\n> \r\n> 1. The cached_info indication would be consumed by the hidden server, not the fronting server, so you have the issues I note in Appendix A.\r\n> \r\n> 2. If we ultimately want to do 0-RTT priming (which seems interesting) we will likely want different keys with different lifetimes.\r\n> \r\n> 3. Not every hidden server may want to support cached_info and so it might make it harder to get wide ESNI deployment.\r\n> \r\n> In line with point 3, I think it may be easier to experiment with the simpler mechanism, because we can easily change the semantics to be the ones you propose if we need to, given that the extension is encrypted.\r\n\r\nI would argue that these three concerns could be resolved by sending the certificate as an optional feature (as well as the 0-RTT a flag in the ESNIKey structure).\r\n\r\nBut having that said, it really depends on if client and resolver developers want to implement. I also understand that a small step is a good thing.\r\n\r\nPlease feel free to close the issue (or float it around if you think we might revisit).\r\n\r\nOTOH, having an `extensions` field might be always a good idea.",
          "createdAt": "2018-05-12T22:17:47Z",
          "updatedAt": "2018-05-12T22:17:47Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "FWIW, you should remember that cached-info will reveal the identity of the server as effectively as SNI.\r\n\r\nI think that I agree with ekr here: priming clients with certificates is valuable, as is priming them for 0-RTT, but both require\r\n\r\nI think that protecting ALPN is of far less interest.  Also, as ekr observes, the lifetime for these keys might be dramatically different.  All in all, that makes me lean more toward the piecemeal approach that this draft suggests, as opposed to the \"just encrypt extensions\" approach that Richard considered.",
          "createdAt": "2018-05-12T23:30:06Z",
          "updatedAt": "2018-05-12T23:30:06Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "> FWIW, you should remember that cached-info will reveal the identity of the server as effectively as SNI.\r\n\r\nWhat I am arguing for is \"an encrypted variant of Cached Certificate Extension\", which is sent by client using the ESNIKey.",
          "createdAt": "2018-05-13T00:09:56Z",
          "updatedAt": "2018-05-13T00:09:56Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "> I think that protecting ALPN is of far less interest. Also, as ekr observes, the lifetime for these keys might be dramatically different. All in all, that makes me lean more toward the piecemeal approach that this draft suggests, as opposed to the \"just encrypt extensions\" approach that Richard considered.\r\n\r\nI agree. Considering the fact that sending the certificate-chain does not improve security, it can be an option that can be added later as an extension.\r\n\r\nDo you think that it would generally be a good idea to have an extensions slot in ESNIKey? I would assume so considering the fact that we now have extensions field in most of the TLS handshake messages.",
          "createdAt": "2018-05-13T00:21:24Z",
          "updatedAt": "2018-05-13T00:21:24Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I don't think we need extensions.  If we miss something, we can add another extension.  We had extensions in (the unencrypted) SNI, and they ended up being unused and unusable eventually.  And there was a clear intended use for those even.",
          "createdAt": "2018-05-13T10:04:20Z",
          "updatedAt": "2018-05-13T10:04:20Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "I think we might be having a confusion here.\r\n\r\nWhat I am arguing for is adding an extensions slot to ESNIKey, which is currently defined as:\r\n```\r\nstruct {\r\n    ESNIKeyShareEntry keys<4..2^16-1>;\r\n    CipherSuite cipher_suites<2..2^16-2>;\r\n    uint16 padded_length;\r\n} ESNIKeys;\r\n```\r\n\r\nThis structure is sent as a DNS record; you cannot extend it. If we want to add additional attributes, we would be forced to define a new DNS record that gets queried simultaneously. I think we do not want to do that.\r\n\r\nI totally agree that we do not need the capability to extend the EncryptedSNI structure.",
          "createdAt": "2018-05-13T12:31:20Z",
          "updatedAt": "2018-05-13T12:31:46Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Ahh, I see what you mean.  Yeah, that's probably fine.",
          "createdAt": "2018-05-14T01:03:27Z",
          "updatedAt": "2018-05-14T01:03:27Z"
        }
      ]
    },
    {
      "number": 14,
      "id": "MDU6SXNzdWUzMjI1MjkwMTM=",
      "title": "Proposed _esni TXT structure does not fit with DNS encodings",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/14",
      "state": "CLOSED",
      "author": "huitema",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The proposed DNS publication method for the key is sketched in section 4, Publishing the SNI Encryption Key. The proposed structure is\r\n~~~\r\n    struct {\r\n        ESNIKeyShareEntry keys<4..2^16-1>;\r\n        CipherSuite cipher_suites<2..2^16-2>;\r\n        uint16 padded_length;\r\n    } ESNIKeys;\r\n~~~\r\nThis can be problematic, given the constraints on TXT records. The practical length of the record payload is at most 255 bytes. The payload content is supposed to be text, which would suggest a base64 encoding, further reducing the available payload size to 189 bytes.\r\n\r\nI would suggest encoding just one key & one ciphersuite per record using base64 encoding, and using multiple records if necessary.",
      "createdAt": "2018-05-12T17:34:36Z",
      "updatedAt": "2018-05-13T03:18:44Z",
      "closedAt": "2018-05-13T03:18:44Z",
      "comments": [
        {
          "author": "ghedo",
          "authorAssociation": "CONTRIBUTOR",
          "body": "FWIW RFC 4408 allows you to have multiple strings in the same TXT record to get around the limit https://tools.ietf.org/html/rfc4408#section-3.1.3\r\n\r\n> one key & one ciphersuite per record\r\n\r\nThis should probably be one key and _all_ cipher suites, since suites and keys are orthogonal to each other.",
          "createdAt": "2018-05-12T18:06:07Z",
          "updatedAt": "2018-05-12T18:06:07Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "We assumed a suitable encoding that would not bump into this bound. Alessandro\u2019s suggestion above seems best.",
          "createdAt": "2018-05-12T18:25:27Z",
          "updatedAt": "2018-05-12T18:25:27Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I really have two concerns, the maximum length and the char requirement. The latter may be an harder issue. For example, can I set a TXT record to contain binary data if I use Amazon's Route 53 service?",
          "createdAt": "2018-05-12T18:28:01Z",
          "updatedAt": "2018-05-12T18:28:01Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "I think we can work around the first with the concatenation suggestion. For the second, I assumed (perhaps incorrectly) any binary data was admissible. If we can\u2019t use binary data, then we can encode it easy enough. ",
          "createdAt": "2018-05-12T18:30:39Z",
          "updatedAt": "2018-05-12T18:30:39Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@huitema Shall we close this?",
          "createdAt": "2018-05-13T00:33:13Z",
          "updatedAt": "2018-05-13T00:33:13Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Closed after merging PR #18",
          "createdAt": "2018-05-13T03:18:44Z",
          "updatedAt": "2018-05-13T03:18:44Z"
        }
      ]
    },
    {
      "number": 15,
      "id": "MDU6SXNzdWUzMjI1Mjk1MjE=",
      "title": "Think of the smiley when forwarding ESNI values",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/15",
      "state": "CLOSED",
      "author": "huitema",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": " Appendix A, Communicating SNI to Hidden Server, specifies mechanisms for providing the hidden server with the selected SNI. We should not assume that the network connection between fronting and hidden is private. An obvious attack path is for the adversary to rent or hack servers in the same location as the hidden server. That's one more reason for not sending the SNI in clear text.",
      "createdAt": "2018-05-12T17:42:02Z",
      "updatedAt": "2018-05-22T18:34:46Z",
      "closedAt": "2018-05-22T18:34:46Z",
      "comments": [
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "I agree with this. Added some clarifying text.",
          "createdAt": "2018-05-12T18:31:42Z",
          "updatedAt": "2018-05-12T18:31:42Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@huitema can we close this?",
          "createdAt": "2018-05-22T14:19:31Z",
          "updatedAt": "2018-05-22T14:19:31Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "body": "EKR mentioned that the text of appendix A was clarified, but I don't see the clarification. The text says:\r\n~~~\r\nAs noted in Section 5.3, in Fronting Mode the hidden server will generally not know the true SNI. It is possible for the fronting server to communicate the true SNI to the hidden server, but at the cost of having that communication not be unmodified TLS 1.3. The basic idea is to have a shared key between the fronting server and the hidden server (this can be a symmetric key) and use it to send Z at the beginning of the connection before the ClientHello. The hidden server can then decrypt ESNI to recover the true SNI.\r\n\r\nAn obvious alternative here would be to have the fronting server forward the true SNI, but that would allow the fronting server to lie. In this design, the attacker would need to be able to find a Z which would expand into a key that would validly AEAD-encrypt a message of his choice, which should be intractable (Hand-waving alert!).\r\n~~~\r\nWhat I don't see is a mention that the network transmission between the fronting server and the hidden server  could be spied upon. I guess I need to propose a PR.\r\n",
          "createdAt": "2018-05-22T14:43:44Z",
          "updatedAt": "2018-05-22T14:43:44Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "Given (a) RFC 3552 and (b) that we propose encrypting the value, I don't really think we need to say that this channel can be observed.",
          "createdAt": "2018-05-22T15:20:47Z",
          "updatedAt": "2018-05-22T15:20:47Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Well, OK. I suppose the requirement for encryption solves the issue.",
          "createdAt": "2018-05-22T18:34:46Z",
          "updatedAt": "2018-05-22T18:34:46Z"
        }
      ]
    },
    {
      "number": 17,
      "id": "MDU6SXNzdWUzMjI1MzI1ODA=",
      "title": "Refresh ESNIKeys with HelloRetryRequest",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/17",
      "state": "CLOSED",
      "author": "ghedo",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Regarding:\r\n\r\n```\r\n- If the EncryptedSNI.label value does not correspond to any known\r\n  SNI encryption key, it MUST abort the connection with an\r\n  \"illegal_parameter\" alert.\r\n  [[OPEN ISSUE: We looked at ignoring the extension but concluded\r\n  this was better.]]\r\n```\r\nRather than aborting, would it make more sense for the server to (optionally?) send a fresh `ESNIKeys` as an extension as part of `HelloRetryRequest`? Example use case would be that for whatever reason (e.g. key compromise?) the server might want to discard a previously advertised `ESNIKeys` before it expires. Not sure if it's worth the added complexity though.\r\n\r\n(With some other changes it could also be used as an alternative way to publish a key at the cost of one round trip, but the usefulness there is probably limited)\r\n",
      "createdAt": "2018-05-12T18:26:58Z",
      "updatedAt": "2018-05-14T17:22:37Z",
      "closedAt": "2018-05-14T17:22:37Z",
      "comments": [
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "I thought about this a bit, but making sure it doesn't allow cut-and-paste attacks seemed like it was going to need a lot of thought.",
          "createdAt": "2018-05-12T18:32:49Z",
          "updatedAt": "2018-05-12T18:32:49Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@ghedo I don't think we should do this. It allows an on-path TCP proxy to inject a HRR, with a fresh ESNI key, and cause the client to reveal its SNI to that proxy. ",
          "createdAt": "2018-05-12T18:43:31Z",
          "updatedAt": "2018-05-12T18:43:31Z"
        },
        {
          "author": "ghedo",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Ugh, right. I guess the server could send the full DNS record, alongside DNSSEC signatures and chain, though that sounds like something that should be done independently from this spec.",
          "createdAt": "2018-05-14T17:22:37Z",
          "updatedAt": "2018-05-14T17:22:37Z"
        }
      ]
    },
    {
      "number": 19,
      "id": "MDU6SXNzdWUzMjI1NDY2ODE=",
      "title": "Specify whether ESNI key is provided by hidden or by fronting server",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/19",
      "state": "CLOSED",
      "author": "huitema",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "chris-wood"
      ],
      "labels": [],
      "body": "The text in section 4, Publishing the SNI Encryption Key, specifies that _if a client queries example.com, the ESNI TXT name is _esni.example.com_. That's fine, but suppose that the client queries \"hidden.example.com\". The client needs to learn that \"hidden.example.com\" is fronted by \"fronting.example.com\" -- per PR #18, the client will do that by obtaining an ALT-SVC record. Should the client get the ESNI key from \"_esni.hidden.example.com\", or from \"_esni.fronting.example.com\" ?",
      "createdAt": "2018-05-12T22:11:46Z",
      "updatedAt": "2018-05-22T14:49:12Z",
      "closedAt": "2018-05-22T14:49:12Z",
      "comments": [
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "@chris-wood I think this is you.",
          "createdAt": "2018-05-12T23:23:18Z",
          "updatedAt": "2018-05-12T23:23:18Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "#18 covers this.  Mostly.  It might pay to observe that the client does not look up and DNS records for the fronting service, it is just the case that all servers in the anonymity set point to the same IP address.  I made similar comments on #18.",
          "createdAt": "2018-05-12T23:25:00Z",
          "updatedAt": "2018-05-12T23:25:00Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "I agree with @martinthomson here. I didn't see the client querying fronting.example.com.",
          "createdAt": "2018-05-12T23:38:42Z",
          "updatedAt": "2018-05-12T23:38:42Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "body": "That means all servers that share the same IP need to publish the same key. Are we confident that there is no synch issue during key rollover?",
          "createdAt": "2018-05-13T00:05:34Z",
          "updatedAt": "2018-05-13T00:05:34Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Servers can publish multiple ESNI keys with different labels in a record. That way they can retire one key and start using another as needed. Though it might be good (necessary?) to require clients to use one of those keys. ",
          "createdAt": "2018-05-13T00:30:04Z",
          "updatedAt": "2018-05-13T00:30:04Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "> Servers can publish multiple ESNI keys with different labels in a record. That way they can retire one key and start using another as needed.\r\n\r\nWhile that is possible, I am not sure if it would be the approach that would generally be used.\r\n\r\nThe issue is identical to the encryption key of the session tickets. In case of session tickets, we encrypt the ticket using one key, and send the identifier of the key along with the encrypted ticket.\r\n\r\nWhen we rollover the keys, we first deploy a new key to the server as well as keeping the old one alive for decryption only. And we retire the old key after certain amount of period that we become sure that it is no longer used.\r\n\r\nI'd assume that we can and will use the same approach for ESNIKeys.",
          "createdAt": "2018-05-14T05:29:19Z",
          "updatedAt": "2018-05-14T05:33:45Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "PS. therefore, it is possible to have just one label for the set of keys rather than having labels for each of the keys (assuming that we can remove the \"choose one at random\" rule). In that approach, a server will identify the key being used by looking at the `(label, group)` tuple.\r\n\r\nThe benefit will be that you will save the space of N-1 labels assuming that you are sending N key shares. Identification of the key on the server-side might seem complicated, but I actually think that it simplifies things, because a server operator is anyways expected to deploy the entire set of keys found in ESNIKeys at the same moment.",
          "createdAt": "2018-05-14T05:41:16Z",
          "updatedAt": "2018-05-14T05:51:07Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "> therefore, it is possible to have just one label for the set of keys rather than having labels for each of the keys (assuming that we can remove the \"choose one at random\" rule)\r\n\r\nTo me it seems that this is necessary to prevent downgrade attack. Hence #24.",
          "createdAt": "2018-05-14T12:02:31Z",
          "updatedAt": "2018-05-14T12:02:31Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "body": "How do we prevent labels from becoming identifiers?",
          "createdAt": "2018-05-14T13:36:56Z",
          "updatedAt": "2018-05-14T13:36:56Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Labels as identifiers seem problematic in both approaches -- current and #24. ",
          "createdAt": "2018-05-14T13:43:30Z",
          "updatedAt": "2018-05-14T13:43:30Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "Would you mind elaborating why label becomes an identifier? We state in the document that the probability of identifying the hidden server is 1/N where N is the number of the hosts belonging to the same set of hidden servers. A label represents that entire set.\r\n\r\nSo I do not think it is an issue.",
          "createdAt": "2018-05-14T15:23:44Z",
          "updatedAt": "2018-05-14T15:23:44Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Now that #43 is merged, which removes the label altogether, and we've added text describing the anonymity set for hidden servers, I think this issue is covered. @huitema do you agree?",
          "createdAt": "2018-05-22T14:21:18Z",
          "updatedAt": "2018-05-22T14:21:18Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The label issue is definitely covered. ",
          "createdAt": "2018-05-22T14:49:12Z",
          "updatedAt": "2018-05-22T14:49:12Z"
        }
      ]
    },
    {
      "number": 20,
      "id": "MDU6SXNzdWUzMjI1NTIxMjg=",
      "title": "Client-side verification of ESNIKeys",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/20",
      "state": "CLOSED",
      "author": "kazuho",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The biggest concern from web-site operators will be the possibility of out-of-sync or broken ESNIKeys leading to service disruption.\r\n\r\nConsidering that, I propose having two attributes being added:\r\n* validity - we can borrow `notBefore` and `notAfter` from PKIX\r\n* checksum - something like 32-bits would be enough\r\n\r\nSeeing wired ESNIKeys will become a big issue especially if the clients accept ESNIKeys sent from low-quality resolvers / proxies (e.g. those in home routers).\r\n\r\nPS. One alternative approach would be to use HTTP (.well-known URI) as a transport of the semi-static key between the TLS server and the resolver. Then, we can use the vocabulary of HTTP to implement client-side verification.",
      "createdAt": "2018-05-13T00:06:15Z",
      "updatedAt": "2018-05-14T16:04:43Z",
      "closedAt": "2018-05-14T16:04:43Z",
      "comments": []
    },
    {
      "number": 25,
      "id": "MDU6SXNzdWUzMjI3OTQ4ODI=",
      "title": "wildcard delegations to hidden server",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/25",
      "state": "CLOSED",
      "author": "kazuho",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Current text says:\r\n> If the serialized ServerNameList is longer than ESNIKeys.padded_length, the client MUST NOT use\r\nthe \"encrypted_server_name\" extension.\r\n\r\nHowever, I am not sure if this is the desired behavior. I would rather suggest encrypting even when the hostname exceeds the padded_length. Having some protection is better than none.\r\n\r\nThe issue is that in certain deployments it is impossible to guess what the maximum length of the hostname will be. Consider `*.github.io`. It uses a wildcard certificate. Anybody can add a new hostname of any length by creating a new Github account (it might be true that Github some limitation on the length, but that does not necessarily mean that Github shares the maximum length information with the fronting CDN, assuming that it uses a CDN).",
      "createdAt": "2018-05-14T12:27:23Z",
      "updatedAt": "2018-06-21T13:19:04Z",
      "closedAt": "2018-06-21T13:19:04Z",
      "comments": [
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "I have filed #26 that fixes another issue (it's just a clarification of an open issue) related to wildcard delegation.",
          "createdAt": "2018-05-14T12:33:38Z",
          "updatedAt": "2018-05-14T12:33:38Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Technically, it is possible to guess the maximum length of the hostname, as that maximum textual representation length is defined as 253 bytes per RFC 1034.",
          "createdAt": "2018-05-16T06:24:06Z",
          "updatedAt": "2018-05-16T06:24:06Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "Yes. So the question is if a CDN that has a wildcard mapping needs to set `padded_length` to 253 (since current text is a MUST NOT for sending a server name longer than the padded_length), or if we should introduce a different rule.",
          "createdAt": "2018-05-16T12:16:10Z",
          "updatedAt": "2018-05-16T12:16:10Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "How about something like:\r\n\r\npadded_length : The length to pad the ServerNameList value to prior to encryption. This value SHOULD be set to the largest ServerNameList the fronting server expects to support rounded up the nearest multiple of 16. If the fronting server supports wildcard names, it SHOULD set this value to 256.",
          "createdAt": "2018-05-16T18:10:58Z",
          "updatedAt": "2018-05-16T18:10:58Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "@DavidSchinazi Thank you for the suggestion.\r\n\r\nI was feeling uneasy (and am still feeling a bit) about requiring the client to send an ESNI extension as large as ~300 bytes, assuming that CDN's would have at least one wildcard mappings.\r\n\r\nBut it's about the first packet sent from the client, and we typically have enough room even when 0-RTT data is involved. So I think that we can live with that.",
          "createdAt": "2018-05-25T05:42:35Z",
          "updatedAt": "2018-05-25T05:42:35Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "To be closed by #48.",
          "createdAt": "2018-05-26T05:09:23Z",
          "updatedAt": "2018-05-26T05:09:23Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "Closed by #48.",
          "createdAt": "2018-06-21T13:19:04Z",
          "updatedAt": "2018-06-21T13:19:04Z"
        }
      ]
    },
    {
      "number": 27,
      "id": "MDU6SXNzdWUzMjI4MjQ2NjI=",
      "title": "Client and server ESNI key selection",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/27",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Doing so doesn't allow a server to gracefully generate new ESNI keys and retire old ones. We should mandate that clients always choose the first ESNI key for which they have group support. If we adopt #24, where servers lookup keys with a (label, group) -> key mapping, should we also require that each label have the same groups? ",
      "createdAt": "2018-05-14T13:48:27Z",
      "updatedAt": "2018-07-02T14:17:59Z",
      "closedAt": "2018-07-02T14:17:59Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@kazuho what do you think?",
          "createdAt": "2018-05-14T13:49:00Z",
          "updatedAt": "2018-05-14T13:49:00Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "I am not sure what you mean by \"doing so\", but the model I expect is something like following assuming that we adopt #24.\r\n\r\n* the fronting server generates a new ESNIKeys and pushes it to DNS server every 1 hour\r\n  * TTL will be set to 5 minutes ~~`not_after` - now~~<sup>1</sup>\r\n* the fronting server will accept the following keys to be used in the EncryptedSNI extension:\r\n  * the key for the current hour\r\n  * the key for the previous hour, for the first 10 minutes of every hour\r\n\r\nA ESNIKeys record can contain multiple keys belonging to different groups, but not belonging to the same group. So there is no ambiguity by specifying the key using (label, group).\r\n\r\nThe server can add a new Named Group or retire one when it generates a new ESNIKeys.\r\n\r\n[1] updated to reflect the fact that we can only use a constant TTL in the standard way of DNS server synchronization (i.e. DNS zone transfer) (02:47UTC May 15 2018)",
          "createdAt": "2018-05-14T15:15:13Z",
          "updatedAt": "2018-05-15T02:47:14Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "That seems perfectly fine. But it does mean that there exists only one key per group at any given point in time. Is that a restriction we are comfortable with?",
          "createdAt": "2018-05-14T15:18:39Z",
          "updatedAt": "2018-05-14T15:18:39Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "> That seems perfectly fine. But it does mean that there exists only one key per group at any given point in time. \r\n\r\nI don't think so. A DNS server can send different ESNIKeys at the same hour using short TTL (e.g. 60 seconds) in response to different queries (a.k.a. round-robin DNS).",
          "createdAt": "2018-05-14T15:20:58Z",
          "updatedAt": "2018-05-14T15:20:58Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Sorry, I mean within a single record. ",
          "createdAt": "2018-05-14T15:21:46Z",
          "updatedAt": "2018-05-14T15:21:46Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "I am comfortable with not having that. You can only have a handful of keys in ESNIKeys anyways.\r\n\r\nI'd assume that either one would be enough or we would need a way to distribute more than just a handful, for which we can use round-robin.",
          "createdAt": "2018-05-14T15:26:29Z",
          "updatedAt": "2018-05-14T15:26:29Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "SGTM. We should add this rationale as text to the DNS record section. ",
          "createdAt": "2018-05-14T15:29:09Z",
          "updatedAt": "2018-05-14T15:29:09Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think that TTL suffices here.",
          "createdAt": "2018-05-15T01:04:22Z",
          "updatedAt": "2018-05-15T01:04:22Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "@martinthomson FWIW, `not_after` is now in master. We can certainly discuss about the necessity, but you might want to see the debate on #23.",
          "createdAt": "2018-05-15T05:05:23Z",
          "updatedAt": "2018-05-15T05:05:23Z"
        },
        {
          "author": "ghedo",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@kazuho I think your point in the PR is quite valid. However it's probably worth noting that having explicit not_before / not_after that the client has to validate, is likely to make it very difficult, if not impossible, to deploy very-short-lived keys (say, in the order of a few hours), due to the fact that a significant portion of clients have shitty clocks (https://ai.google/research/pubs/pub46359), which affects forward secrecy.\r\n\r\nMaybe it should be noted in the spec as an appendix or something.",
          "createdAt": "2018-05-22T17:57:46Z",
          "updatedAt": "2018-05-22T17:57:46Z"
        },
        {
          "author": "ghedo",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Hmmm, thinking about this some more. In the \"split brain\" case @kazuho described in #23, the not_after is used to avoid having clients send an ESNI encrypted with an old key (as fetched from an out-of-date DNS server), to a TLS server that might have already switched to a new key (thus causing the connection to break).\r\n\r\nSo i'm guessing what happens is that the client would fallback to plaintext SNI if the key it fetched from DNS is expired. Though it seems to me this fallback could be dangerous for the client since they would end up exposing the SNI, but I can't come up with a practical way to exploit this (could be dependent on the specific deployment I guess).\r\n\r\nWhether this is something worth fixing is a different question, but an alternative to fix the split brain problem would be for the TLS server to somehow make sure the new key has been received by the DNS server, before discarding the old one.\r\n\r\nDid I understand the problem you described in #23 correctly @kazuho ?",
          "createdAt": "2018-05-22T20:18:23Z",
          "updatedAt": "2018-05-22T20:18:23Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "@ghedo Thank you for your comments.\r\n\r\n> I think your point in the PR is quite valid. However it's probably worth noting that having explicit not_before / not_after that the client has to validate, is likely to make it very difficult, if not impossible, to deploy very-short-lived keys (say, in the order of a few hours), due to the fact that a significant portion of clients have shitty clocks (https://ai.google/research/pubs/pub46359), which affects forward secrecy.\r\n\r\nI think you are correct in stating that the ESNIKeys cannot have a very short lifetime. However, I would like to argue that the fact does not prevent server operators from rotating the keys frequently.\r\n\r\nServer operators can rotate the keys at the speed they like, as well as retiring them from the servers in any way.\r\n\r\n> So i'm guessing what happens is that the client would fallback to plaintext SNI if the key it fetched from DNS is expired. Though it seems to me this fallback could be dangerous for the client since they would end up exposing the SNI, but I can't come up with a practical way to exploit this (could be dependent on the specific deployment I guess).\r\n\r\nI agree with what happens.\r\n\r\nIn my view, ESNI is opportunistic encryption in sense that the unencrypted hostname is used when the ESNI resource record fails to reach the client (including the case of a middlebox dropping it intentionally).\r\n\r\nI would argue that using SNI in case of receiving an expired ESNI record is one of the failure modes in distributing the correct resource record. And therefore, I do not think that it is a security concern.\r\n\r\n> Whether this is something worth fixing is a different question, but an alternative to fix the split brain problem would be for the TLS server to somehow make sure the new key has been received by the DNS server, before discarding the old one.\r\n\r\nThat is correct. However, I fear that having such a requirement hinders us from using existing DNS deployments, because DNS authoritative servers are designed to favor availability over consistency, whereas in our case without `not_after`, we need consistency over availability.",
          "createdAt": "2018-05-23T02:02:02Z",
          "updatedAt": "2018-05-23T02:02:02Z"
        },
        {
          "author": "ghedo",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Server operators can rotate the keys at the speed they like, as well as retiring them from the servers in any way.\r\n\r\nI didn't realize that was possible (that is, I kind of assumed servers would have to keep the key around until the not_after expired, but it's not actually written anywhere). In that case fine, though it might be worth clarifying.\r\n\r\nThe other concern I had was risking of turning this into another OCSP (where network failure and attack basically look the same so clients end up ignoring both), but I guess that with DoH, DPRIVE and DNSSEC an attack here is much harder to pull off. So all in all I don't have a strong opinion on not_before / not_after anymore.",
          "createdAt": "2018-06-01T19:15:50Z",
          "updatedAt": "2018-06-01T19:15:50Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "I think this is fine, @chris-wood please re-open if not.",
          "createdAt": "2018-07-02T14:17:59Z",
          "updatedAt": "2018-07-02T14:17:59Z"
        }
      ]
    },
    {
      "number": 28,
      "id": "MDU6SXNzdWUzMjI4Njk1MDM=",
      "title": "Recast Fronting mode as Split Mode",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/28",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "chris-wood"
      ],
      "labels": [],
      "body": "Domain fronting already has a bad rap. Perhaps we should give this a new name to avoid pushback?",
      "createdAt": "2018-05-14T15:33:48Z",
      "updatedAt": "2018-05-22T14:18:55Z",
      "closedAt": "2018-05-22T14:18:55Z",
      "comments": [
        {
          "author": "ghedo",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Agree, Maybe \"Transparent\" mode? \"Proxy\" mode?",
          "createdAt": "2018-05-14T17:32:16Z",
          "updatedAt": "2018-05-14T17:32:16Z"
        },
        {
          "author": "mcmanus",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'm going to go a step farther and suggest only defining shared mode in this document.\r\n\r\nit brings esni to the masses and eliminates the need for special tech to acheive classic fronting. That's a significant net-win without being weighed down by bias about fronting - I think we'll get more participation that way because the set of goals is easier to achieve consensus on (privacy is good!)\r\n\r\nIf folks need a separate document later to figure out they can tunnel based on the decrypted SNI then istm it can be separable.. true?\r\n",
          "createdAt": "2018-05-15T18:00:31Z",
          "updatedAt": "2018-05-15T18:00:31Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@mcmanus My reservation there is that, with only Shared Mode, a better design is probably to encrypt all of the extensions, and not just the SNI. With that change, it then later becomes infeasible to accomplish the front/hidden split. ",
          "createdAt": "2018-05-20T23:58:11Z",
          "updatedAt": "2018-05-20T23:58:11Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing via #45. @mcmanus if we want to keep only Shared Mode, let's use a new issue to track that.",
          "createdAt": "2018-05-22T14:18:55Z",
          "updatedAt": "2018-05-22T14:18:55Z"
        }
      ]
    },
    {
      "number": 29,
      "id": "MDU6SXNzdWUzMjI5MDk3MzY=",
      "title": "Why single A and AAAA requirements?",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/29",
      "state": "CLOSED",
      "author": "ghedo",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Regarding:\r\n```\r\nServers SHOULD configure DNS such that, upon querying a domain name with ESNI support, at most one each of A, AAAA, TXT ESNI, and ALTSVC {{?I-D.schwartz-httpbis-dns-alt-svc}} Resource Record is returned.\r\n```\r\nWhy is that a SHOULD? Does it apply to both fronting and shared mode?\r\n\r\nFor reference, Cloudflare almost always sends at least two A and AAAA answers for every question.\r\n\r\n(I get that it's not a MUST, though I'd also like to understand what the reasoning is in the first place)",
      "createdAt": "2018-05-14T17:27:10Z",
      "updatedAt": "2018-05-14T22:50:01Z",
      "closedAt": "2018-05-14T22:50:01Z",
      "comments": [
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "@chris-wood ??",
          "createdAt": "2018-05-14T19:51:09Z",
          "updatedAt": "2018-05-14T19:51:09Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "The idea was to simplify key management. If multiple A or AAAA records are returned, the server needs to ensure each server behind those addresses have all the necessary keys. ",
          "createdAt": "2018-05-14T19:52:31Z",
          "updatedAt": "2018-05-14T19:52:31Z"
        },
        {
          "author": "ghedo",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@chris-wood I see, I'd rather the spec said that instead of trying to impose limits (I made #31 with suggested fix).",
          "createdAt": "2018-05-14T22:18:56Z",
          "updatedAt": "2018-05-14T22:18:56Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@ghedo works for me :)",
          "createdAt": "2018-05-14T22:28:59Z",
          "updatedAt": "2018-05-14T22:28:59Z"
        }
      ]
    },
    {
      "number": 30,
      "id": "MDU6SXNzdWUzMjI5MzE2MjA=",
      "title": "Rename ESNIKeys to something more generic",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/30",
      "state": "CLOSED",
      "author": "ghedo",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "With #22 merged, I wonder if the ESNIKeys struct should just be renamed to something not specific to ESNI, but something more like \"generic TLS config in DNS\" so that it can be more cleanly reused by unrelated features.\r\n\r\n\"ServerConfiguration\" comes to mind from the early TLS 1.3 days.",
      "createdAt": "2018-05-14T18:33:48Z",
      "updatedAt": "2018-05-17T19:56:27Z",
      "closedAt": "2018-05-17T19:56:27Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "If we were to re-use these keys for other purposes, that seems fine. However, I'm not sure we want to do that. Semi-static keys, for example, should ideally be separate.",
          "createdAt": "2018-05-14T21:41:23Z",
          "updatedAt": "2018-05-14T21:41:23Z"
        },
        {
          "author": "ghedo",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The keys yes, but I imagine the extensions field can hold \"arbitrary\" data, so while the keys would be ESNI-specific, you could also include extensions that have nothing to do with ESNI.",
          "createdAt": "2018-05-14T21:59:22Z",
          "updatedAt": "2018-05-14T21:59:22Z"
        },
        {
          "author": "ghedo",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thinking about this some more, this would also require changing the \"_esni.\" prefix to something else.\r\n\r\nIn any case I can see how this might be out of scope for this spec. In the end it's a matter of deciding whether future TLS extensions that need similar DNS records, should be able to reuse the same structure (so no additional TXT record with its own prefix would be required), or if they should define their own structure (and have a separate TXT record).\r\n\r\nI'm happy to close this if it goes too much out of scope.",
          "createdAt": "2018-05-14T22:27:54Z",
          "updatedAt": "2018-05-14T22:27:54Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Right, I think it's verging on being out of scope. What do others think? @kazuho @ekr?",
          "createdAt": "2018-05-14T22:28:37Z",
          "updatedAt": "2018-05-14T22:28:37Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "My preference goes to keeping the name as-is, considering the fact that the role of ESNIKeys is  (at least for the moment) to negotiate properties between the client and the fronting server (not the hidden server), and that the only property we need to negotiate between the two is the information necessary for ESNI protection.\r\n\r\nIt is true that the DNS record can covey properties related to the hidden server (as you know, I've argued for using it to carry the server certificate chain). But IMO that's a change of concept, and I prefer keeping the concept simple for the time being.",
          "createdAt": "2018-05-14T22:55:51Z",
          "updatedAt": "2018-05-14T22:55:51Z"
        },
        {
          "author": "ghedo",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Ok.",
          "createdAt": "2018-05-17T19:56:27Z",
          "updatedAt": "2018-05-17T19:56:27Z"
        }
      ]
    },
    {
      "number": 32,
      "id": "MDU6SXNzdWUzMjMzMTUwODg=",
      "title": "Add text comparing ESNI to alternative approaches",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/32",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Others include those discussed in I-D.ietf-tls-sni-encryption and the H2-layer approach with secondary certs.",
      "createdAt": "2018-05-15T17:35:54Z",
      "updatedAt": "2018-07-02T14:18:08Z",
      "closedAt": "2018-07-02T14:18:08Z",
      "comments": []
    },
    {
      "number": 33,
      "id": "MDU6SXNzdWUzMjMzMTYyMjE=",
      "title": "Add text regarding fallback",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/33",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-05-15T17:39:26Z",
      "updatedAt": "2018-10-21T20:36:28Z",
      "closedAt": "2018-10-21T20:36:28Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Any on-path active attacker can send an unsigned alert in response to a CH it doesn't like, so perhaps it's best just to acknowledge this. ",
          "createdAt": "2018-05-15T17:43:08Z",
          "updatedAt": "2018-05-15T17:43:08Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "More than acknowledge this, should we make a recommendation as to whether the client should fail hard or fallback to unencrypted SNI?",
          "createdAt": "2018-05-16T06:48:31Z",
          "updatedAt": "2018-05-16T06:48:31Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@DavidSchinazi I don't think so. ",
          "createdAt": "2018-05-16T22:03:13Z",
          "updatedAt": "2018-05-16T22:03:13Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Can you elaborate?",
          "createdAt": "2018-05-16T23:59:19Z",
          "updatedAt": "2018-05-16T23:59:19Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "AFAIK, the 1.3 draft makes no recommendation for dealing with this particular problem, and so I think we shouldn't do so here, either.",
          "createdAt": "2018-05-17T19:49:22Z",
          "updatedAt": "2018-05-17T19:49:22Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Do you mean fallback to TLS 1.2 or fallback to unencrypted SNI? The latter is a new privacy concern that arises in this document so we may want recommendations for that one.",
          "createdAt": "2018-05-17T20:21:28Z",
          "updatedAt": "2018-05-17T20:21:28Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "I see little difference between those fallbacks since they're triggered the same way. So I would prefer to simply acknowledge the problem and nothing more.",
          "createdAt": "2018-05-17T20:24:50Z",
          "updatedAt": "2018-05-17T20:24:50Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Acknowledging is fine if you explain the properties so implementers can make an informed decision knowing the consequences. Also these fallbacks are very different in my mind. TLS 1.3->1.2 has downgrade prevention, whereas once you've fallen back to unencrypted SNI it's too late you've leaked it.",
          "createdAt": "2018-05-17T20:35:59Z",
          "updatedAt": "2018-05-17T20:38:31Z"
        },
        {
          "author": "mhofman",
          "authorAssociation": "NONE",
          "body": "I agree there may be a risk of leaking SNI here.\r\n\r\nIf an attacker is on the path between the client and fronting server, it is capable of forcing a downgrade to a TLS 1.2 connection. Even if such downgrade might ultimately cause the connection to fail, some clients could be tricked into revealing the unencrypted server name.\r\n\r\nWhile the [Section 6.1. Misconfiguration](https://github.com/ekr/draft-rescorla-tls-esni/blob/master/draft-ietf-tls-esni.md#misconfiguration) states that `Clients SHOULD NOT fall back to cleartext SNI, because that allows a network attacker to disclose the SNI`, there is a risk that the client implementation would just switch to a 1.2 mode that completely omits any ESNI logic.\r\n\r\nThe middlebox section also focuses mostly on the stripping of the explicit encrypted_server_name extension. In a downgrade scenario, the stripping could be implicitly performed by the client.\r\n\r\nI think there should be a more explicit protection against MITM middleboxes that force a downgrade of the connection to 1.2.",
          "createdAt": "2018-09-27T19:24:05Z",
          "updatedAt": "2018-09-27T19:24:05Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "We now forbid negotiating 1.2.",
          "createdAt": "2018-10-21T20:36:28Z",
          "updatedAt": "2018-10-21T20:36:28Z"
        }
      ]
    },
    {
      "number": 34,
      "id": "MDU6SXNzdWUzMjMzMjcxMDE=",
      "title": "altsvc",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/34",
      "state": "CLOSED",
      "author": "mcmanus",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "I suggest dropping the references to Ben's individual alt-svc in DNS draft.. it hasn't been adopted and its future is murky.\r\n\r\nactual alt-svc (the non dns kind) actually requires the use of the plaintext SNI. As those are both cachable and connections to new IP addresses (less linkable) you could consider updating it with mike bishop's https://tools.ietf.org/html/draft-bishop-httpbis-sni-altsvc-01 (also an individual draft atm)\r\n\r\n",
      "createdAt": "2018-05-15T18:13:00Z",
      "updatedAt": "2018-05-17T20:29:24Z",
      "closedAt": "2018-05-17T20:29:24Z",
      "comments": [
        {
          "author": "ghedo",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@chris-wood also suggested that the reference might not be needed in https://github.com/ekr/draft-rescorla-tls-esni/pull/31#discussion_r188117285 so I made #44 to actually remove it.",
          "createdAt": "2018-05-17T20:01:41Z",
          "updatedAt": "2018-05-17T20:01:41Z"
        }
      ]
    },
    {
      "number": 35,
      "id": "MDU6SXNzdWUzMjMzMzM1OTk=",
      "title": "define rules for cname (aka multi-cdn or multi-cloud)",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/35",
      "state": "CLOSED",
      "author": "mcmanus",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "traditional SNI is the origin name. You can use an HTTP connect tunnel, traverse a CNAME (or 3), or engage in some alt-svc load balancing and, while these things all change the DNS name you lookup and connect() to, they don't change the SNI.\r\n\r\nwhat about eSNI? the keys are a property of the server, not really the origin. It seems really hard to coordinate this across administrative domains.\r\n\r\nThe case I'm particularly worried about is where more than one hosting provider is in the mix.. ISTM a typical way of doing this is LB'ing DNS responses with CNAMEs. (e.g. 50% of www.example.com gets CNAME www.cdnA.com and 50% gets www.cdnB.com).. We've got folks from 2 CDNs as active contributors here who know better than I, but this kind of level of indirection to get you CDN agility seems pretty common.. we would want cdnA and cdnB to be able to each use their own keys.\r\n\r\nEven without agility, its a pretty common pattern for an origin to maintain control of their own DNS and only delegate to a CDN under load/whatnot and do that via cname...\r\n\r\nthat argues to me to allow _esni TXT records on the server lookup, not just the origin name. Perhaps they could override the _esni at the origin scope but that seems like a way to trigger the misconfiguration fallback path.\r\n\r\nAlso, what about connect tunnels where you do do SNI, but don't traditionally do DNS at all?\r\n\r\n",
      "createdAt": "2018-05-15T18:32:29Z",
      "updatedAt": "2019-06-05T14:51:05Z",
      "closedAt": "2019-06-05T14:51:05Z",
      "comments": [
        {
          "author": "mcmanus",
          "authorAssociation": "CONTRIBUTOR",
          "body": "rfc 1034 (I cannot figure out if this provision has been udpated) says\r\n\r\nThe domain system provides such a feature using the canonical name\r\n(CNAME) RR.  A CNAME RR identifies its owner name as an alias, and\r\nspecifies the corresponding canonical name in the RDATA section of the\r\nRR.  If a CNAME RR is present at a node, no other data should be\r\npresent; this ensures that the data for a canonical name and its aliases\r\ncannot be different.  This rule also insures that a cached CNAME can be\r\nused without checking with an authoritative server for other RR types.\r\n",
          "createdAt": "2018-05-15T19:03:20Z",
          "updatedAt": "2018-05-15T19:03:20Z"
        },
        {
          "author": "mcmanus",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I guess there is also the question of whether a txt query of _esni.www.example.com can return a CNAME even if www.exmaple.com returned A/AAAA (which would seem to be a good way to keep your keys straight.)\r\n\r\n",
          "createdAt": "2018-05-15T19:05:46Z",
          "updatedAt": "2018-05-15T19:05:46Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "> I guess there is also the question of whether a txt query of _esni.www.example.com can return a CNAME even if www.exmaple.com returned A/AAAA (which would seem to be a good way to keep your keys straight.)\r\n\r\nWe need to allow this. As you said, certain CDNs do not provide DNS as a service and their customers use their own DNS. Please see my comment on https://github.com/ekr/draft-rescorla-tls-esni/issues/7#issuecomment-388531906.\r\n\r\nRegarding the multi-CDN use-case, I do not think there is a easy solution.\r\n\r\nOne way of supporting that kind of configuration will be to do the following:\r\n1. (instead of querying for A and _eni) client only queries for A. Let's consider example.com is queried for and 1.2.3.4 is returned.\r\n2. client then connects to the return address via https to obtain the ESNIKeys (i.e. https://1.2.3.4/.well-known/esni-keys/example.com\r\n3. client connects to 1.2.3.4 with ESNI specifying \"example.com\"\r\n\r\nBut this has more overhead, looks more like TLS tunneling...\r\n\r\nHonestly, I'd prefer to not covering multi-CDN use-case. IIUC it's mostly for entertainment content. They need least protection, to the extent to which some believe that serving using plaintext HTTP is fine.",
          "createdAt": "2018-05-15T20:38:28Z",
          "updatedAt": "2018-05-15T20:38:28Z"
        },
        {
          "author": "mcmanus",
          "authorAssociation": "CONTRIBUTOR",
          "body": "we need to document that when a.example.com -> cname b.example.com the TXT record that is looked up is _esni.b.example.com\r\n\r\nWe also need to document that when _esni.b.example.com is a CNAME to c.example.com the TXT record is recursively looked up from c.example.com not _esni.c.example.com. (If they want that behavior the CNAME should be from b.example.com to c.example.com).\r\n",
          "createdAt": "2018-07-03T15:58:48Z",
          "updatedAt": "2018-07-03T15:58:48Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "> we need to document that when a.example.com -> cname b.example.com the TXT record that is looked up is _esni.b.example.com\r\n\r\nI am not sure if using an _intermediate_ result of address resolution as a key to obtain ESNI is a good approach. Rather, I would argue that `_esni.a.example.com` should be used in that case, due to the following reasons:\r\n\r\n* some APIs used for querying a hostname (or a DNS record) might resolve CNAME's by itself\r\n  * `getaddrinfo` is one of such APIs, though it does not provide you the ability to query TXT records\r\n* we can fully parallelize the address resolution and the ESNI key resolution if we select `_esni.original-host` as the name\r\n\r\nIf we are _not_ going to use the original hostname, I wonder if we could use the final result rather than the intermediate result (e.g., assuming that a.example.com results to 192.0.2.1, query `_esni.1.2.0.192.in-addr.apa`). That solves the API issue and the multi-CDN use-case, with the downside being that the queries cannot be parallelized.",
          "createdAt": "2018-07-04T01:15:43Z",
          "updatedAt": "2018-07-04T01:15:43Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I agree with @kazuho.  You start with A/AAAA requests to example.com and TXT requests to _esni.example.com and see where each leads you.  The point about _esni. using CNAME to point to a leaf that might not have the underscore is valuable.",
          "createdAt": "2018-07-04T02:36:07Z",
          "updatedAt": "2018-07-04T02:36:07Z"
        },
        {
          "author": "mcmanus",
          "authorAssociation": "CONTRIBUTOR",
          "body": "the use case not being captured is when www.example.com is a cname to\nwww.cdn-a.com (and at other times a cname to www.cdn-b.com). presumably the\nonus to manage their key records falls on cdn-a and cdn.b and should\nrequire example.com to be managing the _esni record. (example.com may not\neven be aware which cdn is currently doing esni)\n\n\nOn Tue, Jul 3, 2018 at 10:36 PM, Martin Thomson <notifications@github.com>\nwrote:\n\n> I agree with @kazuho <https://github.com/kazuho>. You start with A/AAAA\n> requests to example.com and TXT requests to _esni.example.com and see\n> where each leads you. The point about _esni. using CNAME to point to a leaf\n> that might not have the underscore is valuable.\n>\n> \u2014\n> You are receiving this because you authored the thread.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/ekr/draft-rescorla-tls-esni/issues/35#issuecomment-402345849>,\n> or mute the thread\n> <https://github.com/notifications/unsubscribe-auth/AAP5s1q0uoHCz_HMIKovuOw4eQ1kRflNks5uDCoXgaJpZM4UADk5>\n> .\n>\n",
          "createdAt": "2018-07-04T02:48:26Z",
          "updatedAt": "2018-07-04T02:48:26Z"
        },
        {
          "author": "sludin",
          "authorAssociation": "NONE",
          "body": "I know this is three months old, but did the CDN case get landed?  Entities using multiple CDNs, or even an entity flipping between using a CDN and not is a reality that needs to be fully thought through.  Reading through the tickets and RFC I am concerned about:\r\n  - The apparent need to share the private key between entities\r\n  - The possibility of the TXT or RR record returning information for one CDN and then the A record returning information for another (in cases where there are multiple keys).\r\n\r\n",
          "createdAt": "2018-10-04T18:36:15Z",
          "updatedAt": "2018-10-04T18:36:15Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@mcmanus I think this issue is resolved. Can you please confirm and close if so?",
          "createdAt": "2019-06-02T14:56:18Z",
          "updatedAt": "2019-06-02T14:56:18Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing as resolved. Please re-open if something's still needed!",
          "createdAt": "2019-06-05T14:51:05Z",
          "updatedAt": "2019-06-05T14:51:05Z"
        }
      ]
    },
    {
      "number": 37,
      "id": "MDU6SXNzdWUzMjM0Mjg1MDE=",
      "title": "Remove the fronting / hidden server distinction",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/37",
      "state": "CLOSED",
      "author": "kontaxis",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "In 3.1 Topologies, in Shared Mode topology the fronting and hidden servers are one and the same.\r\n\r\nFronting Mode Topology is described as \"... might not be the origin for any domains, but as a practical matter, it is probably the origin for a large set of innocuous domains\".\r\n\r\nWhy are some domains innocuous and others aren't?\r\nIs it ok for an attacker (adversary) to discover innocuous domains names?\r\n\r\nInnocuous domain names may provide cover when the threat model includes censorship.\r\nIs this what you are trying to solve here?\r\nIsn't that orthogonal to ESNI, i.e., architectures where there is a cover reason why a client is communicating with a server? (because it's a known CDN or sth)\r\n\r\n\r\nIn 5.2 Fronting Server Behavior the text says \"Upon determining the true SNI, the fronting server then either serves the connection directly (if in Shared Mode), in which case it executes the steps in the following section, or forwards the TLS connection to the hidden server (if in Fronting Mode).\"\r\n\r\n... or decrypts the TLS connections and forwards plain text traffic to the hidden server. (Bad idea I know)\r\nThe question is why should this document describe what happens after a TLS connection is established between a client and server? Seems to deviate from the problem this document is trying to address. (See below)\r\n\r\n\r\nIntroduction implicitly defines the problem as \"an on-path attacker to determine the domain name\"\r\nThis is always true with ESNI between the client and fronting server.\r\nAll domain names are hidden, innocuous, non-innocuous, hosted in the fronting or some other server.\r\n\r\nI would propose to drop any mention of hidden servers or deployment architectures, just say \"server\" and in Security Considerations mention that a server SHOULD be configured in a way that it does not leak the identities of domains it wants to protect. I.e., when the SNI / ESNI extension is missing the server SHOULD not return a certificate for a protected site. For example CDNs should just return a certificate for their own domain.",
      "createdAt": "2018-05-16T00:26:15Z",
      "updatedAt": "2018-07-02T14:18:59Z",
      "closedAt": "2018-07-02T14:18:59Z",
      "comments": [
        {
          "author": "mcmanus",
          "authorAssociation": "CONTRIBUTOR",
          "body": "see also #28 ",
          "createdAt": "2018-05-16T02:43:50Z",
          "updatedAt": "2018-05-16T02:43:50Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "We ended up changing the terminology here.",
          "createdAt": "2018-07-02T14:18:59Z",
          "updatedAt": "2018-07-02T14:18:59Z"
        }
      ]
    },
    {
      "number": 38,
      "id": "MDU6SXNzdWUzMjM0Mjk0NzQ=",
      "title": "Make ESNI TLS 1.2 compatible",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/38",
      "state": "CLOSED",
      "author": "kontaxis",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "ESNI seems to rely on TLS 1.3 KeyShareEntry which makes it incompatible with TLS 1.2.\r\n\r\nThat's unfortunate with that \"The protocol designed in this document is quite straightforward.\"\r\n\r\nThe gist of ESNI comes down to \"encrypted_server_name extension, which contains the true extension encrypted under the provider\u2019s public key.\"\r\n\r\nThat seems pretty generic and backwards compatible.",
      "createdAt": "2018-05-16T00:32:42Z",
      "updatedAt": "2018-05-18T13:18:46Z",
      "closedAt": "2018-05-18T13:18:45Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "To prevent cut-and-paste attacks, you need to bind ESNI to the CH. That means we\u2019d need 1.2 clients to send a key share in the CH to use when deriving encryption keying material, and that\u2019s not currently done. ",
          "createdAt": "2018-05-16T00:46:43Z",
          "updatedAt": "2018-05-16T00:46:43Z"
        },
        {
          "author": "ghedo",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Since TLS 1.2 sends the server certificate in plaintext it seems like ESNI wouldn't be particularly useful there anyway, no?",
          "createdAt": "2018-05-18T08:29:25Z",
          "updatedAt": "2018-05-18T08:29:25Z"
        },
        {
          "author": "kontaxis",
          "authorAssociation": "NONE",
          "body": "Indeed. I guess someone could argue about wildcard certificates or when multiple names are present but the names are usually related so I agree there\u2019s no significant benefit from encrypting the SNI.",
          "createdAt": "2018-05-18T13:18:45Z",
          "updatedAt": "2018-05-18T13:18:45Z"
        }
      ]
    },
    {
      "number": 39,
      "id": "MDU6SXNzdWUzMjM0MzEyMTA=",
      "title": "Reuse RFC 6066 ServerName extension / Do not define a new extension",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/39",
      "state": "CLOSED",
      "author": "kontaxis",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "6.2 Middleboxes identifies a legitimate concern where middleboxes might strip a new ESNI extension that is unknown to them.\r\n\r\nThe ServerName structure as defined in RFC 6066 has an 8-bit NameType field where 0 is defined as host_name and all other values are undefined. Why not define 1 (or any other value) as encrypted_host_name?\r\n\r\nThe name structure inside ServerName is 16 opaque bits which seems able to accommodate EncryptedSNI as defined in this document. (Make encrypted_sni slightly smaller so that \"label\" and \"suite\" fit)",
      "createdAt": "2018-05-16T00:44:07Z",
      "updatedAt": "2018-05-16T06:32:28Z",
      "closedAt": "2018-05-16T06:32:27Z",
      "comments": [
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "I prefer having a different extension, because we do not want to limit the capability of ESNIKeys to just protecting the \"HostName\" (as identified by the 8-bit NameType field of zero).  IMO it is better to have a mechanism that can protect any type of \"server-name\", including those covered by NameTypes other than zero.\r\n\r\nNote that DNS is just one way of publishing ESNIKeys.",
          "createdAt": "2018-05-16T03:40:23Z",
          "updatedAt": "2018-05-16T03:40:23Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "I agree with @kazuho.",
          "createdAt": "2018-05-16T03:53:42Z",
          "updatedAt": "2018-05-16T03:53:42Z"
        },
        {
          "author": "kontaxis",
          "authorAssociation": "NONE",
          "body": "I didn't mean for ESNI to only apply to NameType 0.\r\n\r\nThere are 256 values, 0 is host_name, 1 can be encrypted_server_name, and there are 254 more values for additional types of server name types. Going forward I doubt someone will define a plain text type that will have to be protected. But even if that happens encrypted_server_name can encapsulate all name types but itself.\r\n\r\nP.S.: Not really sure how the use of DNS is a factor here.",
          "createdAt": "2018-05-16T04:15:37Z",
          "updatedAt": "2018-05-16T04:15:37Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Recall that SNI extensibility is [irrevocably busted](https://mailarchive.ietf.org/arch/msg/tls/1t79gzNItZd71DwwoaqcQQ_4Yxc).",
          "createdAt": "2018-05-16T06:03:36Z",
          "updatedAt": "2018-05-16T06:03:36Z"
        },
        {
          "author": "kontaxis",
          "authorAssociation": "NONE",
          "body": "Fair enough.",
          "createdAt": "2018-05-16T06:32:27Z",
          "updatedAt": "2018-05-16T06:32:27Z"
        }
      ]
    },
    {
      "number": 40,
      "id": "MDU6SXNzdWUzMjM0ODgzOTE=",
      "title": "Consider using a new DNS RR Type instead of TXT",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/40",
      "state": "CLOSED",
      "author": "DavidSchinazi",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The current document uses the TXT record for `_esni.example.org`. This will cause multiple issues.\r\n\r\n1) There is no IANA registry for prefixes that start with underscores to be used in DNS, so it is valid for existing servers to already be using _esni as part of the FQDN.\r\n2) The TXT record was designed to hold descriptive text, which means operators can already be using it for other descriptions.\r\n3) As described in issue #35 , using a prefix breaks CNAME.\r\n4) TXT requires base64 encoding which adds overhead on the network and recursive resolvers.\r\n\r\nThe generally recommended way to \"stuff it in the DNS\" is to create a new RR type for your data. For example DANE established RR type TLSA (52). There is room in the 16bit IANA registry for another value. The key here is that this prevents systems from misinterpreting the TXT record as something else, and it prevents systems from already using it for something else\r\n\r\nhttps://www.iana.org/assignments/dns-parameters/dns-parameters.xhtml#dns-parameters-4",
      "createdAt": "2018-05-16T06:46:43Z",
      "updatedAt": "2018-05-16T21:59:06Z",
      "closedAt": "2018-05-16T21:59:06Z",
      "comments": [
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "That was previously discussed in #7.",
          "createdAt": "2018-05-16T07:03:09Z",
          "updatedAt": "2018-05-16T07:03:09Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "See https://www.ietf.org/internet-drafts/draft-ietf-dnsop-attrleaf-fix-00.txt regarding the use of underscore names.",
          "createdAt": "2018-05-16T07:23:52Z",
          "updatedAt": "2018-05-16T07:23:52Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thanks for those links, I had missed #7. This makes sense to me. I makes me somewhat uncomfortable to abuse TXT this way but I understand the operational concerns. Feel free to close this issue.",
          "createdAt": "2018-05-16T17:42:16Z",
          "updatedAt": "2018-05-16T17:42:16Z"
        }
      ]
    },
    {
      "number": 41,
      "id": "MDU6SXNzdWUzMjM0OTA2MjQ=",
      "title": "Clarify downsides of encrypting ALPN with the same key as SNI",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/41",
      "state": "CLOSED",
      "author": "DavidSchinazi",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "chris-wood"
      ],
      "labels": [],
      "body": "This seems to be somewhat discussed in the draft and in issues, but I fail to see the motivation behind not using the ESNI key to encrypt other extensions such as ALPN. The main concern seems to be around entities seeing the value of decrypted ALPN, but that's still better than ALPN being the clear. Another concern is a middlebox blocking this extension, but if the client decides to fail hard, blocking is better than leaking; and if a client falls back to unencrypted then the connection works regardless. If I'm missing something, can that be clarified in the draft?",
      "createdAt": "2018-05-16T06:56:12Z",
      "updatedAt": "2019-07-08T18:18:13Z",
      "closedAt": "2019-07-08T17:26:24Z",
      "comments": [
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think that the goal with ALPN is to ensure that the set of values that are advertised remains small and fixed.  That is, everyone can offer h2+http/1.1 and no more.  This gives no advantage to a passive observer in terms of distinguishing traffic; the pattern of TLS extensions (order and so forth) gives more away.",
          "createdAt": "2018-07-03T05:15:46Z",
          "updatedAt": "2018-07-03T05:15:46Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "The other point is that SNI designates the server the client wants to handshakes with. ALPN (as well as other properties of ClientHello) is a property of the handshake.\r\n\r\nConsider the split case. SNI is decrypted by the fronting server. ALPN will be a property that will be taken into consideration by the backend server.",
          "createdAt": "2018-07-03T05:23:06Z",
          "updatedAt": "2018-07-03T05:25:13Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I agree that in current usage, ALPN is only used for h2 vs http/1.1. But if we had a way to hide ALPN from censors, we could use it to run a VPN over TLS to evade censorship - I'd like to have a TLS server on port 443 that mostly serves HTTPS but can also serve VPN to select clients.\r\n\r\nIn the split case, having the fronting server decrypt the ALPN and pass it decrypted to the backend server is fine - I'm mostly concerned about threats between the client and the fronting server.",
          "createdAt": "2018-07-03T05:32:33Z",
          "updatedAt": "2018-07-03T05:32:33Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "> In the split case, having the fronting server decrypt the ALPN and pass it decrypted to the backend server is fine\r\n\r\nCurrent draft is designed in a way to allow stock TLS servers to be run as a hidden server. Creating a way to pass the decrypted ALPN (or decrypted SNI) from the client-facing server to hidden server destroys that design.\r\n\r\nGenerally speaking, I am not opposed to protecting more properties. OTOH, I might prefer doing things in small steps; we have the extensions field in ESNIKeys.",
          "createdAt": "2018-07-03T06:04:40Z",
          "updatedAt": "2018-07-03T06:04:53Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@DavidSchinazi, if you want to advertise a VPN ALPN on all your connections, then that would work.  I'd prefer to establish privacy-preserving usage patterns as the norm so that this is considered acceptable (and not a reason to block a connection).  Advertising a willingness to use a VPN connection in addition to HTTP would be analogous to what we're doing here; the observer doesn't know what you ended up using.  They could decide to block based on the possibility that you are doing something bad, but that applies to encrypted SNI in equal measure.",
          "createdAt": "2018-07-03T10:17:44Z",
          "updatedAt": "2018-07-03T10:17:44Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This sounds reasonable to me. If we build this solution in a way that allows us to encrypt ALPN later without it being distinguishable from ESNI by a MitM, then I'm happy \ud83d\ude04 ",
          "createdAt": "2018-07-03T20:19:34Z",
          "updatedAt": "2018-07-03T20:19:34Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@DavidSchinazi this should be fixed by #169 -- please reopen if that's not the case!",
          "createdAt": "2019-07-08T17:26:24Z",
          "updatedAt": "2019-07-08T17:26:24Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@chris-wood #169 works for me, thanks.",
          "createdAt": "2019-07-08T18:18:13Z",
          "updatedAt": "2019-07-08T18:18:13Z"
        }
      ]
    },
    {
      "number": 42,
      "id": "MDU6SXNzdWUzMjM0OTE0Njg=",
      "title": "Fronting server forwarding the TLS connection is unclear",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/42",
      "state": "CLOSED",
      "author": "DavidSchinazi",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "From the \"Fronting Server Behavior\" section:\r\n\r\n> the fronting server then [...] forwards the TLS connection to the hidden server\r\n\r\nThis is not very clearly defined. Does the fronting server not make any changes to the client hello? Doesn't it remove the encrypted SNI extension and/or possibly add a cleartext SNI as discussed in \"Communicating SNI to Hidden Server\"?",
      "createdAt": "2018-05-16T06:59:54Z",
      "updatedAt": "2018-07-02T14:20:43Z",
      "closedAt": "2018-07-02T14:20:43Z",
      "comments": []
    },
    {
      "number": 47,
      "id": "MDU6SXNzdWUzMjU4OTIzMTQ=",
      "title": "pad the certificate too",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/47",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-05-23T22:12:20Z",
      "updatedAt": "2018-07-02T14:17:23Z",
      "closedAt": "2018-07-02T14:17:23Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@martinthomson addressed by #48?",
          "createdAt": "2018-06-15T21:06:21Z",
          "updatedAt": "2018-06-15T21:06:21Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Mostly.  I left comments on the PR.  A few things to follow-up on.",
          "createdAt": "2018-06-15T23:28:44Z",
          "updatedAt": "2018-06-15T23:28:44Z"
        }
      ]
    },
    {
      "number": 61,
      "id": "MDU6SXNzdWUzMzc5NjQwOTQ=",
      "title": "Is DNS query for server or origin",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/61",
      "state": "CLOSED",
      "author": "mcmanus",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The TLS server name (and thus SNI) is the HTTP origin name, however it is not necessarily the same as the host name of the TLS server. HTTP Alternative Services is the obvious way that happens - but Alt-Svc never changes the origin name.\r\n\r\nWhen fetching the ESNI key, do we fetch it from _esni.origin-name or _esni.host-name?\r\n\r\nI think origin-name makes more sense - keeping everything that is an expiicit protocol element in terms of origin eliminates confusion.\r\n\r\nthe counter argument is that you can use alt-svc to do fine grained fanout to providers with different keys (using cdn specific names for them in alt-svc) in a way that is harder to do through the origin name dns controls.",
      "createdAt": "2018-07-03T16:06:46Z",
      "updatedAt": "2018-10-21T20:52:41Z",
      "closedAt": "2018-10-21T20:52:41Z",
      "comments": [
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "My view is that the base name that is used to lookup the ESNI value (i.e. the name excluding the `_esni.` prefix) must be the same as the hostname that is carried by the ESNI extension.\r\n\r\nESNI is a replacement for SNI, and I think that the design should allow the TLS stack to obtain the ESNI key by itself (i.e. by querying `_esni.<sni-name>`).",
          "createdAt": "2018-07-12T02:28:22Z",
          "updatedAt": "2018-07-12T02:28:34Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "PS. To give an example, golang's TLS API to establish a new connection looks like below.\r\n```\r\nconn, err := tls.Dial(\"tcp\", \"mail.google.com:443\", &tls.Config{\r\n    RootCAs: roots,\r\n})\r\n```\r\n\r\nAs is obvious from the example, name resolution happens inside the TLS stack. I'd assume that we would want to handle ESNI record lookup within the stack as well.\r\n\r\nTherefore, the name used to lookup the ESNI record cannot be the origin name, which is specific to the behavior defined in HTTP (alt-svc), which operates above the TLS stack. It needs to be the hostname that is used for the name resolution (or a name that is derived from that).\r\n\r\nMy understanding is that TLS stacks on other programming language often has the same abstraction; i.e. handle name resolution inside in the TLS connection establishment call (or the TCP connection establishment call).",
          "createdAt": "2018-07-12T03:47:28Z",
          "updatedAt": "2018-07-12T03:54:58Z"
        },
        {
          "author": "mcmanus",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> My view is that the base name that is used to lookup the ESNI value (i.e. the name excluding the `_esni.` prefix) must be the same as the hostname that is carried by the ESNI extension.\r\n> \r\n\r\nto be clear - that is the origin name. In the case of alt-svc, where the host name and the origin name diverge, the SNI remains the origin name. This is also the identity that the client stack will authenticate. The host name is resolved to get a a/aaaa but never appears on the wire.\r\n\r\n> ESNI is a replacement for SNI, and I think that the design should allow the TLS stack to obtain the ESNI key by itself (i.e. by querying `_esni.<sni-name>`).\r\n\r\nThis matches my opinion, and also what firefox nightly is currently doing.. but I'm confused by your next comment\r\n\r\n> PS. To give an example, golang's TLS API to establish a new connection looks like below.\r\n> \r\n> ```\r\n> conn, err := tls.Dial(\"tcp\", \"mail.google.com:443\", &tls.Config{\r\n>     RootCAs: roots,\r\n> })\r\n> ```\r\n> As is obvious from the example, name resolution happens inside the TLS stack. I'd assume that we would want to handle ESNI record lookup within the stack as well.\r\n\r\nafaict the SNI information actually comes from tls.Config (Falling back to mail.google.com only if not provided).. this is no doubt also the information used to authenticate the cert.. https://golang.org/src/crypto/tls/tls.go?s=3255:3347#L88\r\n\r\nThe TLS stack is going to need both pieces of information. So which should it use?\r\n> \r\n> Therefore, the name used to lookup the ESNI record cannot be the origin name, which is specific to the behavior defined in HTTP (alt-svc), which operates above the TLS stack. \r\n\r\nno - the origin name is the SNI name even with alt-svc. It might not be the host name.\r\n\r\n> It needs to be the hostname that is used for the name resolution (or a name that is derived from that).\r\n> \r\n\r\nI think that's defensible but for different reasons (key management flexibility). but I would argue against this as we don't really want you using large sets of keys\r\n\r\n> My understanding is that TLS stacks on other programming language often has the same abstraction; i.e. handle name resolution inside in the TLS connection establishment call (or the TCP connection establishment call).\r\n\r\nIf a stack can't support alt-svc, then this isn't a problem - the name is the same everywhere :)\r\n\r\nIf a stack does support alt-svc then it has 2 names to deal with.. one is the name used for SNI and auth, and the other is the one used for TCP. (or perhaps it doesn't do TCP on its own).\r\n\r\nAll this issue is trying to do is decide whether the name we lookup for ENSNI/TXT is the same as the name we lookup for A/AAAA.. I'm going to say that they don't necessarily have to match. (i.e. your A could be for the alt-svc but your txt/esni is always going to be for the origin - which is the same thing you put in your CH.\r\n\r\nI'll make a pr.",
          "createdAt": "2018-10-17T22:13:40Z",
          "updatedAt": "2018-10-17T22:13:40Z"
        }
      ]
    },
    {
      "number": 62,
      "id": "MDU6SXNzdWUzMzgzOTQ1Mzg=",
      "title": "Note about checking zero padding",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/62",
      "state": "CLOSED",
      "author": "ekr",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Require that the server check that everything after ServerNameList is zero.",
      "createdAt": "2018-07-05T00:28:46Z",
      "updatedAt": "2018-10-21T20:41:00Z",
      "closedAt": "2018-10-21T20:41:00Z",
      "comments": [
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed.",
          "createdAt": "2018-10-21T20:38:55Z",
          "updatedAt": "2018-10-21T20:38:55Z"
        }
      ]
    },
    {
      "number": 63,
      "id": "MDU6SXNzdWUzMzg0MjQ5Njc=",
      "title": "Versioning for the record?",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/63",
      "state": "CLOSED",
      "author": "ekr",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Do we need it.",
      "createdAt": "2018-07-05T04:39:04Z",
      "updatedAt": "2018-09-16T20:03:24Z",
      "closedAt": "2018-09-16T20:03:24Z",
      "comments": [
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "For ESNIKeys (the DNS record) I do not think we need a version for the following reasons:\r\n* I think we would prefer adding extensions rather than making incompatible changes\r\n* we always have the freedom to pick a new prefix (e.g. `_esni2`) or a new RR type when making incompatible changes\r\n  * an incompatible change will require the client to query for two DNS records anyways\r\n\r\nFor the ESNI extension, I also do not think that we need a version field. When we define an extension sometime in the future, we could the advertise the support as an extension in the ESNIKeys to instruct the clients that support that extension to send a CH extension that uses a different extension ID than the ESNI extension.",
          "createdAt": "2018-07-05T06:05:15Z",
          "updatedAt": "2018-07-05T06:05:15Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> an incompatible change will require the client to query for two DNS records anyways\r\n\r\nA lot of other TXT records have a version in them.  It turns out that if you do that you can query for TXT records and get multiple answers back.  Then, you pick those with the version you like.  That's one query.\r\n\r\nI'm tempted to suggest that the first octet (or two) be used for a version number.  It's cheap.",
          "createdAt": "2018-07-05T09:39:40Z",
          "updatedAt": "2018-07-05T09:39:40Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm concerned about how we iterate on these in the field. They're not tied to TLS version, so what if we decide to change the formats, as we are discussing in #67 ",
          "createdAt": "2018-07-05T12:18:08Z",
          "updatedAt": "2018-07-05T12:18:08Z"
        },
        {
          "author": "mcmanus",
          "authorAssociation": "CONTRIBUTOR",
          "body": "a magic number (including version) is a pretty decent idea. right now _esni is in its own namespace but you can imagine someone doing a txt record that applies to every dns response so we would want to disambiguate that as well.\r\n\r\ntake note to update the \"concat multiple records\" rule if we go down this path..",
          "createdAt": "2018-07-05T12:32:21Z",
          "updatedAt": "2018-07-05T12:32:21Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "I think that having version is a good idea in sense that it allows to do experiments before the standardization completes.",
          "createdAt": "2018-07-17T05:29:46Z",
          "updatedAt": "2018-07-17T05:29:46Z"
        }
      ]
    },
    {
      "number": 64,
      "id": "MDU6SXNzdWUzMzg0MjgxMDU=",
      "title": "checksum and extension hashes",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/64",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The hash used in the extension should use the same hash inputs as the checksum.  The difference here just makes using this harder.",
      "createdAt": "2018-07-05T05:04:37Z",
      "updatedAt": "2019-07-03T01:20:45Z",
      "closedAt": "2019-07-03T01:20:45Z",
      "comments": [
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "I support the change, if that makes people feel more comfortable about having the checksum field in ESNIKeys.",
          "createdAt": "2018-07-05T06:13:26Z",
          "updatedAt": "2018-07-05T06:13:26Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm not opposed, but it doesn't help as much as you might think, because\nyou need to compute the label with the cipher hash and not (necessarily)\nwith SHA-256.\n\nOn Wed, Jul 4, 2018 at 11:13 PM, Kazuho Oku <notifications@github.com>\nwrote:\n\n> I support the change, if that makes people feel more comfortable about\n> having the checksum field in ESNIKeys.\n>\n> \u2014\n> You are receiving this because you are subscribed to this thread.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/ekr/draft-rescorla-tls-esni/issues/64#issuecomment-402616617>,\n> or mute the thread\n> <https://github.com/notifications/unsubscribe-auth/ABD1oepUYCUrNp7wcZST5fvAOOHtpyfvks5uDa6HgaJpZM4VDQOE>\n> .\n>\n",
          "createdAt": "2018-07-05T12:16:24Z",
          "updatedAt": "2018-07-05T12:16:24Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "So, if you take my suggestion in #142 (which I know @kazuho doesn't like, but we simply disagree about that), then you can identify the ESNI using a truncated hash that is calculated using the cipher hash because it only appears in the context of a handshake.  But that just suggests that this is either not-helpful because we chose not to do anything in #142, or it is not necessary because we did.  I'm OK closing this on that basis.",
          "createdAt": "2019-07-03T00:40:10Z",
          "updatedAt": "2019-07-03T00:40:10Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Checksum is now gone. Closing this issue. @martinthomson, thanks for filing it!",
          "createdAt": "2019-07-03T01:20:45Z",
          "updatedAt": "2019-07-03T01:20:45Z"
        }
      ]
    },
    {
      "number": 65,
      "id": "MDU6SXNzdWUzMzg0MjgzNjA=",
      "title": "checksum",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/65",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Does the advertisement really need a checksum?  It complicates things for questionable benefit.\r\n\r\nUse DNS-over-something-that-isn't-as-lame-as-UDP and this problem goes away.  You probably want DNS to be protected by TLS anyway.",
      "createdAt": "2018-07-05T05:06:36Z",
      "updatedAt": "2019-06-02T15:01:11Z",
      "closedAt": "2019-06-02T15:01:11Z",
      "comments": [
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "As discussed on https://github.com/ekr/draft-rescorla-tls-esni/pull/23 and https://www.ietf.org/mail-archive/web/tls/current/msg26532.html, I prefer to have the checksum for end-to-end integrity checking and to not have increased risk of service disruption for better adoption of ESNI; otherwise the hosts that using ESNI would stick out.\r\n\r\nIt's not only when transmitting data over the wire that the ESNIKeys might get corrupt. That could happen before the record gets installed on the authoritative server, or while the data is being cached in a resolver. Or we might have other conveyer in the future.",
          "createdAt": "2018-07-05T06:11:18Z",
          "updatedAt": "2018-07-05T06:11:18Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yeah, I don't find those arguments particularly persuasive.  The biggest risk is misconfiguration, which - given the nature of this - won't be persistent.  Sites that do this will test their code and once it is fixed, it should work.\r\n\r\nAs for network-level corruption, that's rare, and DNS over TLS (or DoH) aren't really vulnerable to that.",
          "createdAt": "2018-07-05T09:53:00Z",
          "updatedAt": "2018-07-05T09:53:00Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "I agree that corruption is rare; the question is if it is as rare as TCP transferring corrupt data.\r\n\r\nI would like to also point out that corruption cannot be immediately fixed; you need to wait for the cached records to expire. And even if you use DNS over TLS or DOH between the client and the resolver, you could still be using unauthenticated DNS over UDP between the resolver and the authoritative server.",
          "createdAt": "2018-07-05T15:33:51Z",
          "updatedAt": "2018-07-05T15:33:51Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@kazuho @martinthomson shall we consider this issue resolved?",
          "createdAt": "2019-01-19T01:15:44Z",
          "updatedAt": "2019-01-19T01:15:44Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Considering resolved. ",
          "createdAt": "2019-06-02T15:01:11Z",
          "updatedAt": "2019-06-02T15:01:11Z"
        }
      ]
    },
    {
      "number": 66,
      "id": "MDU6SXNzdWUzMzg0MjkwNzg=",
      "title": "Contributory behaviour",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/66",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "chris-wood"
      ],
      "labels": [],
      "body": "This might not need the same level of rigour as TLS itself, but the construction of the keys could be better.  Right now, Z is dependent on contributory behaviour.\r\n\r\nI recommend that rather than just hashing `ClientHello.random`, a pseudo-message be constructed that includes the random, the server advertisement (in its entirety), the client's key share in some form, and maybe the prologue of the esni extension as well.  Essentially the entire mini-protocol we're using.",
      "createdAt": "2018-07-05T05:12:12Z",
      "updatedAt": "2018-10-21T20:35:43Z",
      "closedAt": "2018-10-21T20:35:43Z",
      "comments": [
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "+1\r\n\r\nClarification question: and we will be using Derive-Secret to extract the keys to encrypt the ESNI extension? I think we should, so as to align the key derivation process to the norm.",
          "createdAt": "2018-07-05T07:27:14Z",
          "updatedAt": "2018-07-05T07:27:14Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yeah, using Derive-Secret would be best, I think. Try to keep the entire process aligned with existing practice.",
          "createdAt": "2018-07-05T09:54:27Z",
          "updatedAt": "2018-07-05T09:54:27Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "We didn't do Derive-Secret, but otherwise we did this.",
          "createdAt": "2018-10-21T20:35:11Z",
          "updatedAt": "2018-10-21T20:35:11Z"
        }
      ]
    },
    {
      "number": 67,
      "id": "MDU6SXNzdWUzMzg0MjkzNTg=",
      "title": "Use different client key shares for ESNI and TLS KE?",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/67",
      "state": "CLOSED",
      "author": "ekr",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Using the same key share looked like a good idea, but it's actually a real pain to implement because you need to get pretty involved with the TLS 1.3 key exchange.\r\n\r\nAnother approach would be to have separate keys but bind the ClientHello.KeyShare extension into the ESNI extension. I had thought of putting a hash in the extension plaintext but @martinthomson points out that if you use it as AAD, then the client-facing server will automatically detect mismatch\r\n\r\n",
      "createdAt": "2018-07-05T05:14:20Z",
      "updatedAt": "2018-10-21T20:43:09Z",
      "closedAt": "2018-10-21T20:43:09Z",
      "comments": [
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "> Using the same key share looked like a good idea, but it's actually a real pain to implement because you need to get pretty involved with the TLS 1.3 key exchange.\r\n\r\nI am not sure if we are going to have such pain in general. In my view, what you can do is as follows:\r\n* construct encrypted_server_name extension\r\n* construct ClientHello, with passing in the ESNI extension and the key-exchange context that was used for constructing the extension as the arguments\r\n  * add the key-exchange context being passed in to ClientHello\r\n  * omit constructing a key-exchange context if the id of the context to-be-constructed matches that of the supplied context\r\n\r\nTo me, they seem to be fairly limited change.\r\n\r\nGenerally speaking, I think the question of if we should have different key shares depends on if we want to apply different crypto to the ESNI and the TLS application payload. My preference is to use single crypto whenever possible for simplicity and in hope that we can reuse ESNIKeys for other purposes in the future.",
          "createdAt": "2018-07-05T05:56:41Z",
          "updatedAt": "2018-07-05T05:56:52Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "> I had thought of putting a hash in the extension plaintext but @martinthomson points out that if you use it as AAD, then the client-facing server will automatically detect mismatch\r\n\r\n:+1:\r\n\r\nEDIT: Well, but then a server cannot use the digest to find the corresponding ESNIKeys (and the private key). So while I agree that using it as AAD makes sense, I do not think that we can omit the hash. We could send something other than a hash (e.g., ID) though.",
          "createdAt": "2018-07-05T06:20:02Z",
          "updatedAt": "2018-07-05T06:22:16Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "Sorry, there are two values here:\r\n\r\n1. The ESNIKeys hash, which I agree has to be in the clear.\r\n2. The hash of KeyShares to prevent substitution attacks.\r\n\r\n@kazuho: I agree it's doable, as I just got my POC working. Yes, the CH is as you say, which is modestly disruptive. On the server side it's a bit disruptive because of the way NSS handles extensions, which is to say in-order. So, ESNI could come either before or after KeyShares. I could refactor this of course.\r\n\r\nIt also affects negotiation, so if the client didn't pick the server's most preferred group, you have to refrain from sending HRR, which is a bit of a pain.\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
          "createdAt": "2018-07-05T14:05:46Z",
          "updatedAt": "2018-07-05T14:05:46Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "Thank you for the clarification.\r\n\r\nI can understand the pain on the server-side. Current approach of ESNI changes the negotiation from client-offers-a-list-server-chooses-one, to server-offers-a-list-client-chooses-one.\r\n\r\nI think that it might be fine to revert to the TLS 1.3 way of negotiation. Actually we might be required to do that, if we want to prevent a client-facing server downgrading the crypto in the split server scenario.\r\n\r\nOTOH, I am not sure if we would want to use a _separate_ key share for ESNI, because that would require additional CPU cost. My benchmark tells me that in case of X25519, key generation takes about half the time of key derivation. That means that if we are going to have separate key shares but the algorithm collides, the client will be spending 17% more CPU cycles (i.e. 1 key generation + 2 derivations vs. 2 key generations and 2 derivations).\r\n\r\nConsidering the cost, I think that we'd be tempted to try reuse the key-share for two purposes (i.e. ESNI and TLS handshake), even if we define separate key exchange fields for the two.\r\n\r\nAnd that in turn make me wonder what the value is for having separate key exchange fields.\r\n\r\nTo summarize, I do not oppose to allowing client send multiple key shares or allowing server send HRR when ESNI is involved, but I prefer using the value of the KeyShares extension for carrying the ECDH key being used to encrypt ESNI.",
          "createdAt": "2018-07-05T16:06:35Z",
          "updatedAt": "2018-07-05T16:06:35Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "> To summarize, I do not oppose to allowing client send multiple key shares or allowing server send HRR when ESNI is involved, but I prefer using the value of the KeyShares extension for carrying the ECDH key being used to encrypt ESNI.\r\n\r\nFWIW, I've created #70 that implements this, hoping that having a PR would help us evaluate the approach.",
          "createdAt": "2018-07-05T23:20:56Z",
          "updatedAt": "2018-07-05T23:20:56Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed",
          "createdAt": "2018-10-21T20:43:09Z",
          "updatedAt": "2018-10-21T20:43:09Z"
        }
      ]
    },
    {
      "number": 68,
      "id": "MDU6SXNzdWUzMzg1MDgxMDI=",
      "title": "Limit this to DNS names",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/68",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "chris-wood"
      ],
      "labels": [],
      "body": "Extensibility failed for SNI, no point in repeating that failure.  This is less complex:\r\n\r\n```\r\n   struct {\r\n       opaque domain_name<1..255>;\r\n       opaque zeros[ESNIKeys.padded_length - length(sni)];\r\n   } PaddedServerNameList;\r\n```\r\n\r\n",
      "createdAt": "2018-07-05T10:03:54Z",
      "updatedAt": "2019-07-03T20:30:29Z",
      "closedAt": "2019-07-03T20:30:29Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Are there other ways we expect servers to select certificates? I can imagine a scenario where clients pin server leaf certificates, and hint servers to the right leaf certificate by sending the leaf SPKI hash in the SNI. Would we want to rule something like that out?",
          "createdAt": "2019-01-19T01:19:07Z",
          "updatedAt": "2019-01-19T01:19:07Z"
        }
      ]
    },
    {
      "number": 69,
      "id": "MDU6SXNzdWUzMzg1OTY5MDU=",
      "title": "ESNIKeys can be used for Downgrade",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/69",
      "state": "CLOSED",
      "author": "ekr",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Say that you have a server whose policy is that it will accept any KeyShare that is in the overlap between the client and server supported_groups (this isn't really an advisable policy). An on-path to DNS attacker can force you into the weakest joint group by creating an invalid ESNIKeys structure with a key in that group. The client will then send a KeyShare in that group, and you have been undetectably downgraded. Note that this will lead to suppression of SNI (because the client will be encrypting), but many servers don't require SNI. This works even against a non-ESNI servers.\r\n\r\nThere's also a weaker attack in which the client-facing server just sends a weaker share in ESNIKeys. This will be very hard for the server to detect.\r\n\r\nThis doesn't seem ideal, and I'm not quite sure how to remove it. This seems like an argument for #67 if we can make that work.\r\n\r\nThanks to @tvdmerwe for discussions leading to this.\r\n\r\n@kazuho: ^^\r\n",
      "createdAt": "2018-07-05T14:23:23Z",
      "updatedAt": "2018-10-21T20:35:33Z",
      "closedAt": "2018-10-21T20:35:33Z",
      "comments": [
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "See also the big disclaimer at the top :)",
          "createdAt": "2018-07-05T14:25:41Z",
          "updatedAt": "2018-07-05T14:25:41Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "> An on-path to DNS attacker can force you into the weakest joint group by creating an invalid ESNIKeys structure with a key in that group. The client will then send a KeyShare in that group, and you have been undetectably downgraded.\r\n\r\nI do not think that the attack works against servers that support ESNI. The server will fail to find the private key that matches the ESNIKeys being used by the client (based on the value of record_digest), and the handshake will fail (that is the defense we implemented in #24).\r\n\r\n> This works even against a non-ESNI servers.\r\n\r\nI think that this is true. One way to fix the issue will be to use the value of ESNIKeys as an input to the Key Schedule (see #66), but a fix like that will not work with unmodified hidden server in Split mode. \r\n\r\nHaving that said, I am not sure if this is kind of an attack we need to fix. An attacker that can tamper the DNS responses can mount a DoS attack in a simpler way: send a negative response to an A query. Our model of sending unauthenticated ESNIKeys over DNS is based on the perception that DoS or preventing ESNI from working is possible when unauthenticated transmission of DNS is involved, but that does not open _new_ attack vectors.\r\n\r\n> There's also a weaker attack in which the client-facing server just sends a weaker share in ESNIKeys. This will be very hard for the server to detect.\r\n\r\nThis is true. I think the question here is if we want to permit using different key-shares / cipher-suites for ESNI and application data. As you point out, it relates to #67.",
          "createdAt": "2018-07-05T15:25:50Z",
          "updatedAt": "2018-07-06T00:06:44Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed with the new structure.",
          "createdAt": "2018-10-21T20:35:33Z",
          "updatedAt": "2018-10-21T20:35:33Z"
        }
      ]
    },
    {
      "number": 74,
      "id": "MDU6SXNzdWUzNDAzOTE3OTc=",
      "title": "don't base 64 encode",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/74",
      "state": "CLOSED",
      "author": "mcmanus",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "dns records are 8 bit clean and rfc 6763 is an example of a TXT record carrying arbitrary data\r\n\r\n",
      "createdAt": "2018-07-11T20:22:17Z",
      "updatedAt": "2019-03-06T22:44:27Z",
      "closedAt": "2019-03-06T22:44:26Z",
      "comments": [
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": ":+1:\r\n\r\nBase64 is not only complication. It is a space overhead for a large object like ESNIKeys. Seeing corruption of binary will be rare; we can detect them by validating the checksum and fallback to non-ESNI in such case. So why not go for binary?\r\n\r\nFWIW, base64 was introduced in #18.",
          "createdAt": "2018-07-11T21:47:07Z",
          "updatedAt": "2018-07-12T03:38:17Z"
        },
        {
          "author": "ghedo",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This is solved in #73 which removes base64 with new ESNI RR type.",
          "createdAt": "2018-07-12T12:09:29Z",
          "updatedAt": "2018-07-12T12:09:29Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "We only added this since TXT records were claimed to not work well with binary, per Christian\u2019s suggestion. I\u2019m fine either way. ",
          "createdAt": "2018-07-12T12:53:32Z",
          "updatedAt": "2018-07-12T12:53:32Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks for the info. I found https://github.com/ekr/draft-rescorla-tls-esni/issues/14#issuecomment-388573921, in which @huitema asks:\r\n> I really have two concerns, the maximum length and the char requirement. The latter may be an harder issue. For example, can I set a TXT record to contain binary data if I use Amazon's Route 53 service?\r\n\r\nWe know that we can store more than 128 octets in TXT record, and that we have a precedent that uses TXT to store binary data, as @mcmanus has pointed out.\r\n\r\nRegarding configurability, my understanding is that RFC 1035 defines how binary TXT records can be specified in a zone file, and therefore many DNS server \"softwares\" support having such records. Googling also tells me that managed DNS services like Route 53 and Azure DNS provide the capability, although surprisingly they use different escape sequences ([Route 53](https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/ResourceRecordTypes.html#TXTFormat) uses `\\` + 3 octal, [Azure](https://docs.microsoft.com/en-US/azure/dns/dns-faq) uses `\\` + 3 decimal).",
          "createdAt": "2018-07-12T14:33:32Z",
          "updatedAt": "2018-07-12T14:33:32Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "I do not think it\u2019s a complication, and I\u2019m not convinced space is an issue as per your comment above.",
          "createdAt": "2018-07-12T14:58:53Z",
          "updatedAt": "2018-07-12T14:58:53Z"
        },
        {
          "author": "mcmanus",
          "authorAssociation": "CONTRIBUTOR",
          "body": "only tangentially related - @kazuho do you know why your examp1e.net txt record is broken into 127 char strings instead of 255? Is there a bug being worked around somewhere?",
          "createdAt": "2018-07-12T15:15:10Z",
          "updatedAt": "2018-07-12T15:15:10Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "@mcmanus Oh I did not notice that. I am using tinydns (of djbdns), and it seems like tinydns works that way (see https://github.com/abh/djbdns/blob/master/tinydns-data.c#L402).",
          "createdAt": "2018-07-12T15:53:20Z",
          "updatedAt": "2018-07-12T15:53:20Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "@chris-wood The issue about the size is that with base64 we might hit the 512-octet threshold when publishing keys of multiple strengths.\r\n\r\nAs an example, query for _esni.esni.examp1e.net currently returns a 186-byte response, which contains just secp256r1 key. If we add secp384r1 and secp521r1, I'd assume that the size will come near to 490 octets. In other words, for longer hostnames we will hit the 512-octet threshold if we publish three keys.\r\n\r\nIf we avoid the base64 encoding, we will have enough room to store 3 ECDH keys that can provide 128-, 192-, 256-bit-level security.\r\n\r\nI do not think this argument is strong enough to prohibit the use of base64 for the following reasons:\r\n\r\n* we will be using DoH / DNS over TLS between the client and the resolver\r\n* we might be using DNS over UDP that has the 512-octet threshold between the resolver and the authoritative server, but we would want that to migrate to DNSSEC or something even better\r\n* we might be just fine with publishing only two keys: X25519, X448\r\n\r\nBut it does make me prefer not to have the overhead of base64, if that is possible.",
          "createdAt": "2018-07-12T16:09:19Z",
          "updatedAt": "2018-07-12T16:09:19Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed in #144.",
          "createdAt": "2019-03-06T22:44:26Z",
          "updatedAt": "2019-03-06T22:44:26Z"
        }
      ]
    },
    {
      "number": 75,
      "id": "MDU6SXNzdWUzNDEzMjM3MDI=",
      "title": "iana registry for underscore scoped name",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/75",
      "state": "CLOSED",
      "author": "mcmanus",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "https://datatracker.ietf.org/doc/draft-ietf-dnsop-attrleaf/\r\n\r\nis in wglc and seems likely to become a standards track doc.\r\n\r\nIt establishes a registry for undesrscore scoped names\r\n```\r\n      \"Per\" [Attrleaf] \"please add the following entry to the DNS\r\n      Underscore Global Scoped Entry Registry:\"\r\n\r\n   +--------+----------------+-----------------------------------------+\r\n   | RR     | _NODE NAME     | REFERENCE                               |\r\n   | Type   |                |                                         |\r\n   +--------+----------------+-----------------------------------------+\r\n   | TXT    | _esni          | this document                           |\r\n   +--------+----------------+-----------------------------------------+\r\n```\r\n\r\nit means a blocking reference to ATTRLEAF, but that doesn't seem like a problem time wise",
      "createdAt": "2018-07-15T14:05:39Z",
      "updatedAt": "2018-07-15T14:36:02Z",
      "closedAt": "2018-07-15T14:36:02Z",
      "comments": []
    },
    {
      "number": 79,
      "id": "MDU6SXNzdWUzNDI4NjExMjI=",
      "title": "_esni prefix is challenging for DNS wildcard syntax with TXT type",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/79",
      "state": "CLOSED",
      "author": "mcmanus",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "if you dynamically syntehsize a whole bunch of names in example.com you would probably use a *.example.com a/aaaa configuration to do so and give them all the same addresses.\r\n\r\nbut you can't do the same things for TXT records with the _esni prefix..  basically _esni.*.example.com doesn't do the trick (rfc 4592).\r\n\r\ninitially I viewed this as a configuration and implementation issue because queries and responses do not carry the * at all - the records are synthesized on demand from this config.\r\n\r\nhowever, the wildcard is part of AXFR which forms an open interface between resolvers so its syntax and meaning is quite reasonably standardized and should be considered.\r\n",
      "createdAt": "2018-07-19T19:34:14Z",
      "updatedAt": "2019-03-06T22:43:23Z",
      "closedAt": "2019-03-06T22:43:23Z",
      "comments": [
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "> however, the wildcard is part of AXFR which forms an open interface between resolvers\r\n\r\nMinor point but I am not sure if AXFR is something that is exposed to the resolvers. My understanding is standardized interface for synchronizing authoritative servers. So this will be an issue only for websites that use a DNS that either depends on AXFR (or in other ways depend on the vocabulary of the AXFR).\r\n\r\nI agree that it would be preferable to address the issue.",
          "createdAt": "2018-07-19T19:55:58Z",
          "updatedAt": "2018-07-19T19:55:58Z"
        },
        {
          "author": "mcmanus",
          "authorAssociation": "CONTRIBUTOR",
          "body": "my thought here is that axfr represents an interface between, potentially,\ndifferent implementations so we should try and respect that to whatever\nextent is possible.\n\nOn Thu, Jul 19, 2018 at 3:55 PM, Kazuho Oku <notifications@github.com>\nwrote:\n\n> however, the wildcard is part of AXFR which forms an open interface\n> between resolvers\n>\n> Minor point but I am not sure if AXFR is something that is exposed to the\n> resolvers. My understanding is standardized interface for synchronizing\n> authoritative servers. So this will be an issue only for websites that use\n> a DNS that either depends on AXFR (or in other ways depend on the\n> vocabulary of the AXFR).\n>\n> I agree that it would be preferable to address the issue.\n>\n> \u2014\n> You are receiving this because you authored the thread.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/ekr/draft-rescorla-tls-esni/issues/79#issuecomment-406395145>,\n> or mute the thread\n> <https://github.com/notifications/unsubscribe-auth/AAP5s4s6W1bSbCrcAOda5E9l00lvVmO5ks5uIORPgaJpZM4VW-J6>\n> .\n>\n",
          "createdAt": "2018-07-19T20:08:48Z",
          "updatedAt": "2018-07-19T20:08:48Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "My view of the issue is that we can support all the models that we need to support if we adopt #73 so that ESNIKeys will be distributed using a dedicated type with a prefix.\r\n\r\nThe patterns we need to consider are the combination of three types of DNS records (i.e. single-host, APEX, wildcard) and a boolean indicating if DNS is maintained by someone other than the CDN.\r\n\r\nThe table below illustrates how you could configure the DNS on each case. There are certain cases in which you could use CNAME instead of A / ESNI.\r\n\r\n|**DNS operated by**|**single-host**|**APEX**|**wildcard**|\r\n|:---|:---|:---|:---|\r\n|**CDN**|host IN A addr<br>_esni.host IN ESNI ...|@ IN A addr<br>_esni IN ESNI ...|* IN A addr<br>* IN ESNI ...<sup>1</sup>|\r\n|**not CDN**|host IN CNAME addr<br>_esni.host CNAME _esni.cdn|@ IN A cdn-ipaddr<br>_esni IN CNAME _esni.cdn|* IN CNAME cdn<sup>1<sup>|\r\n\r\n1: You will be required to create _esni records for all hosts that you specify explicitly, if it is necessary to disable ESNI for those hosts (or if those hosts use different ESNI keys).",
          "createdAt": "2018-07-19T22:55:42Z",
          "updatedAt": "2018-07-19T22:57:38Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed in #144.",
          "createdAt": "2019-03-06T22:43:23Z",
          "updatedAt": "2019-03-06T22:43:23Z"
        }
      ]
    },
    {
      "number": 80,
      "id": "MDU6SXNzdWUzNDMwOTIxNDE=",
      "title": "Add consolidations considerations section",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/80",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "chris-wood"
      ],
      "labels": [],
      "body": "",
      "createdAt": "2018-07-20T12:38:51Z",
      "updatedAt": "2019-07-03T00:11:15Z",
      "closedAt": "2019-07-03T00:11:14Z",
      "comments": [
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "Can you explain what you mean about this? Or submit a PR",
          "createdAt": "2018-10-21T20:46:21Z",
          "updatedAt": "2018-10-21T20:46:21Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@ekr I missed your comment.... in October. Oops. Closing as NTBF. We can add text if required later.",
          "createdAt": "2019-07-03T00:11:14Z",
          "updatedAt": "2019-07-03T00:11:14Z"
        }
      ]
    },
    {
      "number": 81,
      "id": "MDU6SXNzdWUzNDU0OTU2MDE=",
      "title": "Mix client KeyShare into AEAD to prevent malleability",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/81",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "See \r\nhttps://mailarchive.ietf.org/arch/msg/tls/rc_tgkgVIeB4yeNCgPcyPzRnrBI",
      "createdAt": "2018-07-29T02:37:15Z",
      "updatedAt": "2018-10-21T20:34:12Z",
      "closedAt": "2018-10-21T20:34:11Z",
      "comments": [
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "Done.",
          "createdAt": "2018-10-21T20:34:11Z",
          "updatedAt": "2018-10-21T20:34:11Z"
        }
      ]
    },
    {
      "number": 82,
      "id": "MDU6SXNzdWUzNDU0OTU2ODI=",
      "title": "Consider new extension that permits server to supply new ESNI key upon mismatch",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/82",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Currently, the connect fails when a mismatch occurs. An alternative strategy might be to return a new ESNI key that is then used for a subsequent connection.",
      "createdAt": "2018-07-29T02:39:04Z",
      "updatedAt": "2019-02-26T21:14:12Z",
      "closedAt": "2019-02-26T21:14:12Z",
      "comments": [
        {
          "author": "yfdyh000",
          "authorAssociation": "NONE",
          "body": "How to understand the reliability of the public key from server?",
          "createdAt": "2018-09-14T18:01:17Z",
          "updatedAt": "2018-09-14T18:01:17Z"
        }
      ]
    },
    {
      "number": 83,
      "id": "MDU6SXNzdWUzNDU0OTU3Mzk=",
      "title": "Discuss query strategies and how to deal with loss",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/83",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The order of DNS queries may matter in systems that use Happy Eyeballs. Also, should TLS connections block until ESNI key queries come back? What if they never come back?",
      "createdAt": "2018-07-29T02:40:53Z",
      "updatedAt": "2018-08-14T17:13:09Z",
      "closedAt": "2018-08-14T17:13:09Z",
      "comments": [
        {
          "author": "mcmanus",
          "authorAssociation": "CONTRIBUTOR",
          "body": "can you elaborate on what you're thinking about wrt he? (assuming the inaddr.arpa plan is off the table)",
          "createdAt": "2018-08-05T00:47:26Z",
          "updatedAt": "2018-08-05T00:47:26Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Basically addressed in #86.",
          "createdAt": "2018-08-14T17:13:09Z",
          "updatedAt": "2018-08-14T17:13:09Z"
        }
      ]
    },
    {
      "number": 84,
      "id": "MDU6SXNzdWUzNDYzMjgyMTc=",
      "title": "Supporting multiple protocols text is slightly misleading",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/84",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "chris-wood"
      ],
      "labels": [],
      "body": "Replace \r\n\r\n\"It only affects connection routing, server certificate selection, and client certificate verification.\" \r\n\r\nwith \r\n\r\n\"It may affect connection routing, server certificate selection, and client certificate verification.\" ",
      "createdAt": "2018-07-31T19:33:47Z",
      "updatedAt": "2019-07-03T00:15:11Z",
      "closedAt": "2019-07-03T00:15:11Z",
      "comments": [
        {
          "author": "yfdyh000",
          "authorAssociation": "NONE",
          "body": "https://ekr.github.io/draft-rescorla-tls-esni/draft-rescorla-tls-esni.html#rfc.section.7.2.8\r\nIt is relative to \"This design has no impact on application layer protocol negotiation.\", so \"only\" is more explicit.",
          "createdAt": "2018-09-14T18:05:32Z",
          "updatedAt": "2018-09-14T18:05:32Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "This was fixed in #87 and I forgot to close. ",
          "createdAt": "2019-07-03T00:15:11Z",
          "updatedAt": "2019-07-03T00:15:11Z"
        }
      ]
    },
    {
      "number": 88,
      "id": "MDU6SXNzdWUzNTIwMTIwODc=",
      "title": "DNS record disadvantage & Purpose enhancement & My suggestion",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/88",
      "state": "CLOSED",
      "author": "JemmyLoveJenny",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "I don't know that I can give out my advice here before, so I had written an e-mail to draft-rescorla-tls-esni@ietf.org and that's my first time to send an email to IETF. I don't know whether sending an e-mail is the right thing, so I would paste it here again.\r\n\r\nI'm not a native English speaker, I would apologize for my poor English first.\r\n\r\n\r\n### DNS record disadvantage\r\n\r\n#### 1.Impossible for wildcard A or AAAA record\r\n\r\nIt isn't possible for us to set a txt record for wildcard A or AAAA record (_esni.*.example.com. 60S IN TXT \"...\" \"...\"). \r\nThe same problem as https://github.com/ekr/draft-rescorla-tls-esni/issues/79 mentioned.\r\n\r\n#### 2.Publishing a public key using DNS is very inconvenient and insecure. \r\n\r\nIn general, we can't change the DNS record very conveniently (except some DNS which provide API), so that most domain owners won't change the key very often. \r\n\r\nAnd in some cases, domain owners host their site at host service providers (I don't know how to explain that in English. Host service provider use one physical or virtual server to host many sites) once the provider want to change the ESNI public key, all owners on this server need to change their txt record on time, which is very inconvenient and nearly impossible.\r\n\r\nThe lack of frequently changing public key and the lack of Perfect Forward Security only provide us little security.\r\n\r\n#### 3.DNS record limited only exist domains can enable ESNI\r\n\r\nAs DNS record is needed to be set, only the owner of a exist and valid domain can enable ESNI.\r\n\r\nHowever, sometimes we want to use encrypted-sni as a private entry. For example, I configured my server that client hello with the sni \"vps.panel\" would lead to the vps control panel ( I issued a cert for \"vps.panel\" from my own PKI ). Though I configured that the server must verify my identity using a client certificate, I don't want this private sni to be known to the public. But your draft's method won't allow this use case as \"vps.panel\" isn't a valid domain name, so that I won't be able to own this domain and set a DNS record for it.\r\n\r\n#### 4.Local DNS (hosts) won't work\r\n\r\nThe hosts file can only take the place of A and AAAA record and won't be able to set public key in hosts in the near future.\r\n\r\n#### 5.Requirements to the server is too high\r\n\r\nThis ESNI draft requires that the server can the decrypt the sni which is encrypted by any public key. This means that the server has to take hold all ESNI private keys. However, I think that it's not proper.  \r\nTo CDN service provider like Cloudflare, it means that one Cloudflare server has to storage all private ESNI keys of the websites hosted on it.  \r\nIn my opinion, the browser should encrypt the sni using all public keys found in the DNS record and add a few invalid ESNI along with those, to prevent the attacker identify the real sni from the number of public keys.\r\n\r\n\r\n### Purpose Enhancement - Wall-resistent\r\n\r\nIn some countries (e.g. China, North Korea, Iran) , people may want to use ESNI to break the government's GreatFireWall, which blocks people from visiting some website.\r\n\r\nThe wall isn't just a wall, but a very complicated system which can modify DNS resolve result ( DNSSEC isn't common ). They can simply block all _esni txt record, so that all browsers can' get the public key and downgrade to cleartext-sni.\r\n\r\nIf ESNI can be used with SNI Proxy, it would be a good solution to break the wall. However the DNS record limited only the owner can enable ESNI ( Another disadvantage of DNS :D )\r\n\r\n\r\n### My suggestions\r\n\r\nI think some ideas of https://datatracker.ietf.org/doc/draft-ietf-tls-sni-encryption/ is quite good. One good idea is to use a certificate to authenticate the Client-Facing Server instead of publishing a public key. My main idea is to introduce a series of HTTP headers like HSTS and HPKP. I will give an example below:\r\n\r\nFirstly, I would introduce these headers\r\n( These names may be not proper due to my poor English )\r\n\r\n```\r\nESNI:(preload);(includeSubdomains);max-age=??\r\nIf ESNI header presents in the response, it means this domain enables ESNI. Otherwise, the browser MUST ignore other ESNI-* headers.\r\ne.g.\r\nESNI:preload;includeSubdomains;max-age=31536000\r\n\r\nESNI-Resolve:{address};max-age=??\r\n{address} can be either FQDN or IP(s) the purpose is to hide the real domain during DNS resolve. The server MUST keep this header up-to-date. This header just like a cacheable CNAME record.\r\ne.g. \r\nESNI-Resolve: server233.domain-cdn.com;max-age=31536000\r\nESNI-Resolve: 0.0.0.0/16;max-age=2592000\r\nESNI-Resolve: 1.1.1.1;max-age=2592000\r\n\r\nESNI-Trust:{address or pin-hash};max-age=??\r\n{address} is the same as above. The only difference is that the FQDN can contain wildcard.\r\n{pin-hash} is similar to HPKP's pin-hash.\r\nCan have more than one this header in the HTTP Response. (Explain later)\r\ne.g.\r\nESNI-Trust:fqdn{ *.domain-cdn.com};max-age=31536000\r\nESNI-Trust:ip{0.0.0.0/16};max-age=31536000\r\nESNI-Trust:pin-hash{X523zEOQCuEJeU6PzewOGkKCRX+YLvfAsCYJbQubCuE=};max-age=31536000\r\n\r\n\r\nESNI-Policy:{policy};max-age=??\r\n{policy} can be \"force-encrypted-sni\", \"retry-clear-sni\", \"allow-dns-re-resolve\", \"disallow-dns-re-resolve\" defines the action if error happens using ESNI. \r\nCan have more than one this header in the Response. (Explain below)\r\n```\r\n\r\nIt's impossible to have more than one header with the same name, but we may construct these in to a structure and encode (e.g.base64) into one header. The header may be very big, but don't worry, only the first response contains it, HTTP2 will automatically compress them into a few bits in the later response.\r\n\r\nWhen the first time I visit https://www.example.com , I just do the normal tls1.3 hand shake with clear-text sni. The server just do what it should do, but the response MUST contain those ESNI headers if ESNI is enabled. The browser MUST remember these headers ( unless in incognito mode )\r\n\r\nWhen the second time I visit https://www.example.com , the browser SHOULD NOT query DNS resolve for www.example.com, instead, it should visit the FQDN/IP mentioned in the ESNI-Resolve header. And the browser MUST NOT send clear-text sni in the ClientHello, instead, send a CH without sni or a special CH indicates using ESNI.  The Client-Facing Server  send back certificate, the browser validates the certificate and makes sure the certificate contains at least one FQDN/IP mentioned in the ESNI-Trust header. If mismatch, check the ESNI-Policy and determine whether to retry or not. \r\nAnd then re-handshake with the server with encrypted-ClientHello in the 0RTT data or another CH extension. \r\n( similar to draft-ietf-tls-sni-encryption method )\r\n\r\nMy suggestions' advantages and disadvantages are nearly the same as draft-ietf-tls-sni-encryption method. It provides PFS, don't need to change the Split-Mode Server and solved some part of DNS sniffing. But the disadvantage is obvious too, the first hand shake can't be encrypted and the ESNI-Resolve may become incorrect over time. It needs to handshake twice, however, it provided PFS and I think it worth it. And if multiple sites are hosted on the same server (e.g.CDN, Host Service Provider), we just need to do the second handshake, which eliminate the risk of DoS attack in some level.... And I think 0RTT symmetric decryption is better than asymmetric decryption.\r\nSetting max-age too big or too small both have some risks, and I don't know how to solve it.\r\n\r\n**If you don't like the idea of authenticating the Client-Facing Server, you can simply replace the ESNI-Trust header's content into a public key and use your method. But I don' think set a static public key is a good idea ( explained in some part of DNS disadvantage ).**\r\n\r\nAll in all, we can't have both efficiency, performance and security,  reliability. You should make up your mind and choose whether to provide perfect security or perfect performance. I prefer the former.\r\n\r\nI know that my idea is similar to draft-ietf-tls-sni-encryption than yours. However, you are the candidate for TLS WG, so I hope you can think it over. But I do agree with your idea that \"no need to don't stick out\" or simply \"we can stick out\" :D",
      "createdAt": "2018-08-20T07:15:32Z",
      "updatedAt": "2018-10-21T20:44:31Z",
      "closedAt": "2018-10-21T20:44:31Z",
      "comments": [
        {
          "author": "yfdyh000",
          "authorAssociation": "NONE",
          "body": "> so that all browsers can' get the public key and downgrade to cleartext-sni.\r\n\r\nhttps://github.com/ekr/draft-rescorla-tls-esni/blob/master/draft-ietf-tls-esni.md#misconfiguration prevent this case happening.\r\n\r\n> My main idea is to introduce a series of HTTP headers like HSTS and HPKP. \r\n> When the first time I visit https://www.example.com , I just do the normal tls1.3 hand shake with clear-text sni.\r\n\r\nThis introduces exposure and interception opportunities; a TLS connection that remains connected may not require an external SNI. (I am not sure)\r\n\r\nTLS also works with protocols other than HTTP(S). If the ESNI relies on HTTP headers, it is HTTPS only.",
          "createdAt": "2018-09-14T17:45:18Z",
          "updatedAt": "2018-09-14T17:45:18Z"
        },
        {
          "author": "JemmyLoveJenny",
          "authorAssociation": "NONE",
          "body": "@yfdyh000 \r\n> This introduces exposure and interception opportunities; a TLS connection that remains connected may not require an external SNI. (I am not sure)\r\n> \r\n> TLS also works with protocols other than HTTP(S). If the ESNI relies on HTTP headers, it is HTTPS only.\r\n\r\nTo solve this problem, we can simply change from HTTP headers to TLS extensions. In TLS1.3, handshake extensions are encrypted as well. The only thing need to be done is defining the structure of these settings.",
          "createdAt": "2018-09-15T08:51:53Z",
          "updatedAt": "2018-09-15T08:51:53Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "Not seeing much support for removing DNS here, so closing this issue.",
          "createdAt": "2018-10-21T20:44:31Z",
          "updatedAt": "2018-10-21T20:44:31Z"
        }
      ]
    },
    {
      "number": 97,
      "id": "MDU6SXNzdWUzNjI5ODY2OTg=",
      "title": "Should the server send the SNI confirmation extension?",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/97",
      "state": "CLOSED",
      "author": "ekr",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-09-23T23:20:42Z",
      "updatedAt": "2018-10-21T20:33:05Z",
      "closedAt": "2018-10-21T20:33:05Z",
      "comments": [
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed when we added the nonce",
          "createdAt": "2018-10-21T20:33:05Z",
          "updatedAt": "2018-10-21T20:33:05Z"
        }
      ]
    },
    {
      "number": 99,
      "id": "MDU6SXNzdWUzNjg0MzcwOTc=",
      "title": "Add a reference to draft-ietf-dns-attrleaf",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/99",
      "state": "CLOSED",
      "author": "ekr",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "As well as the IANA registrations",
      "createdAt": "2018-10-09T23:27:53Z",
      "updatedAt": "2018-10-21T22:21:25Z",
      "closedAt": "2018-10-21T22:21:25Z",
      "comments": []
    },
    {
      "number": 103,
      "id": "MDU6SXNzdWUzNzMwMTI3ODU=",
      "title": "Extension as vector of ClientEncryptedSNI structures",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/103",
      "state": "CLOSED",
      "author": "roelfdutoit",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Please consider changing the ESNI client extension to a vector of ESNI values.  This could be used for server-side redundancy and key rollover.  I understand that only one of the entries would be ack'd in EE, and that we would have to think through the possible attacks on the mechanism due to the change.\r\n",
      "createdAt": "2018-10-23T13:54:25Z",
      "updatedAt": "2019-07-03T21:06:44Z",
      "closedAt": "2019-07-03T21:06:44Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@roelfdutoit can you please bring this issue to the list for further discussion?",
          "createdAt": "2019-07-03T03:52:22Z",
          "updatedAt": "2019-07-03T03:52:22Z"
        }
      ]
    },
    {
      "number": 105,
      "id": "MDU6SXNzdWUzNzM3Mzc3MDQ=",
      "title": "remove _esni prefix because it makes CNAME alias too hard",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/105",
      "state": "CLOSED",
      "author": "mcmanus",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "issue #7 briefly discussed the choice of a _esni DNS prefix for the TXT record. I think we should revisit that.\r\n\r\nMy primary concern is that using 2 different names for the addressing and key information makes DNS aliasing un-necessarily complicated.\r\n\r\nConsider the case where www.example.com is a customer of bigHoster.com and bigHoster.com is deploying ESNI for all its customers.\r\n\r\nA classic way to do this is to have www.example.com be a CNAME for host1.bighoster.com\r\n\r\nunfortunately to use bighoster.com's new ESNI infrastructure www.example.com would need to add a CNAME record for _esni.www.example.com as well. So the ESNI deployment requires DNS changes outside of the org deploying ESNI, which is going to limit its deployment, which in turn is going to limit the breadth of its anonymity pool. :(\r\n\r\nAdditionally, I've been told that anecdotally putting names under a CNAME is legal but error prone. RFC 1912 seems to have some language that suggests its not even legal (though that is informational).\r\n\r\nIf the ESNI information were instead stored without a prefix then the alias would automatically apply as the CNAME applies to all the RR's of a hostname.\r\n\r\nPart of the reason for choosing the prefix was to avoid collisions in the TXT space, so it makes sense to also reopen #40 and use a non TXT RR type if we drop the prefix. I think the consensus is moving towards that being fine.\r\n\r\nThis would also resolve #79 to harmonize esni with existing dns deployments.\r\n\r\n",
      "createdAt": "2018-10-25T01:31:36Z",
      "updatedAt": "2019-03-06T00:55:58Z",
      "closedAt": "2019-03-06T00:55:58Z",
      "comments": [
        {
          "author": "mcmanus",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I forgot to acknowledge the downside here is with apex records. You can't cname an apex record, so the normally annoying second cname with the prefix is actually the only thing the apex can use natively as an alias and this proposal gives that up.\r\n\r\notoh apex records inline someone's A records (usually a single provider's anycast) already so they can  do the same thing with esni.. and/or we could allow some kind of delegation explicitly as part of the new rrtype (i.e. delegation within the new rrtype data, not via cname)",
          "createdAt": "2018-10-25T01:35:32Z",
          "updatedAt": "2018-10-25T01:35:32Z"
        },
        {
          "author": "mcmanus",
          "authorAssociation": "CONTRIBUTOR",
          "body": "also see pr #73 ",
          "createdAt": "2018-10-25T01:36:59Z",
          "updatedAt": "2018-10-25T01:36:59Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "> unfortunately to use bighoster.com's new ESNI infrastructure www.example.com would need to add a CNAME record for _esni.www.example.com as well. So the ESNI deployment requires DNS changes outside of the org deploying ESNI, which is going to limit its deployment, which in turn is going to limit the breadth of its anonymity pool. :(\r\n\r\nI am not sure if I agree with the problem statement.\r\n\r\nTo me it seems that the argument is based on the assumption that bighoster.com is the one to decide if ESNI should be applied for www.example.com. I am not sure if all of us would be happy with that assumption.\r\n\r\nThe alternative approach here is to give the owner of each hostname the freedom of deciding whether the hostname should be covered by ESNI. Current design allows the hosting companies to adopt that model, by using the DNS configuration that the hostname owner controls as the switch.",
          "createdAt": "2018-10-25T02:49:22Z",
          "updatedAt": "2018-10-25T03:48:22Z"
        },
        {
          "author": "mcmanus",
          "authorAssociation": "CONTRIBUTOR",
          "body": "ESNI is already a property of the server not the origin name.. in the same way the version of TLS or the cipher suite set is a property of the server.. or the level of http. All necessarily under the control of bighoster.com because it reflects whatever is available on their infrastructure.\r\n\r\nbighoster may commonly allow their customers to configure this stuff on a per customer or service basis, but that's a bit of a different take and not incompatible with the approach here.",
          "createdAt": "2018-10-25T14:04:12Z",
          "updatedAt": "2018-10-25T14:04:12Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "@mcmanus While that might be true, I am not sure if removing the `_esni` prefix and introducing ESNIInclude (#110) is worth the additional complexity and overhead.\r\n\r\nAssuming that we merge #109, #79 becomes a non-issue. Because a wildcard will much all names with the designated type, including the `_esni` prefix.\r\n\r\nFor example, the following configuration will support ESNI for all the hostnames under example.com, like `a.example.com`, `b.c.example.com`, because any query for `_esni.*.example.com` resolves to `*.example.com`.\r\n\r\n```\r\n*.example.com. IN A 192.0.2.1\r\n*.example.com IN ESNI ...\r\n```\r\n\r\nSo the only downside is that using prefix and a dedicated RR type at the same time might look strange. But it's practical.\r\n\r\nI am not sure if we would prefer to require alias resolution for every ESNI client.\r\n\r\nImplementation wise, it's about reimplementing what DNS recursor usually does in the stub resolver. You need to do things like detecting too many redirects and/or loops.\r\n\r\nThere would also be a performance degradation, because each client needs to do the recursive lookup, while with the prefix we can rely on the recursive resolvers to do it and cache it for other clients.\r\n\r\nTo reiterate, I wonder if there is any *practical* reason to reinvent the wheel.",
          "createdAt": "2018-11-02T04:09:19Z",
          "updatedAt": "2018-11-02T04:11:58Z"
        },
        {
          "author": "MikeBishop",
          "authorAssociation": "NONE",
          "body": "Stretching the bounds of my DNS knowledge here, but I *think* this makes divergence between the A/AAAA and ESNIKeys records much less likely.  That is, when www.example.com is served by both CDN A and CDN B, the DNS will return `www.example.com CNAME www.example.com.cdnalpha.com` or `www.example.com CNAME www.example.com.cdnbeta.com`.  If both things are record types on the same hostname, then the divergence only happens when the queries happen on opposite sides of a cached CNAME record expiring and getting the opposite answer the next time around.\r\n\r\nBut if they're separate hostnames, as in the current doc, it's entirely possible to get opposite CNAME records cached, and you've diverged for all clients of the caching resolver for the TTL of the shorter CNAME record.  That's a far worse probability of divergence.",
          "createdAt": "2019-03-01T23:06:17Z",
          "updatedAt": "2019-03-01T23:06:17Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed in #144. Closing. ",
          "createdAt": "2019-03-06T00:55:58Z",
          "updatedAt": "2019-03-06T00:55:58Z"
        }
      ]
    },
    {
      "number": 107,
      "id": "MDU6SXNzdWUzNzQyNzU1MTQ=",
      "title": "Unclear sentence in section 7.1 \"Why is cleartext DNS OK?\"",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/107",
      "state": "CLOSED",
      "author": "thomwiggers",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The second paragraph of this section currently contains:\r\n\r\n```\r\nClearly, DNSSEC (if the client validates and hard fails) is a defense against\r\nthis form of attack, but DoH/DPRIVE are also defenses against DNS attacks\r\nby attackers on the local network, which is a common case where SNI.\r\n```\r\n\r\nClearly, the sentence abruptly ends.\r\n\r\nMoreover, the sentence could probably be split in two, at the \"but\". This should make it easier to read.",
      "createdAt": "2018-10-26T08:19:00Z",
      "updatedAt": "2018-11-26T22:13:21Z",
      "closedAt": "2018-11-26T22:13:21Z",
      "comments": [
        {
          "author": "Eudi4H",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Nick Lamb [comments](https://www.ietf.org/mail-archive/web/tls/current/msg27298.html) on the same passage:\r\n> In section 7.1 the -02 draft says:\r\n>> Clearly, DNSSEC (if the client validates and hard fails) is a defense against this form of attack, but DoH/DPRIVE are also defenses against DNS attacks by attackers on the local network, which is a common case where SNI.\r\n>\r\n> Where SNI what?\r\n>\r\n> I'd be tempted to just say that yes, an active adversary can force you to choose between privacy and connectivity, and hard fail DNSSEC is the only existing way to choose privacy.\r\n> \r\n> The current text feels more like an attempt by people who don't want to face the Dancing Pig problem to justify why their latest seat-belt that snaps in a crash (to borrow Adam Langley's phrase) is a good idea anyway. But regardless of whether I'm correct about that, the sentence is confusing as it stands now.",
          "createdAt": "2018-11-26T22:08:54Z",
          "updatedAt": "2018-11-26T22:08:54Z"
        }
      ]
    },
    {
      "number": 109,
      "id": "MDU6SXNzdWUzNzQ0NDY5MTg=",
      "title": "Use ESNI RRType instead of TXT",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/109",
      "state": "CLOSED",
      "author": "mcmanus",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "PR #73 from @ghedo implements the ESNI RRType, but there doesn't seem to be another issue currently open to track discussion of it.\r\n\r\n* a new RRType allows the removal of the _esni prefix (#105 and #79)\r\n* reusing TXT has the potential for conflicts with other uses even with the prefix. (imagine the definition of a TXT record that simply applied to all DNS entries)\r\n* while both TXT and ESNI are 8 bit clean, some people are surprised to learn that about TXT so using a new type may be more robust. Some generic tools processing TXT records would benefit from this.\r\n* TXT is a set of  <= 255 byte strings, defining a new type removes that complexity and reduces overhead\r\n* There was initially concern about the viability of new RRTypes, but I believe people are more comfortable with that now than when the text was drafted.",
      "createdAt": "2018-10-26T15:58:31Z",
      "updatedAt": "2019-03-06T00:55:27Z",
      "closedAt": "2019-03-06T00:55:27Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed in #144.",
          "createdAt": "2019-03-06T00:55:27Z",
          "updatedAt": "2019-03-06T00:55:27Z"
        }
      ]
    },
    {
      "number": 110,
      "id": "MDU6SXNzdWUzNzQ0NTIyMDA=",
      "title": "ESNIInclude",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/110",
      "state": "CLOSED",
      "author": "mcmanus",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "needs WG discussion"
      ],
      "body": "issues #105 and #79 advocate for the removal of the _esni prefix.\r\n\r\nA significant side effect of that is that it becomes impossible to use a CNAME at the apex of a zone in order to refer to ESNIKeys of a server operated elsewhere. Inlining keys, as is often done with A/AAAA at the apex, is not plausible due to key rotation.\r\n\r\nThe issue can largely be mitigated with the introduction of an inclusion mechanism directly in the TXT/ESNI record.\r\n",
      "createdAt": "2018-10-26T16:13:11Z",
      "updatedAt": "2019-11-02T01:02:56Z",
      "closedAt": "2019-11-02T01:02:56Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "This should be fixed by #136 and follow up changes. Closing as such. Please reopen if necessary!",
          "createdAt": "2019-06-19T16:53:07Z",
          "updatedAt": "2019-06-19T16:53:07Z"
        },
        {
          "author": "mcmanus",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I don't believe #136 resolves this.\r\n\r\n136 effectively requires the address and ESNI information to be stapled together (which I still find objectionable). The issue here is that the apex cannot use a CNAME to delegate to the actual third party provider's ESNI record.. typically it just includes an A/AAAA record at the apex and hopes the pointer doesn't go stale. That's bad enough for A/AAAA but it would be terrible for ESNI because it means copying keying information and hoping it doesn't go stale between two different entities.\r\n\r\n@chris-wood can you reopen?",
          "createdAt": "2019-06-27T20:21:01Z",
          "updatedAt": "2019-06-27T20:21:01Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Sure! Sorry for the misunderstanding. We can probably update this PR to make use of the new DNS-specific extensions.",
          "createdAt": "2019-06-28T15:12:59Z",
          "updatedAt": "2019-06-28T15:12:59Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed by #187.",
          "createdAt": "2019-11-02T01:02:56Z",
          "updatedAt": "2019-11-02T01:02:56Z"
        }
      ]
    },
    {
      "number": 113,
      "id": "MDU6SXNzdWUzNzcwMjM2Njk=",
      "title": "Requirements on backend servers in Split Mode",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/113",
      "state": "CLOSED",
      "author": "Eudi4H",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "As of 7bd60fc, Section 3.1 says that in Split Mode, \"the backend server can be an unmodified TLS 1.3 server.\"\r\n\r\nBut I feel that statement is contradicted by:\r\n- Section 5.4: \"In Split Mode, the backend server must know PaddedServerNameList.nonce to echo it back in EncryptedExtensions and complete the handshake. ... backend servers function the same as servers operating in Shared mode.\"\r\n- Section 7.3: \"...the backend server also only has one identity.\"\r\n- Appendix B: \"When operating in Split mode, backend servers will not have access to PaddedServerNameList.sni or ClientESNIInner.nonce...\"\r\n\r\nA standard TLS 1.3 server that has more than one identity (i.e., requires plaintext SNI) won't work as a backend server. Even if the backend server has only one identity and ignores the forwarded encrypted_server_name extension, and therefore returns a default certificate, it seems that the connection will still fail because of the requirement in Section 5.1 that the client \"MUST check that ClientESNIInner.nonce matches the value of the 'encrypted_server_name' extension provided by the server.\" So I propose removing or amending the statement in Section 3.1. I don't see a way to deploy a Split-Mode topology without making the backend server ESNI-aware and doing some exchange along the lines of Appendix B, but I might have missed something.\r\n\r\nAm I correct in thinking that the current Cloudflare deployment is Shared Mode, not Split Mode, despite that Figure 2 looks more like a typical CDN topology? Because the TLS gets terminated at the Cloudflare CDN edge server, and the connection to the Cloudflare customer's web server is done with an independent connection.",
      "createdAt": "2018-11-03T04:59:57Z",
      "updatedAt": "2019-05-09T06:31:15Z",
      "closedAt": "2019-05-09T06:31:15Z",
      "comments": [
        {
          "author": "Eudi4H",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Closing in favor of #130.",
          "createdAt": "2019-05-09T06:31:15Z",
          "updatedAt": "2019-05-09T06:31:15Z"
        }
      ]
    },
    {
      "number": 116,
      "id": "MDU6SXNzdWUzNzcxMzQ4MjM=",
      "title": "Compress server name in ClientHello",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/116",
      "state": "CLOSED",
      "author": "kazuho",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "needs WG discussion"
      ],
      "body": "In a large-scale server deployment that benefits the most from ESNI (due to the size of the umbrella under which you would hide the domain names), it is often the case that the largest length of the server name to be supported is *unknown*. That leads such server deployments to use a padded_length of 260 because the longest valid DNS name is 253 characters, bloating the ClientHello.\r\n\r\nIt is beneficial to apply a lightweight compression algorithm to the server name to reduce the overhead.\r\n\r\nSome points to consider:\r\n* We cannot use a pre-learnt dictionary, because what we care is the longest possible length. Compression algorithm using a pre-learnt dictionary assigns longer symbols for rarely used patterns, which means that the worst case is longer than the non-compressed string.\r\n* We can use an adaptive compression algorithm (e.g. lz77, brotli), however they also would not compress well if the server-name is a random-looking string.",
      "createdAt": "2018-11-04T09:13:59Z",
      "updatedAt": "2019-11-05T20:10:41Z",
      "closedAt": "2019-11-05T20:10:41Z",
      "comments": [
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "Considering the two points, one practical solution will be to map the valid characters of a DNS name (i.e. `a`-`z`,`0`-`9`,`.`,`-`,`_`) to integers between 0 to 38, and encode three characters into a 16-bit value (39<sup>3</sup>=59319).\r\n\r\nBy applying the conversion, the worst length changes from 253 to 169 (i.e. `ceil(253/3*2)`), giving us 84 bytes back.",
          "createdAt": "2018-11-04T09:17:34Z",
          "updatedAt": "2018-11-05T00:11:40Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "To put it another way, the entropy we have when the set of server names is unknown is 39<sup>253</sup> ~ 256<sup>167.2</sup>.\r\n\r\nI do not think that we can go far below this limit by using contexts between the characters, because there aren't many patterns that are forbidden (two consecutive dots is (possibly one of the) rare pattern that never appears).\r\n\r\nConsidering that, using `mod 39` to squeeze three characters into 16 bit to achieve 256<sup>169</sup> is reasonable.",
          "createdAt": "2018-11-05T02:36:31Z",
          "updatedAt": "2018-11-05T02:36:31Z"
        },
        {
          "author": "kontaxis",
          "authorAssociation": "NONE",
          "body": "The valid characters in a DNS host name are [a-zA-Z0-9-] so 63.\r\n\r\nYou can represent each 8-bit character in the above set using 6 bits and group 4 characters together to form 24 bits.\r\nYou can then represent the 24 bits as 3 8-bit characters.\r\nThis is basically the Base64 decoding process.\r\nThe output is 3/4 of the input which means you gain 25%.\r\n\r\nBut then ServerName in ClientESNIInner won't be the same as the ServerName defined in RFC 3546 and it probably won't be printable.",
          "createdAt": "2019-03-08T00:24:04Z",
          "updatedAt": "2019-03-08T00:58:48Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@kazuho how do you want to proceed here?",
          "createdAt": "2019-11-04T20:48:37Z",
          "updatedAt": "2019-11-04T20:48:37Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "@chris-wood I think we should close this with no action.",
          "createdAt": "2019-11-05T06:03:32Z",
          "updatedAt": "2019-11-05T06:03:32Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Sounds good! Closing.",
          "createdAt": "2019-11-05T20:10:41Z",
          "updatedAt": "2019-11-05T20:10:41Z"
        }
      ]
    },
    {
      "number": 117,
      "id": "MDU6SXNzdWUzNzcyODUwNzA=",
      "title": "easy to miss validity intervals",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/117",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "@hardie notes that the not_before and not_after fields are there and described, but not really part of the operational notes.  Having something there that talks about these, particularly as it relates to clock skew, would be valuable.",
      "createdAt": "2018-11-05T07:52:04Z",
      "updatedAt": "2019-06-17T18:17:54Z",
      "closedAt": "2019-06-17T18:17:54Z",
      "comments": [
        {
          "author": "sftcd",
          "authorAssociation": "NONE",
          "body": "(My ~monthly login into github.com - this'd be better on the TLS WG list, and I will send mail on this sometime but anyway...)\r\nThe not-before and not-after fields are a mistake.\r\nSame as turned out true for x.509.\r\nI was just doing testing where FF nightly barfed on ESNIKeys I'd published for only that non-reason. (There is no overall security win in so-doing, in general.)\r\nCreating a tangle between the cadence at which one updates DNS, the ESNIKeys-internal \"lifetime\" of a key, the DNS TTL and server-state is basically just pointless nonsense. \r\nLet's delete those fields from ESNIKeys before we're done and just rely on DNS for what it already does.",
          "createdAt": "2019-06-10T22:49:18Z",
          "updatedAt": "2019-06-10T22:49:18Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "Now that #124 has been merged, I agree that there is less need for not_before and not_after fields. Previously, a client using an expired key led to connection failure, and therefore having these fields were necessary.",
          "createdAt": "2019-06-11T02:49:02Z",
          "updatedAt": "2019-06-11T02:49:13Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed by removing these fields with #161.",
          "createdAt": "2019-06-17T18:17:49Z",
          "updatedAt": "2019-06-17T18:17:49Z"
        }
      ]
    },
    {
      "number": 118,
      "id": "MDU6SXNzdWUzNzc0MDY4OTc=",
      "title": "Is there a debug/development server to test client side implementation",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/118",
      "state": "CLOSED",
      "author": "mosajjal",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "We've recently developed a PoC for ESNI and we're having trouble pinning down what we're doing wrong since the test URL (https://cloudflare.com/cdn-cgi/trace) is still showing sni=off. \r\n\r\nI was wondering if CloudFlare is considering running a test/debug server to help us facilitate the development of various clients. ",
      "createdAt": "2018-11-05T13:46:41Z",
      "updatedAt": "2019-11-06T22:02:21Z",
      "closedAt": "2019-06-02T15:08:29Z",
      "comments": [
        {
          "author": "sftcd",
          "authorAssociation": "NONE",
          "body": "Same here - well, sorta, I've just got to where I've an openssl [build](https://github.com/sftcd/openssl/tree/master/esnistuff)  sending a CH with the ESNI extension in that seems maybe correctish;-)\r\n\r\nWould be great if there was a public server to bang against.",
          "createdAt": "2018-11-20T21:26:09Z",
          "updatedAt": "2018-11-20T21:26:09Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "https://www.cloudflare.com/ssl/encrypted-sni/ supports the latest, Firefox does too (if you turn on all the right options, which I can share if necessary).",
          "createdAt": "2018-11-20T21:50:15Z",
          "updatedAt": "2018-11-20T21:50:15Z"
        },
        {
          "author": "sftcd",
          "authorAssociation": "NONE",
          "body": "Ta - was trying cloudflare.net - www.cloudflare.com seems to get me a bit further. Off to debug so:-)",
          "createdAt": "2018-11-20T21:56:31Z",
          "updatedAt": "2018-11-20T21:56:31Z"
        },
        {
          "author": "mosajjal",
          "authorAssociation": "NONE",
          "body": "[this](https://www.cloudflare.com/cdn-cgi/trace)  address is also good. But I'm looking for a debug server because my request's ESNI gets ignored by the server and I can't figure out why. ",
          "createdAt": "2018-11-21T04:43:53Z",
          "updatedAt": "2018-11-21T04:43:53Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing, since this is not an issue with the draft. Moved initial implementation list to https://github.com/tlswg/draft-ietf-tls-esni/wiki/ESNI-Implementations.",
          "createdAt": "2019-06-02T15:08:29Z",
          "updatedAt": "2019-06-02T15:08:29Z"
        },
        {
          "author": "sftcd",
          "authorAssociation": "NONE",
          "body": "Hiya, I just put up a server based on my openssl code; see https://defo.ie/ for details. (I would've tried edit the wiki but didn't see a button;-)",
          "createdAt": "2019-06-14T15:04:00Z",
          "updatedAt": "2019-06-14T15:04:00Z"
        },
        {
          "author": "avened",
          "authorAssociation": "NONE",
          "body": "Hello. There is a test server with ESNI support available at https://tls13.1d.pw/ (TLS 1.3 only).",
          "createdAt": "2019-11-04T16:33:15Z",
          "updatedAt": "2019-11-04T16:33:15Z"
        },
        {
          "author": "sftcd",
          "authorAssociation": "NONE",
          "body": "Hiya, that works with my ``openssl s_client`` client... so long as you don't send me an HRR! (Which you seem to be doing about every 2nd time?) If you do send me an HRR, then my side doesn't do the right thing yet - my code admittedly did have a \"TODO: ... implement ... handling HRR\" comment;-) ",
          "createdAt": "2019-11-06T21:28:56Z",
          "updatedAt": "2019-11-06T21:28:56Z"
        },
        {
          "author": "avened",
          "authorAssociation": "NONE",
          "body": "Actual probability of HRR being sent depends on key shares received from client (but, yes, it can be near 1/2). What concerns HRR + ESNI - interestingly, the same happened in NSS and Firefox, I've encountered it while testing browsers against this same test server (fixed in NSS 3.43 release).",
          "createdAt": "2019-11-06T22:02:20Z",
          "updatedAt": "2019-11-06T22:02:20Z"
        }
      ]
    },
    {
      "number": 119,
      "id": "MDU6SXNzdWUzODM4NDMzMzU=",
      "title": "record_digest input bytes",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/119",
      "state": "CLOSED",
      "author": "sftcd",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "The I-D says: \"record_digest : A cryptographic hash of the ESNIKeys structure from which the ESNI key was obtained, i.e., from the first byte of \"checksum\" to the end of the structure. This hash is computed using the hash function associated with suite.\"\r\n\r\nFrom looking at the NSS code it appears that the record_digest input is actually the entire ESNIKeys (after base64 decode) including the version and checksum. Is that correct?\r\n\r\nIOW, does the following also produce the right value (for CF and sha256)?\r\n\r\n``dig +short txt _esni.www.cloudflare.com  | sed -e 's/\"//g' | base64 -d | openssl sha256``",
      "createdAt": "2018-11-23T14:27:47Z",
      "updatedAt": "2019-07-03T03:51:26Z",
      "closedAt": "2019-07-03T03:51:26Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "#163 proposes removing the checksum, which should clear this up. ",
          "createdAt": "2019-07-03T01:16:34Z",
          "updatedAt": "2019-07-03T01:16:34Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing since #163 landed. @sftcd, please re-open if this is still an issue!",
          "createdAt": "2019-07-03T03:51:26Z",
          "updatedAt": "2019-07-03T03:51:26Z"
        }
      ]
    },
    {
      "number": 121,
      "id": "MDU6SXNzdWUzODkzODExMjM=",
      "title": "Can the ESNI values change upon HRR?",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/121",
      "state": "CLOSED",
      "author": "kazuho",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "chris-wood"
      ],
      "labels": [
        "needs WG discussion"
      ],
      "body": "RFC 8446 requires us to specify if the contents of ESNI can change upon a HRR.\r\n\r\nIn case of ESNI, the payload of the extension obviously can change, because the AAD (i.e. ClientHello.KeyShareClientHello) can change. However, we haven't specified if other values (e.g., ClientESNIInner.nonce) can.\r\n\r\nIMO, we should prohibit needless changes.\r\n\r\nTo clarify, all the non-encrypted portion and the encrypted payload of ESNI MUST be consistent between the first ClientHello and the second one.",
      "createdAt": "2018-12-10T16:28:25Z",
      "updatedAt": "2020-03-09T21:58:12Z",
      "closedAt": "2020-03-09T21:58:12Z",
      "comments": [
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "\ud83d\udc4d ",
          "createdAt": "2018-12-10T16:56:17Z",
          "updatedAt": "2018-12-10T16:56:17Z"
        },
        {
          "author": "jb-wisemo",
          "authorAssociation": "NONE",
          "body": "Bad idea.  Causing the encrypted ESNI to change such that observers cannot determine if this is a request for the same or a different back end name is a major security feature of the mechanism.  If a popular CDN such a cloudflare or S3 enables ESNI on their front end servers, observers should not be able to detect if repeated requests from a client are the usual pattern of retrieving common noise from web frameworks, random surfing of many sites or a long visit to a banned site.  ESNI servers (and only ESNI servers) would deal with recognizing that requests are actually resuming the same session despite the camouflage differences.\r\n",
          "createdAt": "2019-03-01T18:51:41Z",
          "updatedAt": "2019-03-01T18:51:41Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "@jb-wisemo \r\n> Causing the encrypted ESNI to change such that observers cannot determine if this is a request for the same or a different back end name is a major security feature of the mechanism.\r\n\r\nI do not get that. When HRR is used on TCP, the fact that the 1st CH and 2nd CH (sent in HRR) specify the same server name will be evident from the fact that they are sent on a single TCP connection. In case of HRR used with cookies, an observer will be able to track the pair by using cookies.",
          "createdAt": "2019-03-02T21:45:06Z",
          "updatedAt": "2019-03-02T21:45:06Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "This is addressed in #207.",
          "createdAt": "2020-03-08T00:33:40Z",
          "updatedAt": "2020-03-08T00:33:40Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed by #207.",
          "createdAt": "2020-03-09T21:58:12Z",
          "updatedAt": "2020-03-09T21:58:12Z"
        }
      ]
    },
    {
      "number": 123,
      "id": "MDU6SXNzdWUzOTA4Mjg3Nzk=",
      "title": "Encrypted nonce in ClientESNIInner",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/123",
      "state": "CLOSED",
      "author": "roelfdutoit",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Would you consider a PR for encrypting the ClientESNIInner nonce?\r\n\r\nWhat I have in mind is the following:\r\n`struct {\r\n       EncryptedNonce enc_nonce;\r\n       PaddedServerNameList realSNI;\r\n   } ClientESNIInner;`\r\n.. where:\r\n`nonceAAD = ClientHello.KeyShareClientHello || realSNI`\r\n`EncryptedNonce = AEAD-Encrypt(nonce_key, nonce_iv, nonceAAD, nonce)`\r\n.. and:\r\n`nonce_key = HKDF-Expand-Label(Zx, \"nonce key\", Hash(ESNIContents), key_length)`\r\n`nonce_iv = HKDF-Expand-Label(Zx, \"nonce iv\", Hash(ESNIContents), iv_length)`\r\n\r\nThe use case is an escrow system where the client wants to allow **read-only** visibility of the real SNI value by only sharing {key,iv} and keeping {nonce_key,nonce_iv} and Zx secret.   Only the real server would be able to acknowledge 'nonce' in EncryptedExtensions.",
      "createdAt": "2018-12-13T19:38:59Z",
      "updatedAt": "2019-07-03T21:06:27Z",
      "closedAt": "2019-07-03T21:06:27Z",
      "comments": [
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "This seems like a change which is very hard to analyze with limited value,\nso I would not be in favor.\n\nOn Thu, Dec 13, 2018 at 11:39 AM Roelof DuToit <notifications@github.com>\nwrote:\n\n> Would you consider a PR for encrypting the ClientESNIInner nonce?\n>\n> What I have in mind is the following:\n> struct { EncryptedNonce enc_nonce; PaddedServerNameList realSNI; }\n> ClientESNIInner;\n> .. where:\n> nonceAAD = ClientHello.KeyShareClientHello || realSNI\n> EncryptedNonce = AEAD-Encrypt(nonce_key, nonce_iv, nonceAAD, nonce)\n> .. and:\n> nonce_key = HKDF-Expand-Label(Zx, \"nonce key\", Hash(ESNIContents),\n> key_length)\n> nonce_iv = HKDF-Expand-Label(Zx, \"nonce iv\", Hash(ESNIContents), iv_length)\n>\n> The use case is an escrow system where the client wants to allow\n> *read-only* visibility of the real SNI value by only sharing {key,iv} and\n> keeping {nonce_key,nonce_iv} and Zx secret. Only the real server would be\n> able to acknowledge 'nonce' in EncryptedExtensions.\n>\n> \u2014\n> You are receiving this because you are subscribed to this thread.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/tlswg/draft-ietf-tls-esni/issues/123>, or mute the\n> thread\n> <https://github.com/notifications/unsubscribe-auth/ABD1oU3KagiPrj04JxnWI89FlD92g9EQks5u4qzTgaJpZM4ZSSdw>\n> .\n>\n",
          "createdAt": "2018-12-13T19:44:37Z",
          "updatedAt": "2018-12-13T19:44:37Z"
        },
        {
          "author": "roelfdutoit",
          "authorAssociation": "NONE",
          "body": "PR created:\r\nhttps://github.com/tlswg/draft-ietf-tls-esni/pull/147",
          "createdAt": "2019-03-07T23:33:48Z",
          "updatedAt": "2019-03-07T23:33:48Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Hi @roelfdutoit, can you elaborate on the motivations for this change? In what scenario would the client wish to share the SNI with a third party?",
          "createdAt": "2019-03-08T00:41:18Z",
          "updatedAt": "2019-03-08T00:41:18Z"
        },
        {
          "author": "roelfdutoit",
          "authorAssociation": "NONE",
          "body": "Enterprise network security solutions are evolving, especially in the area of monitoring and analytics, and SNI is a valuable attribute in such an environment.  A client would share the ESNI {key,iv} with configured enterprise monitoring devices (NGFW, IPS, Proxy, IDS, DLP, etc) and this becomes critical in a zero trust network.  There is a lot of focus on using ESNI in a CDN world, but the mechanism would also be very valuable for enterprises that host multiple proprietary services - again, in a zero trust environment.  Those proprietary services and applications must be monitored at different points in the enterprise network, requiring access to the true SNI.  The PR would provide a responsible way to share the true SNI, without the need for traditional TLS intercept - assuming a secure sharing mechanism is used.",
          "createdAt": "2019-03-08T02:44:07Z",
          "updatedAt": "2019-03-08T02:44:07Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@roelfdutoit can you please bring this issue to the list for further discussion?",
          "createdAt": "2019-07-03T03:52:36Z",
          "updatedAt": "2019-07-03T03:52:36Z"
        }
      ]
    },
    {
      "number": 126,
      "id": "MDU6SXNzdWUzOTUwODkzNTI=",
      "title": "Do not send cached_info cert type when using ESNI",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/126",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "An adversary who observes the certificate fingerprint could confirm certificates previously fetched by a ESNI-compatible client.",
      "createdAt": "2019-01-01T14:46:54Z",
      "updatedAt": "2019-03-16T03:37:43Z",
      "closedAt": "2019-03-16T03:37:43Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed in #127.",
          "createdAt": "2019-03-16T03:37:43Z",
          "updatedAt": "2019-03-16T03:37:43Z"
        }
      ]
    },
    {
      "number": 130,
      "id": "MDU6SXNzdWU0MDA5NDQxODc=",
      "title": "Consider dropping split mode altogether",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/130",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "needs WG discussion"
      ],
      "body": "The mechanism to make split mode work in practice requires non-trivial changes to both the fronting server and origin. Moreover, as the main (mass user base) benefit for ESNI is shared mode, perhaps we should consider dropping split mode.",
      "createdAt": "2019-01-19T01:14:24Z",
      "updatedAt": "2019-09-28T14:41:38Z",
      "closedAt": "2019-09-28T14:41:38Z",
      "comments": [
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "I would not be in favor of this change. There are real uses for split mode and we should try to address them",
          "createdAt": "2019-01-19T03:00:16Z",
          "updatedAt": "2019-01-19T03:00:16Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'm in favor of removing split mode from this draft, the added complexity is not necessarily worth it.",
          "createdAt": "2019-01-20T00:33:47Z",
          "updatedAt": "2019-01-20T00:33:47Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I thought about this some and decided that:\r\n * Split mode is valuable and worth supporting.\r\n * It needs more specification than can reasonably fit in this draft.\r\n * It's part of a larger problem related to load balancers.\r\n\r\nSo I wrote a [new draft on this topic](https://tools.ietf.org/html/draft-schwartz-tls-lb-00).  My hope is that we can remove the detailed discussion of split mode here and replace it with a reference to that draft.\r\n\r\nThere's one thing I'd like to resolve before sending that draft to the TLS list: That draft is derived from the brief proposal in this draft to use a PSK to transfer `Z` between the servers.  I'm not 100% sure who proposed that design, but in my draft I added an acknowledgement to @ekr after looking through the version history here.  I'd like to make sure that credit is correct, and I'm happy to add whoever came up with that to the authors list.",
          "createdAt": "2019-06-28T15:03:31Z",
          "updatedAt": "2019-06-28T15:03:31Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "1. I am not in favor of removing the discussion of split mode from this\ndocument, though I am fine to have detail elsewhere.\n2. I think I was the person who proposed the PSK idea, but honestly, it's\npretty obvious so I'm not worried about credit and if someone else thinks\nthey were first, I'm not going to argue,\n\nOn Fri, Jun 28, 2019 at 8:03 AM Benjamin M. Schwartz <\nnotifications@github.com> wrote:\n\n> I thought about this some and decided that:\n>\n>    - Split mode is valuable and worth supporting.\n>    - It needs more specification than can reasonably fit in this draft.\n>    - It's part of a larger problem related to load balancers.\n>\n> So I wrote a new draft on this topic\n> <https://tools.ietf.org/html/draft-schwartz-tls-lb-00>. My hope is that\n> we can remove the detailed discussion of split mode here and replace it\n> with a reference to that draft.\n>\n> There's one thing I'd like to resolve before sending that draft to the TLS\n> list: That draft is derived from the brief proposal in this draft to use a\n> PSK to transfer Z between the servers. I'm not 100% sure who proposed\n> that design, but in my draft I added an acknowledgement to @ekr\n> <https://github.com/ekr> after looking through the version history here.\n> I'd like to make sure that credit is correct, and I'm happy to add whoever\n> came up with that to the authors list.\n>\n> \u2014\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/tlswg/draft-ietf-tls-esni/issues/130?email_source=notifications&email_token=AAIPLINHQPO5SJFANUDLRF3P4YR4JA5CNFSM4GRDQ36KYY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGODY2KNDA#issuecomment-506766988>,\n> or mute the thread\n> <https://github.com/notifications/unsubscribe-auth/AAIPLILIAK7IRVQRIZ3HQDTP4YR4JANCNFSM4GRDQ36A>\n> .\n>\n",
          "createdAt": "2019-06-28T16:32:15Z",
          "updatedAt": "2019-06-28T16:32:15Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "One discrepancy is whether the frontend shares the Z value with the backend or the ClientESNIInner. The new draft says the latter and the appendix in the ESNI draft says the former.\r\n\r\nWas there a particular reason to send Z? All else equal, ClientESNIInner seems much more straightforward to deploy and reason about. Frontend and backend need to coordinate on which ESNI encryption schemes to support if sending Z. It also feels odd to send along a raw unKDFed key exchange secret like that, but maybe it's fine?\r\n\r\n[Edit: I wrote \"do not need\" originally when I should have written \"need\".]",
          "createdAt": "2019-06-28T16:40:29Z",
          "updatedAt": "2019-06-28T16:41:03Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "I suggested Z on the theory that it would make it hard to lie about\nClientESNIInner. I haven't thought through it all in detail, though.\n\nOn Fri, Jun 28, 2019 at 9:40 AM David Benjamin <notifications@github.com>\nwrote:\n\n> One discrepancy is whether the frontend shares the Z value with the\n> backend or the ClientESNIInner. The new draft says the latter and the\n> appendix in the ESNI draft says the former.\n>\n> Was there a particular reason to send Z? All else equal, ClientESNIInner\n> seems much more straightforward to deploy and reason about. Frontend and\n> backend do not need to coordinate on which ESNI encryption schemes to\n> support if sending Z. It also feels odd to send along a raw unKDFed key\n> exchange secret like that, but maybe it's fine?\n>\n> \u2014\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/tlswg/draft-ietf-tls-esni/issues/130?email_source=notifications&email_token=AAIPLIIZ6L5ZNA73CCD2GB3P4Y5H5A5CNFSM4GRDQ36KYY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGODY2SNKI#issuecomment-506799785>,\n> or mute the thread\n> <https://github.com/notifications/unsubscribe-auth/AAIPLIJ2KE2AHR4J6D4ZCHTP4Y5H5ANCNFSM4GRDQ36A>\n> .\n>\n",
          "createdAt": "2019-06-28T16:45:25Z",
          "updatedAt": "2019-06-28T16:45:25Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "(Late filling this out...)\r\n\r\nDiscussed in Montreal: we don't need to remove it -- we simply shouldn't make it impossible to implement, and the draft as of now achieves that goal. So, I'm closing this issue.",
          "createdAt": "2019-09-28T14:41:11Z",
          "updatedAt": "2019-09-28T14:41:36Z"
        }
      ]
    },
    {
      "number": 131,
      "id": "MDU6SXNzdWU0MDczOTYwOTc=",
      "title": "Proposal: ESNI record Implies TLS support",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/131",
      "state": "CLOSED",
      "author": "bemasc",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "needs WG discussion"
      ],
      "body": "Proposal:\r\nThe ESNI DNS record specification, wherever it ends up, should have the following requirement:\r\n\"If a domain or endpoint publishes an ESNI DNS record, then that domain MUST be accessible over TLS.\"\r\n\r\nThis is almost trivial (why would you publish an ESNI record if you don't have TLS support?), but it would be tremendously useful for browsers, as a way to learn that the specified domain supports HTTPS before attempting a connection.  If DNS records are fetched over a secure channel, this would enable HSTS-like behavior without an insecure bootstrap or a preload list.",
      "createdAt": "2019-02-06T19:34:35Z",
      "updatedAt": "2019-07-03T00:10:21Z",
      "closedAt": "2019-07-03T00:10:21Z",
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "A domain name that has ESNI keys is very likely to support TLS, but you can't assume that is supports HTTPS on port 443 - they could be using TLS for something else.",
          "createdAt": "2019-02-06T19:47:06Z",
          "updatedAt": "2019-02-06T19:47:06Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "CONTRIBUTOR",
          "body": "That depends on how we define the ESNI record.  For example, we could insert a port in the name (like SRV), or include a list of the applicable ports in the record contents.  (Or we could just declare that ESNI implicitly blacklists port 80, which I believe is what you are arguing against.)\r\n\r\nIt's up to us.",
          "createdAt": "2019-02-06T19:58:19Z",
          "updatedAt": "2019-02-06T19:58:19Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "By default, http and https are different origins. HSTS is a opt-in signal that changes the behavior. \r\n\r\nConsidering that, I think that the discussion needs to happen the HTTPbis WG on if the WG should define an extension to ESNI.",
          "createdAt": "2019-02-08T08:02:14Z",
          "updatedAt": "2019-02-08T08:02:14Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Is ESNI something you would use for protocols other than HTTP?",
          "createdAt": "2019-07-03T00:00:54Z",
          "updatedAt": "2019-07-03T00:00:54Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "I tend to think yes. Suppose, for instance, you had DoQ.",
          "createdAt": "2019-07-03T00:07:40Z",
          "updatedAt": "2019-07-03T00:07:40Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Agreed. @bemasc, this should probably go to httpbis for discussion! I'm closing for now.",
          "createdAt": "2019-07-03T00:10:21Z",
          "updatedAt": "2019-07-03T00:10:21Z"
        }
      ]
    },
    {
      "number": 132,
      "id": "MDU6SXNzdWU0MDk5NjcxMTM=",
      "title": "Interaction with Alternative Services is confusing",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/132",
      "state": "CLOSED",
      "author": "DavidSchinazi",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The draft currently states:\r\n\r\n> In cases where the domain of the A or AAAA records being resolved do not match the SNI Server Name, such as when {{!RFC7838}} is being used, the SNI domain should be used for querying the ESNI TXT record.\r\n\r\nI'm confused about what this means. From reading RFC 7838, I'm not sure the SNI and DNS names do not match when you're querying an alternate name. In particular, RFC 7838 states:\r\n\r\n> For example, if the origin's host is \"www.example.com\" and an alternative is offered on \"other.example.com\" with the \"h2\" protocol, and the certificate offered is valid for \"www.example.com\", the client can use the alternative.\r\n\r\nWhich means, if I understand it correctly, the client will send \"other.example.com\" in the SNI when trying to query resources from it - the requirement is only that the certificate for \"other.example.com\" also cover \"www.example.com\".",
      "createdAt": "2019-02-13T19:36:27Z",
      "updatedAt": "2019-03-08T21:24:28Z",
      "closedAt": "2019-03-08T21:24:28Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Agreed. I'm parsing RFC 7838 the same way. I think we should drop this text.",
          "createdAt": "2019-02-16T00:41:15Z",
          "updatedAt": "2019-02-16T00:41:15Z"
        },
        {
          "author": "mcmanus",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The problem the text presents is real (though the resolution is arbitrary).\r\n\r\n> Which means, if I understand it correctly, the client will send \"other.example.com\" in the SNI when trying to query resources from it - the requirement is only that the certificate for \"other.example.com\" also cover \"www.example.com\".\r\n\r\nno.. that's a misread. See section 2.3 of 7838\r\n```\r\n Note that the SNI information provided in TLS by the client will be\r\n   that of the origin, not the alternative (as will the Host HTTP header\r\n   field value).\r\n```\r\n\r\nThe alternate is essentially just a cname for the origin. If host b is an alternate for origin a, in order to use the alternate you look up the DNS a/aaaa of b, do a TCP connect to b, and then use sni=a and expect a certificate valid for a. (indeed the point of the SNI is to tell the server what certificate you expect to see)\r\n\r\nWith esni you would continue to do all of those things, except of course sni=encrypted(a).. and the question becomes where do you find the key used for the encryption. Is it the ESNI DNS record of a (the origin) or b (the alternate host). That's the question the text is trying to resolve - it says to use a (the origin). I could make a case for either choice but I think the text needs to decide \r\n",
          "createdAt": "2019-02-17T01:59:38Z",
          "updatedAt": "2019-02-17T02:14:24Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@mcmanus Would you mind suggesting some text with an example to clear this up?",
          "createdAt": "2019-02-19T17:11:54Z",
          "updatedAt": "2019-02-19T17:11:54Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@mcmanus thanks for the clarification and pointer to s2.3 of 7838.\r\n\r\nAfter reading that I think the text in the ESNI draft looks fine. (I'd just add a pointer to s2.3 of 7838 instead of just 7838 to help prevent the confusion I had)",
          "createdAt": "2019-02-21T20:32:08Z",
          "updatedAt": "2019-02-21T20:32:17Z"
        }
      ]
    },
    {
      "number": 133,
      "id": "MDU6SXNzdWU0MTA1MDgxNDI=",
      "title": "Always returning the same records is too restrictive",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/133",
      "state": "CLOSED",
      "author": "DavidSchinazi",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The document currently states:\r\n\r\n> Servers operating in Split Mode SHOULD have DNS configured to return the same A (or AAAA) record for all ESNI-enabled servers they service. This yields an anonymity set of cardinality equal to the number of ESNI-enabled server domains supported by a given client-facing server. Thus, even with SNI encryption, an attacker which can enumerate the set of ESNI-enabled domains supported by a client-facing server can guess the correct SNI with probability at least 1/K, where K is the size of this ESNI-enabled server anonymity set. This probability may be increased via traffic analysis or other mechanisms.\r\n\r\nI think this is too restrictive. If I have 100000 names and 100 IPs and for all queries I randomly return four out of my 100 IPs chosen randomly, I still provide the same anonymity set but I violate the SHOULD. How about: `Content providers operating in Split Mode SHOULD ensure that the A and AAAA records for ESNI-enabled server names do not allow identifying the server name from the IP address. This can for example be achieved by always returning the same records for all ESNI-enabled names, or by having the function that picks addresses from a pool not depend on the server name. This yields an anonymity set...`",
      "createdAt": "2019-02-14T21:50:38Z",
      "updatedAt": "2019-06-02T15:13:39Z",
      "closedAt": "2019-06-02T15:13:39Z",
      "comments": [
        {
          "author": "enygren",
          "authorAssociation": "NONE",
          "body": "Agreed.  At a minimum this should reference a set of A and AAAA records rather than \"the record\" (as many records across the A and AAAA rrsets is very common).\r\n\r\nI think @DavidSchinazi's proposed text is fine.",
          "createdAt": "2019-02-21T16:21:12Z",
          "updatedAt": "2019-02-21T16:21:12Z"
        },
        {
          "author": "ghedo",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@DavidSchinazi sgtm, do you plan to open a PR? I made https://github.com/ghedo/draft-ietf-tls-esni/commit/c9570cf4a00925bead63d46ecd6744288209146e but I think your wording is better.",
          "createdAt": "2019-06-01T10:52:28Z",
          "updatedAt": "2019-06-01T10:52:28Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Created #157",
          "createdAt": "2019-06-02T09:36:08Z",
          "updatedAt": "2019-06-02T09:36:08Z"
        }
      ]
    },
    {
      "number": 134,
      "id": "MDU6SXNzdWU0MTA5MjY4OTU=",
      "title": "260 bytes is maybe a bit much?",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/134",
      "state": "CLOSED",
      "author": "davidben",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Stephen Farrell pointed out on the list that 260 is rather a lot of waste to stick into the ClientHello.\r\nhttps://mailarchive.ietf.org/arch/msg/tls/kW_SWFamoj6IME4JzGseBKDyUV4\r\n\r\n260 characters is this large of a hostname:\r\n```\r\n>>> \"a\" * 260\r\n'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa'`\r\n```\r\n\r\nIt's probably reasonable to recommend a smaller default value like 64 or 96 or 128. (Numbers pulled out of a hat. I have no data on how big it actually should be.)",
      "createdAt": "2019-02-15T20:15:01Z",
      "updatedAt": "2019-07-03T00:33:47Z",
      "closedAt": "2019-07-03T00:33:47Z",
      "comments": [
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "Yeah. The question is if we are happy with hostnames longer than the threshold (e.g., 64, 96, 128) sticking out. I think the current design of allowing the server to choose the correct value is the right approach.\r\n\r\nOTOH, regarding the size you'd use for greasing, I can understand the concern of wasting bytes. Maybe browsers can use smaller sized payloads when greasing the ESNI extension, under the premise that they would be sometimes using the maximum.\r\n\r\nThe size of the extension being different from when it is actually used does not matter in practice, because an observer can typically tell if ESNI was used by checking if the unencrypted SNI record contains the fallback domain name (here I assume that we adopt #134).",
          "createdAt": "2019-02-16T00:30:58Z",
          "updatedAt": "2019-02-16T00:30:58Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Agreed that letting the server choose the correct value makes sense. But I think the specification should also be opinionated about this, so we don't get wildly different values for everyone, and so implementors have something to pick if they don't really care. The closely thing the spec currently has to an opinion is 260, which is kind of large.",
          "createdAt": "2019-02-16T00:35:58Z",
          "updatedAt": "2019-02-16T00:35:58Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Absent data that shows there's a tighter upper bound, I would prefer to keep the 260 recommendation and perhaps suggest that servers may choose something smaller if they know better. ",
          "createdAt": "2019-02-16T00:39:11Z",
          "updatedAt": "2019-02-16T00:39:11Z"
        },
        {
          "author": "kontaxis",
          "authorAssociation": "NONE",
          "body": "According to RFC 1035 host names can be up to 255 octets.\r\nI don't think this has changed.\r\nSo if this document makes a recommendation it should cover the worst case.\r\n\r\nSomeone could argue for something more efficient.\r\nFor instance, if we were to do draw the distribution of name lengths we would find that the median is 13 characters. (An excellent number) Min is 4 and max is 117. (Source: https://scans.io/study/umich-https)\r\nBut this can change and the recommendation in this document will become outdated.\r\n\r\nMaybe add something like the following: \"servers COULD tailor the padding length to cover the longest name associated with the hosts they handle.\" (And keep the existing number)",
          "createdAt": "2019-03-08T06:14:27Z",
          "updatedAt": "2019-03-08T06:14:27Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "CONTRIBUTOR",
          "body": "In the current text, the \"260\" number only matters for GREASE; anyone who actually publishes ESNIKeys SHOULD choose the smallest number that covers their names, \"rounded up to the nearest multiple of 16\".  Given @kontaxis's data, the most common choices will likely be 16 and 32.  This state of affairs makes GREASE less effective, because (1) it doesn't resemble real usage and (2) it isn't exercising the length \"joint\".\r\n\r\nAs a solution, I would propose recommending that GREASE clients choose a valid length at random.  If we want to get fancy we could say that the random choice may be non-uniform (to favor shorter ClientHellos) but should have at least x% chance of choosing each length option.\r\n\r\nAlso, instead of saying that the padded_length \"SHOULD\" be 16*N or 260, I think we should consider a \"MUST\", and/or a denser encoding (e.g. enum with values 0..16).  Otherwise, we have to figure out what clients should do if `padded_length` is huge.  (I wonder how that interacts with QUIC and DDoS...)",
          "createdAt": "2019-05-21T18:40:27Z",
          "updatedAt": "2019-05-21T18:40:27Z"
        },
        {
          "author": "mrsylerpowers",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Another proposal is mentioned in #116 of just compressing these bits instead",
          "createdAt": "2019-06-10T16:14:07Z",
          "updatedAt": "2019-06-10T16:14:07Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@davidben this should be fixed, with new recommendation text, via #162. Please re-open if not!",
          "createdAt": "2019-07-03T00:33:46Z",
          "updatedAt": "2019-07-03T00:33:46Z"
        }
      ]
    },
    {
      "number": 135,
      "id": "MDU6SXNzdWU0MTMwMDU3MDU=",
      "title": "Extensible information in ESNIKey DNS record",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/135",
      "state": "CLOSED",
      "author": "enygren",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "We may wish to have a way to indicate additional (extensible?) information relevant to establishing a connection alongside ESNIKeys in whatever record is introduced.  This increases the value of clients doing an additional DNS resolution in cases where it reduces future round-trips and reduces the need for subsequent DNS lookups.  In particular (and their might be others in the future):\r\n\r\n* Being able to indicate that an Alternate Service (such as QUIC can/should be used).  Being able to switch directly to QUIC out of DNS without adding in additional resolutions, the need to go via TCP, or RTTs would add significant value and motivation to implement for clients and servers.\r\n\r\n* Being able to indicate that HSTS should be used on a bareword hostname (ie, to default to HTTPS when no scheme is present).  This might unblock browsers from defaulting to HTTPS.\r\n\r\n",
      "createdAt": "2019-02-21T16:14:52Z",
      "updatedAt": "2019-02-21T16:17:36Z",
      "closedAt": "2019-02-21T16:17:36Z",
      "comments": [
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "There already is such a field:\r\n\r\n```\r\n    struct {\r\n        uint16 version;\r\n        uint8 checksum[4];\r\n        KeyShareEntry keys<4..2^16-1>;\r\n        CipherSuite cipher_suites<2..2^16-2>;\r\n        uint16 padded_length;\r\n        uint64 not_before;\r\n        uint64 not_after;\r\n        Extension extensions<0..2^16-1>;   <---- HERE\r\n    } ESNIKeys;````\r\n",
          "createdAt": "2019-02-21T16:17:36Z",
          "updatedAt": "2019-02-21T16:17:36Z"
        }
      ]
    },
    {
      "number": 138,
      "id": "MDU6SXNzdWU0MTU0MDkxMDQ=",
      "title": "Use ESNI in local discovery mode",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/138",
      "state": "CLOSED",
      "author": "huitema",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "chris-wood"
      ],
      "labels": [],
      "body": "I am looking at using ESNI for local private discovery. It would work as follow:\r\n\r\n1) Authorized clients know the ESNI public key of the private server, which is otherwise kept secret.\r\n\r\n2) Client initiates a DTLS session or a QUIC connection by broadcasting a message containing ESNI extension targeting the specific server.\r\n\r\n3) Servers only respond if the recognize their key and name in the extension.\r\n\r\nESNI almost works as is for that, but not quite. First, the \"record_digest\" component allows identification and tracking of the server. In the private discovery mode, we would want to either not use it at all, or incorporate a nonce in the digest.\r\n\r\nSecond, ALPN. But you know that.",
      "createdAt": "2019-02-28T01:50:14Z",
      "updatedAt": "2019-07-08T17:26:02Z",
      "closedAt": "2019-07-08T17:26:01Z",
      "comments": [
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Re: ALPN: Why can't that be public?  You aren't intending to try to keep the fact that this is local private discovery, are you?",
          "createdAt": "2019-02-28T03:13:31Z",
          "updatedAt": "2019-02-28T03:13:31Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "body": "ALPN: It depends. Model 1 would be discovery over DTLS, i.e. handshake followed by DNS/MDNS over DTLS. Model 2 would be discovery integrated in the application, say using QUIC. The first client initial packet would be broadcast, and then the connection just proceeds.",
          "createdAt": "2019-02-28T03:44:00Z",
          "updatedAt": "2019-02-28T03:44:00Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I see, you are suggesting that - in model 2 - the connection is used for both discovery AND the application protocol.  I agree that the application protocol might be too revealing in that case.  \"h3\" might not be, but something more device-specific might leave nothing to the imagination.",
          "createdAt": "2019-02-28T03:51:46Z",
          "updatedAt": "2019-02-28T03:51:46Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Further analysis shows that even adding salt to the hash before computing the \"record digest\" will not help.  This is a defense in depth issue. The privacy of the discovery depends on keeping secret the \"discovery ESNI key\" of the service. If for some reason that key leaks, the attackers can mount active attacks and discover whether a target is present on a network. The record digest, even if it was salted, allows them to also perform passive attacks, such as looking at the digests in a log and checking whether they match a known key.\r\n\r\nThe simplest solution is to just omit the digest when using the ESNI extension for local discovery, e.g. when a DTLS or QUIC initial packet is received over a multicast address.",
          "createdAt": "2019-02-28T18:47:42Z",
          "updatedAt": "2019-02-28T18:47:42Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "> The simplest solution is to just omit the digest when using the ESNI extension for local discovery, e.g. when a DTLS or QUIC initial packet is received over a multicast address.\r\n\r\nSounds correct to me. To me it seems that the trade-off here is trial-decryption vs. exposing the key identifier. In the proposed local discovery scheme, every node is expected to perform trial decryption. That's fine for the proposed scheme, but not for ordinary ESNI keys in which we need a key identifier to avoid trial decryption.",
          "createdAt": "2019-03-05T07:08:54Z",
          "updatedAt": "2019-03-05T07:08:54Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "This should be fixed by #166. @huitema, please reopen if that's not the case!",
          "createdAt": "2019-07-08T17:26:01Z",
          "updatedAt": "2019-07-08T17:26:01Z"
        }
      ]
    },
    {
      "number": 139,
      "id": "MDU6SXNzdWU0MTYyMjg0NDU=",
      "title": "Associate the ESNI record with the client-facing server IP",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/139",
      "state": "CLOSED",
      "author": "jb-wisemo",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "help wanted"
      ],
      "body": "To maximize the cover range for clients and simplify management of the ESNI records, it is more useful to associate the ESNI records with the server rather than the query domain name.  This has the additional benefit of allowing different client-facing servers to use different rotating private DH keys.\r\n\r\nThis eliminates the issues with CNAMEs, individual query domain holders having to make changes, DNS namespace issues etc.\r\n\r\nFor example a large hoster wishing to provide cover for some clients by having their primary / CDN front ends offer ESNI for all requests can then simply enable the code on their server then add the ESNI records.  They can even do this gradually over a large pool of servers, thus having some servers with different (or no) ESNI support during each careful rollout of ESNI software upgrades.\r\n\r\nIn practice the following conventions would be used:\r\n\r\n1. Any ESNI server IP must have exactly one PTR record (typically pointing to the hoster domain, such as a typical systematic CDN node DNS name).  Lets call this name ptrnam.dom\r\n\r\n2. The ESNI records would be under _esni.ptrnam.dom\r\n\r\n3. As with most PTR records ptrnam.dom is expected to have exactly one AAAA or A record pointing back at the same IP (if the starting IP is IPv6 only AAAA need to satisfy this, if IPv4 only A, the same ptrnam.dom can be used for one IPv4 and one IPv6 address if the ESNI records would be the same).\r\n\r\n4. For address-less server types such as tor hidden services, the ESNI records would be published via whatever DNS or DNS-like mechanism is used for that transport, or queried by sending a DNS query for the record to the target, allowing the target to respond within that transport.\r\n\r\nBenefits:\r\n\r\n- B1. Large client-facing servers such as CDNs and shared IP hosters can deploy ESNI without having to negotiate DNS changes with all their customers (in fact with any of their customers).\r\n\r\n- B2. Operators of large pools of client-facing servers such as CDNs can roll out ESNI support and ESNI implementation upgrades in a piecemeal and controlled manner similar to how other system updates are rolled out.  Simply because each IP address will have its own ESNI records.\r\n\r\n- B3. ESNI key rotation becomes much simpler as there is no need to synchronize it between different servers in a pool (except where a pure layer 1/2/3 load balancer shares a single IP among multiple physical/virtual servers, such as the layer 2 HALinux scheme).\r\n\r\n- B4. ESNI private key protection can be much stronger when it is not shared among all the servers.  The private key may be kept in protected hardware and/or in volatile RAM.  The latter case would require clients to fall back to a different A or AAAA record until the DNS entries for now forgotten keys to have expired, but only in case of a server crash or similar event.\r\n\r\n- B5. Client queries for ESNI records do not reveal the actual query domain that will be encrypted, only the IP address to which the ESNI extension will be sent.\r\n\r\n- B6. The whole discussion about _esni prefix or no _esni prefix becomes a lot simpler when there is no need to put ESNI records in every end query domain, only domains of the client-facing servers, allowing to keep the unprefixed TXT name space clean for existing uses such as SPF.\r\n\r\nDownsides:\r\n\r\n- P1: Clients will have to postpone the _esni DNS query until after receiving the answer to the A or AAAA query, thus adding an extra DNS roundtrip before the first connection to a name.  The usual DNS caching hierarchy should mitigate this.  In particular for popular CDNs, a client will typically use the same handful of IPs for lots of unrelated traffic, thus getting the ESNI records in its local cache.\r\n\r\n- P2: VM hosting/Physical hosting/connectivity providers not granting PTR name assignment control to IP address customers will cause the same problems as for other protocols (such as mail) and should thus be under the same or greater pressure to add that service.  However since the greatest ESNI benefit is with IPs shared among many unrelated domains, and the operators of such IPs typically have full IP space ownership or the leverage to get PTR records where normal customers cannnot, the effect on ESNI deployment should be limited.\r\n\r\n- P3: This may or may not make it easier to do spoofing attacks, as an MitM attacker can spoof DNS responses either for the A/AAAA records of a target query domain (pointing to servers entirely under the attackers control, including legitimate ESNI records for that server) OR spoof the ESNI records of a server address for which the attacker has obtained traffic intercept ability.  However these can be secured with the same DNS countermeasures already applicable to those DNS domains.\r\n\r\n- P4: query domains wishing to remain available in massively blocking markets (the kind that would not hesitate to block an entire CDN to stop access to a single web page) may have more difficulty opting out of ESNI so such blocking filters can recognize them as a permitted service.\r\n",
      "createdAt": "2019-03-01T18:35:45Z",
      "updatedAt": "2020-05-27T12:20:57Z",
      "closedAt": "2020-05-27T12:20:56Z",
      "comments": [
        {
          "author": "mcmanus",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This has been kicked around before and generally not selected based on the\ndownsides you identify - prinicipally the serialization issue as well as\npractical matters of control of PTR records. It also prohibits the use of\nmore than 1 key on an address - that's obviously a bad thing for the\nanonymity pool at its extreme, but some architectures might require more\nthan one pool.\n\nYou can fix the latter two issues by using another suggestion that has\npreviously been made: connect to the server and validate an IP based\ncertificate and then get the ESNI key via a REST API (or equivalent) - but\nthat is still likely too slow and comes with the challenges of IP based\ncertificate management.\n\nOn Fri, Mar 1, 2019 at 1:35 PM jb-wisemo <notifications@github.com> wrote:\n\n> To maximize the cover range for clients and simplify management of the\n> ESNI records, it is more useful to associate the ESNI records with the\n> server rather than the query domain name. This has the additional benefit\n> of allowing different client-facing servers to use different rotating\n> private DH keys.\n>\n> This eliminates the issues with CNAMEs, individual query domain holders\n> having to make changes, DNS namespace issues etc.\n>\n> For example a large hoster wishing to provide cover for some clients by\n> having their primary / CDN front ends offer ESNI for all requests can then\n> simply enable the code on their server then add the ESNI records. They can\n> even do this gradually over a large pool of servers, thus having some\n> servers with different (or no) ESNI support during each careful rollout of\n> ESNI software upgrades.\n>\n> In practice the following conventions would be used:\n>\n>    -\n>       1. Any ESNI server IP must have exactly one PTR record (typically\n>       pointing to the hoster domain, such as a typical systematic CDN node DNS\n>       name). Lets call this name ptrnam.dom\n>    -\n>       1. The ESNI records would be under _esni.ptrnam.dom\n>    -\n>       1. As with most PTR records ptrnam.dom is expected to have exactly\n>       one AAAA or A record pointing back at the same IP (if the starting IP is\n>       IPv6 only AAAA need to satisfy this, if IPv4 only A, the same ptrnam.dom\n>       can be used for one IPv4 and one IPv6 address if the ESNI records would be\n>       the same).\n>    -\n>       1. For address-less server types such as tor hidden services, the\n>       ESNI records would be published via whatever DNS or DNS-like mechanism is\n>       used for that transport, or queried by sending a DNS query for the record\n>       to the target, allowing the target to respond within that transport.\n>\n> Benefits:\n>\n>    -\n>\n>    B1. Large client-facing servers such as CDNs and shared IP hosters can\n>    deploy ESNI without having to negotiate DNS changes with all their\n>    customers (in fact with any of their customers).\n>    -\n>\n>    B2. Operators of large pools of client-facing servers such as CDNs can\n>    roll out ESNI support and ESNI implementation upgrades in a piecemeal and\n>    controlled manner similar to how other system updates are rolled out.\n>    Simply because each IP address will have its own ESNI records.\n>    -\n>\n>    B3. ESNI key rotation becomes much simpler as there is no need to\n>    synchronize it between different servers in a pool (except where a pure\n>    layer 1/2/3 load balancer shares a single IP among multiple\n>    physical/virtual servers, such as the layer 2 HALinux scheme).\n>    -\n>\n>    B4. ESNI private key protection can be much stronger when it is not\n>    shared among all the servers. The private key may be kept in protected\n>    hardware and/or in volatile RAM. The latter case would require clients to\n>    fall back to a different A or AAAA record until the DNS entries for now\n>    forgotten keys to have expired, but only in case of a server crash or\n>    similar event.\n>    -\n>\n>    B5. Client queries for ESNI records do not reveal the actual query\n>    domain that will be encrypted, only the IP address to which the ESNI\n>    extension will be sent.\n>    -\n>\n>    B6. The whole discussion about _esni prefix or no _esni prefix becomes\n>    a lot simpler when there is no need to put ESNI records in every end query\n>    domain, only domains of the client-facing servers, allowing to keep the\n>    unprefixed TXT name space clean for existing uses such as SPF.\n>\n> Downsides:\n>\n>    -\n>\n>    P1: Clients will have to postpone the _esni DNS query until after\n>    receiving the answer to the A or AAAA query, thus adding an extra DNS\n>    roundtrip before the first connection to a name. The usual DNS caching\n>    hierarchy should mitigate this. In particular for popular CDNs, a client\n>    will typically use the same handful of IPs for lots of unrelated traffic,\n>    thus getting the ESNI records in its local cache.\n>    -\n>\n>    P2: VM hosting/Physical hosting/connectivity providers not granting\n>    PTR name assignment control to IP address customers will cause the same\n>    problems as for other protocols (such as mail) and should thus be under the\n>    same or greater pressure to add that service. However since the greatest\n>    ESNI benefit is with IPs shared among many unrelated domains, and the\n>    operators of such IPs typically have full IP space ownership or the\n>    leverage to get PTR records where normal customers cannnot, the effect on\n>    ESNI deployment should be limited.\n>    -\n>\n>    P3: This may or may not make it easier to do spoofing attacks, as an\n>    MitM attacker can spoof DNS responses either for the A/AAAA records of a\n>    target query domain (pointing to servers entirely under the attackers\n>    control, including legitimate ESNI records for that server) OR spoof the\n>    ESNI records of a server address for which the attacker has obtained\n>    traffic intercept ability. However these can be secured with the same DNS\n>    countermeasures already applicable to those DNS domains.\n>    -\n>\n>    P4: query domains wishing to remain available in massively blocking\n>    markets (the kind that would not hesitate to block an entire CDN to stop\n>    access to a single web page) may have more difficulty opting out of ESNI so\n>    such blocking filters can recognize them as a permitted service.\n>\n> \u2014\n> You are receiving this because you are subscribed to this thread.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/tlswg/draft-ietf-tls-esni/issues/139>, or mute the\n> thread\n> <https://github.com/notifications/unsubscribe-auth/AAP5szSqBkYuhH39f6ZWOFhNfNZdY9dlks5vSXMCgaJpZM4bZlWX>\n> .\n>\n",
          "createdAt": "2019-03-01T18:59:29Z",
          "updatedAt": "2019-03-01T18:59:29Z"
        },
        {
          "author": "jb-wisemo",
          "authorAssociation": "NONE",
          "body": "The PTR record problem is a real issue, but less so for the servers best placed to be anonymity pools.\r\n\r\nThere are other mechanisms of cause.  The key part is making ESNI a server property rather than an origin property, bypassing most of the issues with configuring each of the non-controversial origin domains that are just used as cover traffic.  Hard part is finding a hello content that doesn't stick out by using any values specific to using a controversial domain.  Per origin ESNI would stick out as most origins would feel pressured to not actively join the pool, while having to do something difficult or even pricey to stay out of the pool would be less easy to encourage via generic mass pressure.\r\n\r\nFor the following approaches compare to a normal first TLS connection:\r\n  Round 1: DNS query for A and DNS query for AAAA (happy eyeballs)\r\n  Round 2: TCP SYN\r\n  Round 3: TLS Handshake round 1\r\n\r\nWith the PTR based approach the parallelizing would go like this for first contact (later contacts benefit from DNS caching):\r\n\r\nRound 1: DNS query for A and DNS query for AAAA (happy eyeballs)\r\nRound 2: TCP SYN, DNS query for PTR and DNS query for ESNI keys directly in i*.arpa\r\nRound 3: DNS query for ESNI keys at PTR name (perhaps cached at nearby resolver).\r\n    This round is done only if\r\n     A: no ESNI record (not even an empty one) returned in round 2 AND\r\n     B: PTR name returned and contains the substring \"esni.\"  For example \r\n          example x1234.cdn.esni.example.net or x1234esni.example.net would cause queries of\r\n          _esni.example x1234.cdn.esni.example.net or _esni.x1234esni.example.net\r\nRound 4: TLS Handshake round 1\r\n\r\nRule 3 B would require ESNI client facing servers without ability to add arbitrary reverse records to at least be able to choose a PTR name of the magic form.  Note that the magic form contains no underscore but will only cost an extra DNS lookup returning NXDOMAIN if a non-ESNI server has that name form by chance.  The rule may require further refinement to deal with common provider practices.\r\n\r\nOne technique requiring less round trips than a full HTTP REST API would be to use a clever sequence of TLS extensions, signalling suites etc. to do everything in the TLS layer at the cost of extra TCP round trips compared to the current draft.\r\n\r\nA hybrid approach could go like this (first contact):\r\n\r\n  Round 1: DNS query for A and DNS query for AAAA (happy eyeballs)\r\n  Round 2: TCP SYN, DNS query for _esni.$reverseip.arpa\r\n\r\nIf _esni returned with \"no\" record:\r\n  Round 3: TLS Hello with the signalling suite and normal SNI, server responds normally\r\n\r\nIf _esni returned with key:\r\n   Round 3: TLS hello with ESNI as per draft-02\r\n\r\nIf _esni returned with \"ask\" record:\r\n   Round 3: TCP hello with invalid right-size data in ESNI extension, server sends keys in encrypted ESNI response.\r\n   Round 4: Send new hello with real ESNI extension inside encrypted stream, server forwards to origin server, once encrypted by origin server, client-side server drops the outer encryption and forwards remaining packets unchanged.\r\n\r\nIf no _esni record returned from DNS, server is actually ESNI:\r\n  Round 3: TLS Hello with a signalling suite and no SNI or ESNI, server sends keys in encrypted ESNI response.  In parallel a new TCP SYN.\r\n  Round 4: Send new hello with real ESNI extension inside encrypted stream, server forwards to origin server, once encryption activated by origin server, client-side server drops the outer encryption and forwards remaining packets unchanged.\r\n (Second TCP connection may be used or closed)\r\n\r\nIf no _esni record returned from DNS, server is not ESNI and has a default certificate matching desired SNI:\r\n  Round 3: TLS Hello with a signalling suite and no SNI or ESNI, server server responds normally using its default certificate, client uses the connection.  In parallel a new TCP SYN.\r\n (Second TCP connection may be used or closed)\r\n\r\nIf no _esni record returned from DNS, server is not ESNI and has a default certificate not matching desired SNI:\r\n  Round 3: TLS Hello with a signalling suite and no SNI or ESNI, server server responds normally using its default certificate, client aborts.  In parallel a new TCP SYN.\r\n  Round 4: TLS Hello with the signalling suite and normal SNI, server responds normally.  In parallel the first session is closed.\r\n\r\nIf no _esni record returned from DNS, server is not ESNI and has no default certificate:\r\n  Round 3: TLS Hello with a signalling suite and no SNI or ESNI, server aborts.  In parallel a new TCP SYN.\r\n  Round 4: TLS Hello with the signalling suite and normal SNI, server responds normally  In parallel the first session is closed.\r\n\r\n(Inclusion of the signalling suite after concluding its a non-esni server is to detect downgrade attacks)\r\n\r\nIntent is that the 4 round cases will be less common than the 3 round cases.  All subsequent contacts to same server IP (up to a cache period) will be simply:\r\n  Round 1: TCP SYN\r\n  Round 2: TLS Hello according to cached type and keys (with or without session resumption), Server responds as expected.\r\n\r\nNeither approach requires special IP address certificates.",
          "createdAt": "2019-03-01T23:11:31Z",
          "updatedAt": "2019-03-01T23:11:31Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "> A hybrid approach could go like this (first contact):\r\n> \r\n> Round 1: DNS query for A and DNS query for AAAA (happy eyeballs)\r\n> Round 2: TCP SYN, DNS query for _esni.$reverseip.arpa\r\n> \r\n> If _esni returned with \"no\" record:\r\n> Round 3: TLS Hello with the signalling suite and normal SNI, server responds normally\r\n> \r\n> If _esni returned with key:\r\n> Round 3: TLS hello with ESNI as per draft-02\r\n\r\nI agree that this method does not introduce an additional round-trip for TCP. But it will for QUIC, and I do not think we'd want to have that overhead always for QUIC.",
          "createdAt": "2019-03-02T22:26:10Z",
          "updatedAt": "2019-03-02T22:26:10Z"
        },
        {
          "author": "jb-wisemo",
          "authorAssociation": "NONE",
          "body": "Since QUIC is a new undeployed protocol running on UDP instead of TCP, it can move its SNI-like operation into the encrypted part and (where applicable) use some kind of in-protocol session resumption to switch from client-facing server public keys to origin server public keys.  QUIC can also design its own mechanism for providing an encrypted non-repeating origin server indication in the early client to server packets.",
          "createdAt": "2019-03-07T17:26:51Z",
          "updatedAt": "2019-03-07T17:26:51Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "Given that QUIC is already using TLS 1.3, I'd prefer that it be able to share mechanisms.",
          "createdAt": "2019-03-07T17:34:19Z",
          "updatedAt": "2019-03-07T17:34:19Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "I think this is orthogonal to the contents of the draft. Namely, servers could maintain this sort of IP<->key association on their own without any client changes. Thus, closing as is. Please re-open if you think otherwise and have a suggested change for the document!",
          "createdAt": "2020-05-27T12:20:56Z",
          "updatedAt": "2020-05-27T12:20:56Z"
        }
      ]
    },
    {
      "number": 140,
      "id": "MDU6SXNzdWU0MTYyMzEwNzM=",
      "title": "Minor nit: This is static DH, not DHE",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/140",
      "state": "CLOSED",
      "author": "jb-wisemo",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Since the mechanism is essentially static DH key mode (with ephemeral client key), the text should not refer to it as DHE / ECDHE, as those acronyms indicate that both sides use a fresh ephemeral (EC)DH key for each connection, when the client-facing server is in fact using a fixed key (which may be rotated a lot more often than a key from a certificate).",
      "createdAt": "2019-03-01T18:43:17Z",
      "updatedAt": "2019-03-06T22:42:28Z",
      "closedAt": "2019-03-06T22:42:28Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "We'll likely address this by adopting notation and terminology from HPKE. See #145.",
          "createdAt": "2019-03-06T22:42:28Z",
          "updatedAt": "2019-03-06T22:42:28Z"
        }
      ]
    },
    {
      "number": 141,
      "id": "MDU6SXNzdWU0MTYyNDE0MTg=",
      "title": "Use the RFC1952/ISO3309/V.42 CRC32",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/141",
      "state": "CLOSED",
      "author": "jb-wisemo",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Since the 32 bit checksum in ESNI records does not server a cryptographic purpose, only error detection, and since the chosen suite for the exchange does not necessarily use the SHA-256 algorithm, it would be more efficient to use a dedicated fast error detecting checksum.  The CRC32 algorithm used in RFC1952 (gzip), ISO 3309 and ITU-T V.42 is optimized for this task, widely available in software and hardware, and likely to already be implemented in ESNI using systems for other purposes.\r\n\r\nThis would also remove the only part of the draft that requires a specific single cryptographic algorithm, thereby making the specification algorithm agile without introducing any new algorithm registries for IANA to maintain.",
      "createdAt": "2019-03-01T19:13:32Z",
      "updatedAt": "2019-06-17T18:21:16Z",
      "closedAt": "2019-06-17T18:21:16Z",
      "comments": [
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "I don't see how this makes it algorithm agile, it just requires baking in some other algorithm. Given that for the foreseeable future, every TLS 1.3 stack will have SHA-256, this would seem to make the implementation profile strictly worse. As for performance, the SHA-256 is trivial compared to the EC cost.",
          "createdAt": "2019-03-01T19:20:39Z",
          "updatedAt": "2019-03-01T19:20:39Z"
        },
        {
          "author": "jb-wisemo",
          "authorAssociation": "NONE",
          "body": "CRC32 makes no pretense to be a cryptographic algorithm, hence is not subject to the usual considerations of cryptographic algorithm agility.  A key lesson from baking SHA-1 into earlier protocols was that keeping it around for protocol compatibility made it more difficult to ensure it wasn't used in places where it would cause security issues.  Looking forward a few decades, there is little or no assurance that SHA-256 won't be in a similar situation.  In contrast the error detection abilities of CRC-32 (the only purpose it has in this place) has been proven mathematically, has survived for much much longer and is much faster to run before deciding if the cryptographic calculations are needed at all.  Like my other proposals, it's all about simplifying the protocol extension as much as possible.",
          "createdAt": "2019-03-01T20:09:38Z",
          "updatedAt": "2019-03-01T20:09:38Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "I am familiar with these arguments, but I don't agree that this is a meaningful simplification. SHA-256 does not need to be agile in this case.\r\n",
          "createdAt": "2019-03-01T20:10:56Z",
          "updatedAt": "2019-03-01T20:10:56Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I agree with @ekr here. Modern TLS implementations already have support for SHA-256 whereas CRC32 isn't always readily available.",
          "createdAt": "2019-03-01T23:56:35Z",
          "updatedAt": "2019-03-01T23:56:35Z"
        },
        {
          "author": "jb-wisemo",
          "authorAssociation": "NONE",
          "body": "You seem to misunderstand the issue.  The problematic scenario is this:\r\n\r\n1. Many years from now, SHA-256 is broken by new research (not faster computers), similar to what happened to MD5.\r\n\r\n2. Everyone works hard to remove SHA-256 from their cryptographic applications, or at least establish onerous review procedures to ensure any remaining SHA-256 invocation is not a security problem.\r\n\r\n3. ESNI using SHA-256 for a non-cryptographic purpose will then become a very real practical liability, as every implementation will need to make excuses and audit documents just to prove they are not really using SHA-256 for anything risky.\r\n\r\nIf in contrast, ESNI used something non-cryptographic, like CRC-32 or the TCP checksum algorithm, this step 3 of the problem wouldn't happen.  Of the commonly implemented short checksums, CRC-32 is the only one optimized for detecting accidental data corruption, while the other are optimized for tiny speed margins at the cost of less effective detection.\r\n\r\nAs for CRC-32 being available in ESNI implementations, this is likely to be present already because it is used in gzip HTTP compression, but standard CRC-32 may be available for many other reasons.  Anyway, CRC-32 is a trivially small algorithm that doesn't need CPU specific optimization for the data sizes in question.",
          "createdAt": "2019-03-07T16:39:17Z",
          "updatedAt": "2019-03-07T16:39:17Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "I understood the scenario and I've been through this before with SHA-1. I don't think that this is a particularly serious concern.",
          "createdAt": "2019-03-07T17:33:26Z",
          "updatedAt": "2019-03-07T17:33:26Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "SHA-256 is fine for this purpose. Closing for now.",
          "createdAt": "2019-06-17T18:21:16Z",
          "updatedAt": "2019-06-17T18:21:16Z"
        }
      ]
    },
    {
      "number": 142,
      "id": "MDU6SXNzdWU0MTYyNTM2OTg=",
      "title": "Eliminating record_digest",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/142",
      "state": "CLOSED",
      "author": "jb-wisemo",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "To simplify implementation, the record_digest can be eliminated as follows:\r\n\r\n1. In ESNIKeys, provide a server-assigned 32 bit id.  Servers are free to manage that id space as they see fit e.g. to optimize lookup in a history of rotating keys.  However the server MAY obscure any structure in the numbering in any convenient manner.  As a further optimization, move all fixed length fields before the variable length fields and order them such that natural alignment is achieved (as per IETF tradition).\r\n\r\n2. In ClientEncryptedSNI, insert the 32 bit id right after the Ciphersuite, making it part of the fixed-length part of the structure.  The record_digest field and its calculation is removed, thus reducing the size of the ESNI extension.\r\n\r\n3. In ESNIContents, just use the full record instead of hashing it separately.  This costs a few extra blocks of hash invocations (as the cache record_digest can no longer be cached for each hash algorithm), but simplifies the code.  Alternatively, record_digest can be kept for this non-transmitted field to preserve that caching opportunity.",
      "createdAt": "2019-03-01T19:49:21Z",
      "updatedAt": "2019-07-03T00:57:49Z",
      "closedAt": "2019-07-03T00:57:49Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm not in favor of this proposal. Computing record_digest is quite trivial as is, and using SHA256 gives us good assurance of its correctness. That is, we don't have to worry about servers possibly assigning incorrect IDs.",
          "createdAt": "2019-06-25T20:44:55Z",
          "updatedAt": "2019-06-25T23:47:03Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "We do have to worry about collisions, which could be even harder to get right.  I don't think that sending it in the record makes any sense, but as an identifier, a hash is fine.",
          "createdAt": "2019-06-25T23:46:00Z",
          "updatedAt": "2019-06-25T23:46:00Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "So my new insight here is that corruption of DNS records (if that does happen) will now be detected with `record_digest` and corrected through the use of the fallback mechanism.  So that makes `record_digest` important, but `checksum` useless.",
          "createdAt": "2019-07-03T00:53:45Z",
          "updatedAt": "2019-07-03T00:53:45Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Since a cryptographic proof of key possession is needed for downgrade protection, we can't remove record_digest in this way. Thus, I'm closing this issue as NTBF. ",
          "createdAt": "2019-07-03T00:57:49Z",
          "updatedAt": "2019-07-03T00:57:49Z"
        }
      ]
    },
    {
      "number": 143,
      "id": "MDU6SXNzdWU0MTYzMzAxMzI=",
      "title": "gh-pages is stale",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/143",
      "state": "CLOSED",
      "author": "MikeBishop",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "The Editor's Copy link leads to a version of the document from July 4, 2018, and there have been no commits to the gh-pages branch since then.  The document is obviously in active development, which suggests that CI is broken / not configured on this repo.",
      "createdAt": "2019-03-02T00:24:43Z",
      "updatedAt": "2019-07-03T01:33:53Z",
      "closedAt": "2019-07-03T01:33:53Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed -- sorry for the delay!",
          "createdAt": "2019-07-03T01:33:53Z",
          "updatedAt": "2019-07-03T01:33:53Z"
        }
      ]
    },
    {
      "number": 145,
      "id": "MDU6SXNzdWU0MTcwOTI1NzQ=",
      "title": "Adopt HPKE",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/145",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "needs WG discussion"
      ],
      "body": "See https://datatracker.ietf.org/doc/draft-barnes-cfrg-hpke/ for more info. ",
      "createdAt": "2019-03-05T03:03:26Z",
      "updatedAt": "2020-03-09T21:58:07Z",
      "closedAt": "2020-03-09T21:58:07Z",
      "comments": [
        {
          "author": "jb-wisemo",
          "authorAssociation": "NONE",
          "body": "Please don't.  The TLS series of RFCs and other related RFCs already contain established terminology for anything in the HPKE draft.   HPKE is basically two guys thinking they reinvented the wheel.",
          "createdAt": "2019-03-07T16:04:51Z",
          "updatedAt": "2019-03-07T16:04:51Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "Hmm... As one of the designers of the construction in this current ESNI draft, I would welcome a more carefully vetted construction that came with the CFRG's endorsement, and I generally assume that Karthik and Richard are at least as well equipped to design this as I am.",
          "createdAt": "2019-03-07T16:08:38Z",
          "updatedAt": "2019-03-07T16:09:21Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "I'd like to second what @ekr says. In a way, this document reinvents the wheel. We should defer such constructions to the CFRG.",
          "createdAt": "2019-03-07T17:56:57Z",
          "updatedAt": "2019-03-07T17:56:57Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "This is part of #207, as discussed in Singapore.",
          "createdAt": "2020-03-08T00:33:26Z",
          "updatedAt": "2020-03-08T00:33:26Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed by #207.",
          "createdAt": "2020-03-09T21:58:07Z",
          "updatedAt": "2020-03-09T21:58:07Z"
        }
      ]
    },
    {
      "number": 146,
      "id": "MDU6SXNzdWU0MTczMjEwODk=",
      "title": "User tracking via ESNI keys",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/146",
      "state": "CLOSED",
      "author": "kirsey",
      "authorAssociation": "NONE",
      "assignees": [
        "chris-wood"
      ],
      "labels": [
        "help wanted"
      ],
      "body": "If each client receives a unique ESNI key from a DNS provider, it is possible to link every usage of this key to the same client. It seems feasible that online services, as well as passive observers of the network traffic, can exploit such a practice for user tracking.\r\n\r\nTo enhance the privacy protections of this draft, we should describe these privacy risks in the draft. Furthermore, I recommend a clear restriction on the clients\u2019 caching durations of ESNI keys. For example, clients MUST NOT cache ESNI keys longer than 24 hours and as privacy protection, it is RECOMMENDED to cache ESNI keys only for 10 minutes.",
      "createdAt": "2019-03-05T14:18:34Z",
      "updatedAt": "2020-05-05T22:07:27Z",
      "closedAt": "2020-05-05T20:10:31Z",
      "comments": [
        {
          "author": "jb-wisemo",
          "authorAssociation": "NONE",
          "body": "To avoid downgrade attacks (by simply filtering out the key DNS response), clients should cache the fact that there is/was an ESNI key significantly longer, perhaps 14 days.  During these 14 days the server can authoritatively report that it no longer has a key, and it can change the key.  But the client would actively look for ESNI support before falling back to plain SNI for that server.\r\n\r\nBug #139 comment 3 contains a proposal that can implicitly handle the case \"client thinks server has ESNI, but doesn't know the current keys or if it has been turned off again server side\"",
          "createdAt": "2019-03-07T17:27:38Z",
          "updatedAt": "2019-03-07T17:27:38Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "I do not believe this will work. In multi-cdn scenarios, clients will sometimes just get an ESNIKeys record sometimes and no record other times and that's normal",
          "createdAt": "2019-03-07T17:32:23Z",
          "updatedAt": "2019-03-07T17:32:23Z"
        },
        {
          "author": "mcmanus",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think noting that this can track you within the same origin is a worthwhile thing to note - it gets added to a whole bucket of things with the same property (e.g. AAAA).\r\n\r\nAs its not really adding anything to that problem I'm not in favor of recommending particular cache ceilings which may or may not really address the issue anyhow..",
          "createdAt": "2019-03-07T17:54:10Z",
          "updatedAt": "2019-03-07T17:54:10Z"
        },
        {
          "author": "kirsey",
          "authorAssociation": "NONE",
          "body": "I observe, that TLS has a tradition in providing upper limits for caching durations. I think this is a good practice as it restricts the harm of an extreme configuration.\r\n\r\nFurthermore, I see added value in recommending a best practice configuration at least for a specific application type such as browsers because it leads to a description of the trade-offs at hand and facilitates the implementation. ",
          "createdAt": "2019-03-07T20:21:16Z",
          "updatedAt": "2019-03-07T20:21:16Z"
        },
        {
          "author": "kontaxis",
          "authorAssociation": "NONE",
          "body": "The document already sets the maximum TTL to the lifetime of the SNI key.\r\nIt also recommends that \"servers rotate keys frequently\" to reduce the harm from compromised keys.\r\n\r\nSo it seems that short-lived keys are good both for security and privacy.\r\n\r\nA recommended value would be useful.\r\nOtherwise \"frequently\" could be interpreted as months.",
          "createdAt": "2019-03-08T00:10:09Z",
          "updatedAt": "2019-03-08T00:10:21Z"
        }
      ]
    },
    {
      "number": 149,
      "id": "MDU6SXNzdWU0MTk2NTA2ODU=",
      "title": "Replay attack and timestamp",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/149",
      "state": "CLOSED",
      "author": "huitema",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "chris-wood"
      ],
      "labels": [
        "needs WG discussion"
      ],
      "body": "Attackers cannot successfully replay a ClientHello and ESNI extension and establish a connection with the server. However, they can replay a ClientHello and examine whether it triggers a positive response. This can be used to check whether a server is still present. This is a particular concern when using ESNI in local discovery mode, where merely eliciting a response would be enough to give away a server's presence.\r\n\r\nTo protect against such attacks, I consider adding two elements in the ESNI:\r\n\r\n1) A 64 bit timestamp, set to the date at which the client sent the message.\r\n2) The IPv6 address from which the client is sending the message.\r\n\r\nThe timestamp prevents repeat of a message over time. The IPv6 address prevents repeat of the message from a different location. I mention IPv6 here because of NAT, of course.\r\n\r\nWhat do you think? Should that be encoded as part of `ClientEncryptedSNI` or `ClientESNIInner`? Or should it just be encoded as a separate ClientHello extension?",
      "createdAt": "2019-03-11T19:45:33Z",
      "updatedAt": "2019-11-22T14:14:30Z",
      "closedAt": "2019-11-22T14:14:30Z",
      "comments": [
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I like the timestamp idea.  Even if it is only fuzzy.  The timestamp seems adequate, because the fact that a server remains active over short timescales is not that interesting - more so if the connection that is being replayed is still active.  \r\n\r\nFor the timestamp, fewer bits will be sufficient as long as the timestamp can express a longer duration than the maximum key validity.  32 bits is plenty, assuming second resolution.  16 might even suffice.",
          "createdAt": "2019-03-11T21:54:09Z",
          "updatedAt": "2019-03-11T21:54:09Z"
        },
        {
          "author": "Lekensteyn",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Frequent ESNIKeys rotation (and subsequent enforcement by the server) should mitigate this issue a bit.\r\n\r\nEncoding the time as-is would undo the effect of [removing the time from the client random field](https://mailarchive.ietf.org/arch/msg/tls/_clS-TIIlZUcid_2S4WPej9iMWk). Not sure if that is desirable.\r\n\r\nWhat is your attacker's model? Even with a truncated timestamp (e.g. in 1 minute intervals), there is still a time span where the confirmation attack could be executed. And if you are worried about an adversary who is trying to raid a data center and needs to track down a physical machine behind a load balancer, then having the IPv6 address binding would not help since the attacker could just spoof packets.",
          "createdAt": "2019-06-03T01:24:14Z",
          "updatedAt": "2019-06-03T01:24:14Z"
        },
        {
          "author": "ghedo",
          "authorAssociation": "CONTRIBUTOR",
          "body": "How long would the server's \"replay window\" be in terms of time? If it's less than say, a day, the server would start seeing a lot of spurious failures due to client clock skew.",
          "createdAt": "2019-06-03T12:47:51Z",
          "updatedAt": "2019-06-03T12:47:51Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Likewise the client will observe failures, and these will hit all connections for some small fraction of users, which is much worse than hitting some small fraction of connections for all users.\r\n\r\nIs the expectation that the client would fail the connection or retry without ESNI? The latter has a clear downgrade attack, while the former strongly discourages ESNI deployment. I would need to check with folks on what kinds of clock skews are observed, but I expect it would be much *much* higher than a day.\r\n\r\nNow that we have the robustness mechanism (if the server does not recognize ESNI, it just responds based on SNI) is that sufficient to resolve this? The server will respond with *something* either way, and the attacker can't tell which certificate it was.",
          "createdAt": "2019-06-03T15:50:19Z",
          "updatedAt": "2019-06-03T15:50:57Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@davidben has a point about fallback to SNI.  If use of the fallback SNI is indistinguishable from successful use of ESNI, then we're good: the observer gains nothing.  Is that a requirement we levy on servers though?\r\n",
          "createdAt": "2019-07-03T00:08:48Z",
          "updatedAt": "2019-07-03T00:08:48Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Hmm, is indistinguishability possible? In the fallback SNI case, the server's EE might carry one or more ESNIKeys, which inflates the size of this message well beyond the EE message size in the normal (non-fallback) case. If we want to make them indistinguishable, we'd probably need to recommend further requirements that the server's EE message(s) are the same in both cases, which is not great. ",
          "createdAt": "2019-07-03T00:29:36Z",
          "updatedAt": "2019-07-03T00:29:36Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Good point.  The extra bits will appear to be part of the certificate chain from the outside.  That means potentially padding everything.  If that is a problem, could the fallback be made to appear more like a response to a request?  That's structurally very different though, and perhaps not worth the pain.",
          "createdAt": "2019-07-03T00:32:04Z",
          "updatedAt": "2019-07-03T00:32:04Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@huitema how do you want to proceed here? ",
          "createdAt": "2019-11-04T20:47:28Z",
          "updatedAt": "2019-11-04T20:47:28Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I don't think the issue is mitigated yet. The problem is a \"discovery oracle\", and it is linked to a very specific ESNI usage: broadcast an ESNI on the local network to check whether someone will respond. In the normal case, the response is processed by the node doing the discovery. The issue is that an attacker can replay the message later and see whether the client is still there.\r\n\r\nThis is not a \"mainline\" ESNI issue, but just an issue arising from trying to use ESNI in a discovery scenario with Quic or DTLS. It is probably OK to not consider it for the current ESNI design, and to address it in the \"discovery scenario\" design.\r\n\r\nHence, close with no action.",
          "createdAt": "2019-11-22T14:14:29Z",
          "updatedAt": "2019-11-22T14:14:29Z"
        }
      ]
    },
    {
      "number": 150,
      "id": "MDU6SXNzdWU0MjYyNTQ1NzU=",
      "title": "record_digest should not cover address_set",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/150",
      "state": "CLOSED",
      "author": "davidben",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Filing this so we don't forget:\r\n\r\nCurrently the record digest covers the address_set extension. This means adding a new addresses to a deployment introduces new digests that need to be propagated to all servers to recognize. (Unless servers trial decrypt everything, but then record digests aren't doing anything.)\r\n\r\nPerhaps the A/AAAA + ESNI gluing should external to the ESNIKeys structure. The glue is probably assembled by DNS serving logic, while ESNIKeys is otherwise probably an opaque blob assembled by some key provisioning system.",
      "createdAt": "2019-03-28T01:38:56Z",
      "updatedAt": "2019-04-18T16:40:57Z",
      "closedAt": "2019-04-18T16:40:57Z",
      "comments": [
        {
          "author": "ghedo",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Made #151 to try to address this by excluding extensions from the digest. A DNS server that knows it will generate extensions can keep the rest of ESNIKeys as blob, and then simply append extensions to it when serving the record. Otherwise I wouldn't know where to put the AddressSet thingy.",
          "createdAt": "2019-04-09T22:10:55Z",
          "updatedAt": "2019-04-09T22:10:55Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "What do you think about splitting it in two layers?\r\n\r\nFirst you've got ESNIKeys as it existed prior to address_set. The record digest covers the whole thing as before. DNS believes it's just an opaque blob.\r\n\r\nThen you've got, say, some BUNDLE RRTYPE whose RDATA encodes a list of (RRTYPE, RDATA) tuples in whatever DNS-y syntax people want. The DNS server then just assembles a BUNDLE with A and AAAA formatted as before, plus an ESNI record with it. This avoids this odd situation we have here where ESNI wants to be the root of the tree, to the exclusion of everyone else who may wish to correlate data with A/AAAA.\r\n\r\nA nuisance here: we do want to avoid the client having to ask for all of A, AAAA, ESNI, *and* BUNDLE. It is more risk of performance problems and acting on any response to ESNI would reintroduce multi-CDN woes. We'd have to say ESNI can only be fetched via BUNDLE or so. (That perhaps suggests the \"keys\" in BUNDLE should be its own namespace? Other than A/AAAA, everything else is likely to never be fetched on its own.)",
          "createdAt": "2019-04-09T22:30:00Z",
          "updatedAt": "2019-04-09T22:30:00Z"
        },
        {
          "author": "ghedo",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I agree that the problem is really in DNS, and a complete solution needs to happen there. However I think it's orthogonal to ESNI, and should probably be discussed on its own (e.g. in dnsop).\r\n\r\nThere was some talk in Prague about doing that but AFAICT nothing happened yet, so I'd be interested in helping put a  BUNDLE proposal together if nothing else comes up, and see what the DNS people think.\r\n\r\nIn the meantime AddressSet is what we have, and it's probably easier to just make that work for the specific ESNI case in the short term, and then replace it with whatever BUNDLE solution comes out later on, so the two discussions can proceed in parallel.",
          "createdAt": "2019-04-11T12:55:31Z",
          "updatedAt": "2019-04-11T12:55:31Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Well, we don't have anything right now because address_set doesn't work. :-P We can change the syntax however we like, be it defining BUNDLE in the ESNI doc, or doing something quick and hacky like:\r\n\r\n```\r\nstruct {\r\n  ESNIKeys keys;\r\n  Address address_set<0..2^16-1>;\r\n} ESNIKeysWithAddresses;\r\n```",
          "createdAt": "2019-04-12T15:54:26Z",
          "updatedAt": "2019-04-12T15:55:34Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "My +1 goes to doing this hack, assuming that it helps somebody deploying ESNI.\r\n\r\nIf it turns out to be a bad idea, we can switch to a different mechanism by just bumping the version number in ESNIKeys.",
          "createdAt": "2019-04-12T16:11:13Z",
          "updatedAt": "2019-04-12T16:11:13Z"
        },
        {
          "author": "ghedo",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@davidben yeah, so that's similar to @chris-wood's proposal of just having an additional extensions field that doesn't go into record_digest. The additional extensions field would be somewhat more flexible and accomodate both address_set and the other multi-CDN proposal if it ever shows up. Do we care about this flexibility?\r\n\r\nI find both solutions kinda yucky, but I guess those are the options we have. I can update my PR (or create a new one) with whatever new hack.",
          "createdAt": "2019-04-12T17:38:14Z",
          "updatedAt": "2019-04-12T17:38:14Z"
        },
        {
          "author": "ghedo",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Actually, I don't know if the other multi-CDN proposal would have the same problem, so maybe the extensibility is not needed?",
          "createdAt": "2019-04-12T17:40:22Z",
          "updatedAt": "2019-04-12T17:40:22Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@ghedo @davidben @kazuho @ekr \r\n\r\nHow about:\r\n\r\n~~~\r\nstruct {\r\n  ESNIKeys keys;\r\n  Extensions dns_extensions<0..2^16-1>;\r\n} ESNIKeysWithExtensions;\r\n~~~\r\n\r\nWe can then put address_set in dns_extensions, and TLS stacks don't ever have to see them.",
          "createdAt": "2019-04-12T17:44:57Z",
          "updatedAt": "2019-04-12T17:44:57Z"
        },
        {
          "author": "ghedo",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yeah, was thinking something along those lines, I'll see if I can put it into text in the next few days if nobody beats me to it.",
          "createdAt": "2019-04-12T17:47:17Z",
          "updatedAt": "2019-04-12T17:47:17Z"
        }
      ]
    },
    {
      "number": 155,
      "id": "MDU6SXNzdWU0MzcyMjA2MTg=",
      "title": "Clarification on AAD for ClientEncryptedSNI.encrypted_sni",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/155",
      "state": "CLOSED",
      "author": "Lekensteyn",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "It was initially not clear to me what should be included in the AAD for encrypting ClientESNIInner into ClientEncryptedSNI.encrypted_sni. The spec currently says:\r\n\r\n> The ClientEncryptedSNI.encrypted_sni value is then computed using the usual TLS 1.3 AEAD:\r\n>\r\n>     encrypted_sni = AEAD-Encrypt(key, iv, ClientHello.KeyShareClientHello, ClientESNIInner)\r\n>\r\n> Where ClientHello.KeyShareClientHello is the body of the extension but not including the extension header.\r\n\r\nClientHello.KeyShareClientHello is not defined in this document. At first I thought it would cover ClientEncryptedSNI.key_share, but that seemed odd.\r\n\r\nLater I found that it refers to the Key Share extension defined in [RFC 8446, Section 4.2.8. Key Share](https://tools.ietf.org/html/rfc8446#section-4.2.8). Perhaps this reference could be added?\r\n\r\nOn a related note, `HKDF-Extract(0, Z)` should probably become `HKDF-Extract(\"\", Z)` or be explicit about the salt as is done in https://tools.ietf.org/html/rfc8446#section-7.1 (or https://tools.ietf.org/html/rfc5869#section-2.2).",
      "createdAt": "2019-04-25T14:08:57Z",
      "updatedAt": "2019-06-02T19:57:43Z",
      "closedAt": "2019-06-02T19:57:43Z",
      "comments": [
        {
          "author": "sftcd",
          "authorAssociation": "NONE",
          "body": "FWIW, I also had a little trouble with this. My initial interpretation was to use the h/s key share that ends up being used as the AAD, which worked fine for my client (vs cloudflare) and for my server (vs. NSS' tstclnt). In each of those cases though only one key share was sent by the client. FF nightly however sends two key shares in the h/s so I had to change my code to do the right thing. Could be worth a note in the internet-draft e.g. saying to use (the encoding of) all key shares from the h/s and that some clients do send more than one.  ",
          "createdAt": "2019-06-02T15:15:57Z",
          "updatedAt": "2019-06-02T15:16:33Z"
        }
      ]
    },
    {
      "number": 156,
      "id": "MDU6SXNzdWU0NDQwNzA0ODM=",
      "title": "Require OCSP stapling for ESNI",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/156",
      "state": "CLOSED",
      "author": "J0WI",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Since OCSP is [leaking](https://bugzilla.mozilla.org/show_bug.cgi?id=1535235#c3) the server name, ESNI should probably enforce OCSP stapling (similar to [RFC 7633](https://tools.ietf.org/html/rfc7633)) or any other way of encrypted OCSP checks.\r\nIgnoring OCSP status checks entirely makes it hard to revoke a certificate, even if it's only valid for a few months.\r\n\r\n",
      "createdAt": "2019-05-14T18:51:20Z",
      "updatedAt": "2019-07-04T01:12:54Z",
      "closedAt": "2019-07-04T01:12:54Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@J0WI what behavior do you expect here? Would clients fail hard if server don't send stapled responses? It's good to view ESNI as part of the leaky boat problem. It plugs one hole, but not all of them. Implementations probably should do something about cleartext OCSP if they want all holes plugged. ",
          "createdAt": "2019-07-03T04:04:57Z",
          "updatedAt": "2019-07-03T04:04:57Z"
        }
      ]
    },
    {
      "number": 160,
      "id": "MDU6SXNzdWU0NTUzNjc3NDQ=",
      "title": "Including Presentation language",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/160",
      "state": "CLOSED",
      "author": "mrsylerpowers",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "chris-wood"
      ],
      "labels": [],
      "body": "I believe it will be helpful to understanding this document to either add \"Presentation Language\" to this document or link to Presentation Language elsewhere. The TLS/1.3 document has something similar in [RFC8446 Section 3](https://tools.ietf.org/html/rfc8446#section-3)",
      "createdAt": "2019-06-12T18:44:41Z",
      "updatedAt": "2019-07-03T01:09:00Z",
      "closedAt": "2019-07-03T01:09:00Z",
      "comments": []
    },
    {
      "number": 171,
      "id": "MDU6SXNzdWU0NjY2MjMzODU=",
      "title": "Formal analysis",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/171",
      "state": "OPEN",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "We need some form of analysis before we ship this. Filing an issue to track that task.",
      "createdAt": "2019-07-11T02:25:38Z",
      "updatedAt": "2019-07-16T16:55:06Z",
      "closedAt": null,
      "comments": [
        {
          "author": "mrsylerpowers",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@chris-wood Do you think that this draft is about ready for ship?\r\n",
          "createdAt": "2019-07-16T15:20:49Z",
          "updatedAt": "2019-07-16T15:20:49Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "No, not yet.",
          "createdAt": "2019-07-16T16:55:06Z",
          "updatedAt": "2019-07-16T16:55:06Z"
        }
      ]
    },
    {
      "number": 173,
      "id": "MDU6SXNzdWU0NzEyMTc5NjM=",
      "title": "Lingering references to `sni` instead of `dns_name`",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/173",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "From Stephen Farrell on the TLS WG list:\r\n\r\nJust spotted that:\r\n\r\n   opaque zeros[ESNIKeys.padded_length - length(sni)];\r\n\r\nshould I guess now be:\r\n\r\n   opaque zeros[ESNIKeys.padded_length - length(dns_name)];\r\n\r\nAnd maybe s/PaddedServerNameList/PaddedDNSName/ would also make sense.",
      "createdAt": "2019-07-22T17:39:28Z",
      "updatedAt": "2019-08-15T22:20:15Z",
      "closedAt": "2019-08-15T22:20:15Z",
      "comments": [
        {
          "author": "ghedo",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Think this is fixed now?",
          "createdAt": "2019-08-15T22:19:26Z",
          "updatedAt": "2019-08-15T22:19:26Z"
        }
      ]
    },
    {
      "number": 177,
      "id": "MDU6SXNzdWU0NzI0MzU0Nzk=",
      "title": "GREASE ESNI extensions are easily distinguished from real ones",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/177",
      "state": "CLOSED",
      "author": "davidben",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "davidben",
        "chris-wood"
      ],
      "labels": [],
      "body": "The draft has provisions for GREASE ESNI extensions, per \"Do not stick out\". However, this is not very effective if an attacker can distinguish a GREASE ESNI extension from a real one.\r\n\r\n#154 tried to address this, but it doesn't work if the (public) ESNI record is known. There's also a simpler attack: replay the ClientHello with one byte of ciphertext corrupted. ESNI currently distinguishes key mismatch from decrypt failure, with the latter resulting in an alert. We can fix that by saying decrypt failure should behave like key mismatch. This still leaves record_digest.\r\n\r\nThe natural fix is to drop record_digest in favor of trial decryption. The cost is the server must perform a DH operation per known key. The number of keys the server needs depends on its DNS TTLs and key rotation. (I think it's 1 + ceil(dns_ttl / time_between_rotation), plus some leeway[*].)\r\n\r\nInstead, we can keep a key name, but make the space dense. Suppose we replace it with a B-bit \"key phase\". The server picks a random starting key phase. Then, each time it rotates the keys, it increments the phase, with wraparound. The server then gets 2<sup>B</sup> keys for free. If it needs more, it still needs trial decryption but gains a 2<sup>B</sup> multiplicative factor in the cost. On the flip side, an individual GREASE extension with a random key phase has a 1/2<sup>B</sup> chance of colliding with a particular ESNI key.\r\n\r\nI'm not sure we actually need that many live keys, so B = 2 is probably plenty. Or even B = 1 if we say you should just rotate slower than your DNS TTL.\r\n\r\n[*] Note the robustness mechanism means that server doesn't need to cover _all_ clients with stale keys. The retry is expensive, so the server still needs to cover _almost all_ of them, but it can cut off the long tail.",
      "createdAt": "2019-07-24T18:37:10Z",
      "updatedAt": "2020-05-27T12:18:22Z",
      "closedAt": "2020-05-27T12:18:21Z",
      "comments": [
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Mostly a note to myself for the actual PR: the draft should also discuss padding of the EncryptedExtensions message.",
          "createdAt": "2019-07-29T23:53:40Z",
          "updatedAt": "2019-07-29T23:53:40Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "I think we really need to go back to first principles here and ask what it is we are trying to accomplish.  First, it's public information whether a given server supports ECHO, so if an attacker wants to know that, it can mostly just ask [there is some complexity around getting candidate names, but note that you can always get the public name from the SNI value and any real attacker will see a lot of non-ECHO traffic and so will know a bunch of SNI values].\r\n\r\nWhat's not public information is whether a given *connection* uses ECHO. The attacker might not know this either because:\r\n\r\n1. It knows that the server is ECHO-supporting.\r\n1. It has a limited view of just the connection and isn't willing to do do the work of trying to determine if the server is ECHO-supporting.\r\n\r\nIn case (1) I would also expect that the attacker is not going to go to the trouble of doing probe connections, as determining if the server is ECHO supporting is easier. This leaves us with the case where the attacker knows that the server is ECHO supporting and that the client *knows* about ECHO (otherwise it couldn't generate GREASE) but doesn't know if the client is actually doing ECHO. Do we expect there to be a lot of clients like this? Why not just do ECHO?\r\n\r\n\r\n",
          "createdAt": "2020-04-24T14:46:10Z",
          "updatedAt": "2020-04-24T14:46:10Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "As per today's call, we're going to revisit the GREASE threat model and then reconvene if further work is needed.",
          "createdAt": "2020-04-27T22:02:57Z",
          "updatedAt": "2020-04-27T22:02:57Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm moving to closes this issue as resolved by #235. If we need to do something against connection blocking adversaries, perhaps we should look into MASQUE for that.",
          "createdAt": "2020-05-20T16:00:52Z",
          "updatedAt": "2020-05-20T16:00:52Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing for now. @davidben, please re-open if you still think we should address this!",
          "createdAt": "2020-05-27T12:18:21Z",
          "updatedAt": "2020-05-27T12:18:21Z"
        }
      ]
    },
    {
      "number": 178,
      "id": "MDU6SXNzdWU0NzI4OTMzMzY=",
      "title": "Cryptographic configuration consistency",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/178",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "chris-wood"
      ],
      "labels": [],
      "body": "There is an unstated constraint on deployments.  All servers in the same anonymity set need to have the same cryptographic configuration.\r\n\r\nThis means that they choose the same key exchange groups/cipher/etc.. when presented with the same ClientHello.  Concretely, servers need to produce the same profile for the ServerHello, because the ServerHello is not encrypted and the form of a ServerHello could be used to split the anonymity set if different servers make different choices.",
      "createdAt": "2019-07-25T14:18:36Z",
      "updatedAt": "2019-11-04T21:41:08Z",
      "closedAt": "2019-11-04T21:41:08Z",
      "comments": [
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Discussion in the room in Montreal suggested that this would not be a requirement, but more of the form of an observation and suggestion.  That is, the document would note that if cryptographic configuration is not consistent, the anonymity set fractures into as many sets as there are configurations.  Then it will recommend (but not require) that uniformity is desirable.",
          "createdAt": "2019-07-25T14:43:15Z",
          "updatedAt": "2019-07-25T14:43:15Z"
        }
      ]
    },
    {
      "number": 179,
      "id": "MDU6SXNzdWU0NzI5NDc0ODY=",
      "title": "Decouple ESNIKeys and the envelope DNS record",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/179",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This will let us adopt another delivery mechanism (HTTPSVC?) if needed later on.",
      "createdAt": "2019-07-25T16:00:18Z",
      "updatedAt": "2019-11-02T01:02:04Z",
      "closedAt": "2019-11-02T01:02:03Z",
      "comments": [
        {
          "author": "ghedo",
          "authorAssociation": "CONTRIBUTOR",
          "body": "We already have `ESNIKeys` and `ESNIRecord` as different structures, wouldn't a different delivery mechanism be able to simply wrap `ESNIKeys` in its own transport, without the DNS record? I guess this point could be clarified though.",
          "createdAt": "2019-08-15T22:18:23Z",
          "updatedAt": "2019-08-15T22:18:23Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "This is mostly an editorial change to make it easy to remove `ESNIRecord`, if needed, without changing any other text.",
          "createdAt": "2019-08-15T22:19:19Z",
          "updatedAt": "2019-08-15T22:19:19Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed by #187.",
          "createdAt": "2019-11-02T01:02:03Z",
          "updatedAt": "2019-11-02T01:02:03Z"
        }
      ]
    },
    {
      "number": 180,
      "id": "MDU6SXNzdWU0NzQxNzYyNzU=",
      "title": "Use SRV for fronting server selection",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/180",
      "state": "CLOSED",
      "author": "huitema",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "I think that the current ESNI record is maybe a little too\r\ncomplicated. The ESNI key is really a property of the public server, yet\r\nthe ESNI record is defined as a property of the hidden server. If the\r\npublic server rolls a new key, all the ESNI records of all the hidden\r\nservers that mentioned the old key need to be updated. I think it would\r\nbe simpler to have the ESNI record as a property of the public server,\r\nand to just have a pointer to the public server in the context of the\r\nhidden server. May an SRV record. The chain would be something like:\r\n\r\n1) Look up whether the SRV record for _esni._tcp.hidden.example.com\r\n\r\n2) If there are such records, select the appropriate public server, say\r\npublic.example.net\r\n\r\n3) Look up ESNI, A, AAAA for public.example.net\r\n\r\nIn that architecture, there is no need to encode the public server name\r\nin the ESNI record. I think there will be several advantages. The ESNI\r\nrecord's TTL can be set to the lifetime of the key. The SRV record's TTL\r\ncan be set to the expected lifetime of the relation between 'hidden\" and\r\n\"public\". If the SRV lifetime is long enough, the value can be\r\nefficiently cached by the client. If multiple clients share the same\r\nhidden server, the ESNI record is fetched only once, and can be cached.\r\nAt connection time, the client would only need to query the A/AAAA\r\nrecords of the public server, i.e. exactly the same DNS transaction as\r\nan access to the public server.",
      "createdAt": "2019-07-29T17:46:43Z",
      "updatedAt": "2019-11-02T01:02:00Z",
      "closedAt": "2019-11-02T01:02:00Z",
      "comments": [
        {
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Issue #139 proposes something similar, using PTR records. I think the semantic of SRV records is closer to what we need.",
          "createdAt": "2019-07-29T17:49:49Z",
          "updatedAt": "2019-07-29T17:49:49Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The practical consequence would be to remove the \"public name\" component from the ESNI record.",
          "createdAt": "2019-07-29T17:51:15Z",
          "updatedAt": "2019-07-29T17:51:15Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "IIRC, the principle that we have so far followed is that ESNI should not introduce additional latency (i.e. roundtrip). TLS WG has spent great effort in reducing the number of roundtrips spent during the handshake. It would be very unfortunate to add latency with ESNI.\r\n\r\nAlso, I am not sure how much the issue is a practical concern, because I'd assume that most if not all of the DNS records of the hidden hostnames would be a CNAME to the public name. The ESNI record would be associated to that public name.\r\n\r\nTo rephrase, the ESNI record would be associated to the public name in the current scheme.",
          "createdAt": "2019-07-30T07:21:18Z",
          "updatedAt": "2019-07-30T07:21:18Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I agree that if the typical implementation is to have the hidden server name point to the public server with a CNAME, then the current record format is just fine. We may want to document this hidden CNAME assumption in the document.\r\n\r\nOn the other hand, I am still not convinced that CNAME is the proper tool. We definitely want to use DNSSEC to sign the record pointing from hidden to public. Otherwise, it becomes very simple to inject a false record pointing to a compromised public server, and then track clients. At a minimum, if we expect the hidden servers to use CNAME, we should explain how to use DNSSEC to secure that.\r\n\r\nApart from DNSSEC, the other feature that we want is the support for multiple public servers, in case one of them is blocked. I don't think that CNAME can do that. In practice, the simplest way will be to have multiple ESNI records listed directly in the context of the hidden server. That works, and doing DNSSEC is straightforward. But it implies replication of the public server ESNI record in many places, which brings in the issues of managing replication.",
          "createdAt": "2019-07-30T16:20:25Z",
          "updatedAt": "2019-07-30T16:20:25Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "@huitema I think that elaborating on the expected practice is a good idea.\r\n\r\n> Apart from DNSSEC, the other feature that we want is the support for multiple public servers, in case one of them is blocked.\r\n\r\nWhile I appreciate the possibility, I am not sure if it is a good idea to endorse ESNI to be used as a tool to circumvent blocking. Because doing so would lead to ESNI being blocked. Rather, my preference goes to promoting ESNI as a tool for protecting privacy.",
          "createdAt": "2019-07-31T07:22:24Z",
          "updatedAt": "2019-07-31T07:22:24Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed by #187.",
          "createdAt": "2019-11-02T01:02:00Z",
          "updatedAt": "2019-11-02T01:02:00Z"
        }
      ]
    },
    {
      "number": 182,
      "id": "MDU6SXNzdWU0OTg0MzQ4OTM=",
      "title": "Consider disabling server tickets if tickets are not uniform across the ESNI anonymity set",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/182",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "chris-wood"
      ],
      "labels": [],
      "body": "Tickets and ESNI interact in a weird way, i.e., they may leak size or contain the SNI, leading to potential issues. One might want to disable them if also offering ESNI as a service.",
      "createdAt": "2019-09-25T17:54:45Z",
      "updatedAt": "2020-04-27T22:01:08Z",
      "closedAt": "2020-04-27T22:01:08Z",
      "comments": [
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Just to confirm, by uniform do you just mean that they're indistinguishable visually or that the server will cross-resume across names in the anonymity set?",
          "createdAt": "2019-09-26T22:47:12Z",
          "updatedAt": "2019-09-26T22:47:12Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Both!",
          "createdAt": "2019-09-26T22:48:16Z",
          "updatedAt": "2019-09-26T22:48:16Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'm not sure we want the latter. For instance, if they have different client certificate requirements, the server could be in a pickle resuming across them allows you to bypass those requirements. It also generally muddles the identity that the server is authenticating as. In the split mode case, the different backends presumably don't even share ticket keys.\r\n\r\nIs the motivation is various attacks around seeing if the server accepts a ticket in various contexts? That would certainly solve this, but I wonder if we can address them by playing games with binders instead? Though it's a little fussy since binder failures are currently fatal, whereas failing to decrypt a ticket just falls back to full handshake...",
          "createdAt": "2019-09-26T22:55:31Z",
          "updatedAt": "2019-09-26T22:55:46Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> For instance, if they have different client certificate requirements, the server could be in a pickle resuming across them allows you to bypass those requirements.\r\n\r\nCorrect! The issue as written isn't crisp :-) What we require, among possibly other things that I didn't write down, is that the information and authentication context for a ticket is indistinguishable across all tickets possible for a given set of servers. So in the example you describe, if a client gets a ticket without authenticating from one server and then resumes it to a different server that normally would require authentication, then the ticket must record whether authentication took place. And storing that bit should not reveal information about the name.\r\n\r\n(I was just aiming to make a note of this so I didn't forget it later. There's probably other things to consider, too. I don't claim this is complete as written!)\r\n\r\n> Is the motivation is various attacks around seeing if the server accepts a ticket in various contexts? \r\n\r\nYep! This is a \"flip table\" solution to the problem that some server operators may wish to do. ",
          "createdAt": "2019-09-26T23:00:16Z",
          "updatedAt": "2019-09-26T23:00:16Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@chris-wood Is this about privacy or about authentication? It seems that we have two issues:\r\n\r\n1) Observers perform some trials and find out that \"hidden1.example.com\" uses 33 bytes tickets while \"hidden2.example.com\" uses 42 bytes. They can then look at TLS resume attempts and tell which server is contacted. \r\n\r\n2) Attackers find out that some servers send a ticket after authentication and other before that, and then use clever repeat attacks to benefit from the confusion.\r\n\r\nI would argue that (1) is part of the wider issue of identifying servers without breaking the encryption. We may want to address it, but it seems very complicated.\r\n\r\nAs for (2), is this an ESNI issue or a TLS issue?",
          "createdAt": "2019-09-27T02:20:38Z",
          "updatedAt": "2019-09-27T02:20:38Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@huitema it's about privacy. As you observe, (1) is clearly an issue for ESNI, but it's more an attack on tickets than it is on ESNI. It seems that if ESNI is to provide desired guarantees, then we ought to address it. (2) is a TLS issue and not related to ESNI. (Servers shouldn't be minting tickets without also including the authentication context. I'd rather not go down that rabbit hole here. :-))",
          "createdAt": "2019-09-27T02:37:41Z",
          "updatedAt": "2019-09-27T02:37:41Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "body": "(1) is a matter of degree. It is also possible to fingerprint servers by looking the sizes of pages, or the sizes of TLS blocks, or the profile of a typical session. There was a talk about that in one of the ANRW presentations.\r\n\r\nLet's assume that we want to standardize ticket sizes. Suppose that a fronting server says \"to hide behind me you should pad your tickets to exactly 64 bytes\". We are then going into two kinds of arguments. \r\n\r\nFirst, many sites owner will ask you \"how exactly do I do that with Apache2?\" So if you want uniformity, you need some deployment guidelines, and you want support in the main server distributions. Or the TLS stacks. Or the QUIC stacks. But then we are getting a bit beyond the scope of ESNI.\r\n\r\nSecond, there will be the occasional site that has the requirement for 67 bytes. Or 129. What do you do? Increase the size for everybody else? Suggest plausible sizes? Randomize?",
          "createdAt": "2019-09-27T05:54:53Z",
          "updatedAt": "2019-09-27T05:54:53Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> It is also possible to fingerprint servers by looking the sizes of pages, or the sizes of TLS blocks, or the profile of a typical session. There was a talk about that in one of the ANRW presentations.\r\n\r\nIndeed! However, the attack in mind is arguably much simpler than fingerprinting, so I'm not sure we should lump them in the same bucket. \r\n\r\nOn the question of sizes, note that we already recommend padding to hide certificate sizes. Making a similar suggestion for tickets therefore seems reasonable to me. ",
          "createdAt": "2019-09-27T14:50:24Z",
          "updatedAt": "2019-09-27T14:50:24Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "Yeah, I now realize that the advice on certificate size seems a bit odd, as the size is not something that is exposed on the wire. To be accurate, I think what we care is the number of TLS records and their sizes transmitted during the handshake. Those are the things that are exposed on the wire.\r\n\r\nSimilarly, the contents of Client Hello and Server Hello are also exposed.\r\n\r\nConsidering that, it might be a good idea to recommend as a general rule to not expose _plaintext_ information that helps observers reduce the anonymity set, using the tickets and the size of the certificate as the examples.",
          "createdAt": "2019-09-28T12:51:14Z",
          "updatedAt": "2019-09-28T12:51:14Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> Considering that, it might be a good idea to recommend as a general rule to not expose plaintext information that helps observers reduce the anonymity set, using the tickets and the size of the certificate as the examples.\r\n\r\nYes, that would certainly be an improvement! Would you mind preparing a PR to that effect? I can do it if you don't have the time.",
          "createdAt": "2019-09-28T14:36:21Z",
          "updatedAt": "2019-09-28T14:36:21Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "@chris-wood I'd appreciate it if you could, as I'm not sure when I can do it.",
          "createdAt": "2019-09-30T07:48:59Z",
          "updatedAt": "2019-09-30T07:48:59Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing as this is effectively included in #209!",
          "createdAt": "2020-04-27T22:01:08Z",
          "updatedAt": "2020-04-27T22:01:08Z"
        }
      ]
    },
    {
      "number": 183,
      "id": "MDU6SXNzdWU1MDA5Nzc1Njc=",
      "title": "Clarification on repeated extensions in ESNIRecord and ESNIKeys",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/183",
      "state": "CLOSED",
      "author": "dmcardle",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "[RFC8446 section 4.2](https://tools.ietf.org/html/rfc8446#section-4.2) states:\r\n\r\n> There MUST NOT be more than one extension of the\r\n   same type in a given extension block.\r\n\r\nThe ESNI draft should probably explicitly restate this for both `ESNIRecord.dns_extensions` and `ESNIKeys.extensions`.  I'd be happy to make a PR if need be. Thanks!",
      "createdAt": "2019-10-01T15:34:05Z",
      "updatedAt": "2020-03-08T00:32:55Z",
      "closedAt": "2020-03-08T00:32:54Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@dmcardle if you could propose text that takes the new ESNIConfig and HTTPSSVC change into account, that'd be great!",
          "createdAt": "2019-11-04T20:51:08Z",
          "updatedAt": "2019-11-04T20:51:08Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed by #195.",
          "createdAt": "2020-03-08T00:32:54Z",
          "updatedAt": "2020-03-08T00:32:54Z"
        }
      ]
    },
    {
      "number": 188,
      "id": "MDU6SXNzdWU1MTI2NzUzMzQ=",
      "title": "\"HKDF-Extract(0, Z)\"",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/188",
      "state": "CLOSED",
      "author": "sayrer",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "A second point in issue #155 wasn't addressed very clearly by #158. \r\n\r\n\"...HKDF-Extract(0, Z) should probably become HKDF-Extract(\"\", Z) or be explicit about the salt as is done in https://tools.ietf.org/html/rfc8446#section-7.1 (or https://tools.ietf.org/html/rfc5869#section-2.2).\"\r\n\r\nThe current draft does clarify this in the text below, but I initially missed that. The reader has to know that the first argument to HKDF-Extract is named \"salt\" to put it together.\r\n\r\nI did end up getting it right, figuring this was intended to mean a buffer of zeros. I think it would be clearer to say:\r\n\r\n```\r\nsalt = uint8[Hash.length]\r\nZx = HKDF-Extract(salt, Z)\r\n```",
      "createdAt": "2019-10-25T19:11:24Z",
      "updatedAt": "2019-11-19T09:26:34Z",
      "closedAt": "2019-11-19T09:26:34Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@sayrer a PR to clarify this point is most welcome!",
          "createdAt": "2019-11-05T02:25:58Z",
          "updatedAt": "2019-11-05T02:25:58Z"
        },
        {
          "author": "sayrer",
          "authorAssociation": "NONE",
          "body": "It would be ok to take this suggestion into consideration under the terms of the IETF's \"Note Well\" blue sheet terms, and incorporate it into a PR by the editors.",
          "createdAt": "2019-11-15T08:05:00Z",
          "updatedAt": "2019-11-15T08:05:00Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@sayrer I agree! Could you please provide that PR?",
          "createdAt": "2019-11-17T03:12:45Z",
          "updatedAt": "2019-11-17T03:12:45Z"
        },
        {
          "author": "sayrer",
          "authorAssociation": "NONE",
          "body": "Oh, I was asking you folks to do it. If there's a reason I need to do it, I'd be happy to.",
          "createdAt": "2019-11-17T21:05:14Z",
          "updatedAt": "2019-11-17T21:05:14Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "I don't think this is necessary, so while I'm willing to look at a PR, I'm not going to make one at this time.",
          "createdAt": "2019-11-17T22:23:24Z",
          "updatedAt": "2019-11-17T22:23:24Z"
        }
      ]
    },
    {
      "number": 189,
      "id": "MDU6SXNzdWU1MTI3NzIzMTE=",
      "title": "AEAD-Encrypt definition",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/189",
      "state": "CLOSED",
      "author": "sayrer",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "```\r\nThe ClientEncryptedSNI.encrypted_sni value is then computed using the\r\n   usual TLS 1.3 AEAD:\r\n\r\n    encrypted_sni = AEAD-Encrypt(key, iv, KeyShareClientHello, ClientESNIInner)\r\n```\r\n\r\nHowever, the TLS 1.3 definition is:\r\n\r\n```\r\nAEADEncrypted =\r\n          AEAD-Encrypt(write_key, nonce, additional_data, plaintext)\r\n```\r\n\r\nIn the ESNI text, it's not clear how `iv` maps to TLS 1.3's `per-record nonce` routine.",
      "createdAt": "2019-10-26T01:10:02Z",
      "updatedAt": "2019-11-04T21:41:29Z",
      "closedAt": "2019-11-04T21:41:29Z",
      "comments": [
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm not following what the problem is here: AEAD-Encrypt is a function that takes four arguments, the second of which is a nonce. In TLS 1.3 record encryption, this nonce value is set as described in S 5.3. In ESNI, it is derived via HKDF in the fashion described in S 5.1.1..",
          "createdAt": "2019-10-26T01:33:48Z",
          "updatedAt": "2019-10-26T01:33:48Z"
        },
        {
          "author": "sayrer",
          "authorAssociation": "NONE",
          "body": "I don't doubt that there is a right answer. It wasn't clear to me whether I should mix in a sequence number to `iv` (maybe zero?).\r\n\r\nOtherwise, it made sense. Although it might be quite a bit clearer to define each argument in terms of the TLS 1.3 definition.\r\n\r\n```\r\n...\r\nnonce = iv\r\nadditional_data = KeyShareClientHello\r\n...\r\n\r\nAEADEncrypted =\r\n          AEAD-Encrypt(write_key, nonce, additional_data, plaintext)\r\n```",
          "createdAt": "2019-10-26T01:40:04Z",
          "updatedAt": "2019-10-26T01:43:35Z"
        },
        {
          "author": "sayrer",
          "authorAssociation": "NONE",
          "body": "In other words, the second argument to `AEAD-Encrypt` in TLS 1.3 is \"derived from the sequence number and the client_write_iv or server_write_iv\".\r\n\r\nAs I read, it wasn't clear to me whether I should do nothing to the existing `iv` value, or mix in zero or something. This might be really obvious in some implementations, but it wasn't in the one I'm working on.",
          "createdAt": "2019-10-26T01:51:22Z",
          "updatedAt": "2019-10-26T01:52:29Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "You don't do either. The function takes a nonce argument. In TLS 1.3, that argument is computed one way, and in ESNI it is computed another way. These are positional functions and the names in scope at the call site are irrelevant.\r\n\r\nI think your proposed change would confuse rather than illuminating.\r\n\r\nI agree with you that adding test vectors would be useful, and if you want to supply some -- though I suggest you wait until the next version -- in a PR, that would be great.",
          "createdAt": "2019-10-26T02:22:40Z",
          "updatedAt": "2019-10-26T02:22:40Z"
        },
        {
          "author": "sayrer",
          "authorAssociation": "NONE",
          "body": "OK, maybe my proposed solution is not the best, but I don't think the status quo is great. I get the point of \"These are positional functions and the names in scope at the call site are irrelevant\", but that's actually not quite true in TLS, afaik. The names tend to imply input/output treatment.\r\n\r\nFor example, things called \"*_iv\" are inputs to `nonce` in TLS 1.3. In some implementations, the input \"Initialization Vector (IV)\" [RFC4106] might be a different static type from the `nonce` in the TLS 1.3 definition. That's why I got confused.\r\n\r\nmaybe adjust `ClientESNIInner ` like so:\r\n\r\n```\r\nstruct {\r\n   uint8 inner_nonce[16];\r\n   PaddedServerNameList realSNI;\r\n} ClientESNIInner;\r\n```\r\n\r\nand then:\r\n\r\n`nonce = HKDF-Expand-Label(Zx, \"esni iv\", Hash(ESNIContents), iv_length)`",
          "createdAt": "2019-10-26T02:29:49Z",
          "updatedAt": "2019-10-26T02:42:28Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "> For example, things called \"*_iv\" are inputs to nonce in TLS 1.3. \r\n\r\nI don't see how this argues your point. Again, the names are irrelevant.\r\n\r\n> In some implementations, the input \"Initialization Vector (IV)\" [RFC4106] might be a different static type from the nonce in the TLS 1.3 definition.\r\n\r\nI don't really see how the implementation types are relevant here.\r\n\r\nIn any case, given the state of the draft and the reasonable likelihood this will change, I think this decision is well within editor discretion.",
          "createdAt": "2019-10-26T03:28:49Z",
          "updatedAt": "2019-10-26T03:28:49Z"
        },
        {
          "author": "sayrer",
          "authorAssociation": "NONE",
          "body": "> > For example, things called \"*_iv\" are inputs to nonce in TLS 1.3.\r\n> \r\n> I don't see how this argues your point. Again, the names are irrelevant.\r\n\r\nThe TLS spec and the ESNI spec do not have a type system. They do have a serialization spec, and I am not arguing about that. I do think the names could be clearer without inventing a type system.\r\n \r\n> > In some implementations, the input \"Initialization Vector (IV)\" [RFC4106] might be a different static type from the nonce in the TLS 1.3 definition.\r\n> \r\n> I don't really see how the implementation types are relevant here.\r\n\r\nWell, I think this perspective leads to reverse engineering C/C++ implementations, rather than precisely specifying the inputs to functions like AEAD-Encrypt.\r\n",
          "createdAt": "2019-10-26T03:44:18Z",
          "updatedAt": "2019-10-26T03:44:18Z"
        },
        {
          "author": "sayrer",
          "authorAssociation": "NONE",
          "body": "Maybe it could say something like \"The ClientEncryptedSNI.encrypted_sni value is then computed using the usual TLS 1.3 AEAD, but note that the second argument, 'iv', is not combined with a sequence number:\"\r\n\r\nThe reason I found this confusing was that TLS 1.3 doesn't define the \"nonce\" argument symbolically, but the ESNI draft does define \"iv\" symbolically. That's fine, but I then had to plumb a new kind of value into the library to allow for this IV, and I wasn't sure if it was right.",
          "createdAt": "2019-10-26T18:49:19Z",
          "updatedAt": "2019-10-26T18:49:19Z"
        },
        {
          "author": "nharper",
          "authorAssociation": "NONE",
          "body": "I agree with @ekr that AEAD-Encrypt is a 4 positional argument function and it shouldn't matter what they're called in the ESNI spec compared to what they're called in RFC 8446. However, from re-reading RFC 8446, I don't see a good definition of the AEAD-Encrypt function. Perhaps it would be better to describe the encryption using the Authenticated Encryption interface described in [Section 2.1 of RFC 5116](https://tools.ietf.org/html/rfc5116#section-2.1)?",
          "createdAt": "2019-10-28T18:41:48Z",
          "updatedAt": "2019-10-28T18:41:48Z"
        },
        {
          "author": "sayrer",
          "authorAssociation": "NONE",
          "body": "\"AEAD-Encrypt is a 4 positional argument function and it shouldn't matter what they're called in the ESNI spec compared to what they're called in RFC 8446.\"\r\n\r\nThis is sort of true, but I noticed that the specs use the name of the second argument to imply its input treatment: IV vs nonce. In that light, I suppose my suggested text might sound redundant, but I think the current document is too concise.",
          "createdAt": "2019-10-28T19:13:50Z",
          "updatedAt": "2019-10-28T19:13:50Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed in #194.",
          "createdAt": "2019-11-04T21:41:28Z",
          "updatedAt": "2019-11-04T21:41:28Z"
        }
      ]
    },
    {
      "number": 190,
      "id": "MDU6SXNzdWU1MTYzMTQ1NDY=",
      "title": "AAD calculation could use more explanation",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/190",
      "state": "CLOSED",
      "author": "sayrer",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "The draft says\r\n\r\n\"The ClientEncryptedSNI.encrypted_sni value is then computed using the usual TLS 1.3 AEAD:\r\n\r\n    encrypted_sni = AEAD-Encrypt(key, iv, KeyShareClientHello, ClientESNIInner)\r\n\r\nWhere KeyShareClientHello is the \"extension_data\" field of the  \"key_share\" extension in a Client Hello (Section 4.2.8 of [RFC8446]))\"\r\n\r\nI found that NSS inserts an extra 8 bytes of zeros in front of KeyShareClientHello for its AAD:\r\nhttps://dxr.mozilla.org/mozilla-central/rev/0e1726e95801928249c4dc14fd23fe2cbbb13b3b/security/nss/lib/ssl/tls13esni.c#665\r\n\r\nI'm not sure if those zeros are implied by one of the references. I couldn't spot it after looking for 10 minutes or so, and that byte seems to be in code specifically intended for ESNI.",
      "createdAt": "2019-11-01T19:52:16Z",
      "updatedAt": "2019-11-01T23:01:34Z",
      "closedAt": "2019-11-01T22:12:42Z",
      "comments": [
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "You're misreading the code. This is an idiosyncracy of the internal NSS interface. The 0s here are what would be the TLS sequence number ordinarily and are not part of the AAD.",
          "createdAt": "2019-11-01T22:12:42Z",
          "updatedAt": "2019-11-01T22:12:42Z"
        },
        {
          "author": "sayrer",
          "authorAssociation": "NONE",
          "body": "It could be a misreading, but should this be closed? At the very least, some TLS implementations will prepend 8 bytes of zeros. Another instance of unclear input treatment in this text.",
          "createdAt": "2019-11-01T22:29:27Z",
          "updatedAt": "2019-11-01T22:29:27Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "NSS's code isn't part of the text, so the spec isn't responsible for people's misinterpretations of the NSS code (or any other code).",
          "createdAt": "2019-11-01T22:32:04Z",
          "updatedAt": "2019-11-01T22:32:04Z"
        },
        {
          "author": "sayrer",
          "authorAssociation": "NONE",
          "body": "Well, currently NSS's code is implied in the spec, because no one could get the ESNI record's checksum right by following any draft. One would have to combine -02 and -04 in the way NSS does.",
          "createdAt": "2019-11-01T22:37:40Z",
          "updatedAt": "2019-11-01T22:37:40Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "I haven't verified that this is true, but even if it is, NSS Is not the reference implementation for the specification and failure to interoperate with NSS is not the test for correct implementations. We (NSS) are not attempting to track the current spec because issues are still in fluc, so it's entirely possible that our implementation is in some funny state, but that's still not a spec issue.",
          "createdAt": "2019-11-01T22:43:11Z",
          "updatedAt": "2019-11-01T22:43:11Z"
        },
        {
          "author": "sayrer",
          "authorAssociation": "NONE",
          "body": "It's true. record_digest is transmitted in the clear, and I noticed my implementation's value mismatched Firefox's.\r\n\r\nI think the issue is not so much that NSS has bugs (it happens), but that the spec is vague enough that I am having trouble telling whether NSS's behavior is following the spec.",
          "createdAt": "2019-11-01T23:00:19Z",
          "updatedAt": "2019-11-01T23:01:34Z"
        }
      ]
    },
    {
      "number": 191,
      "id": "MDU6SXNzdWU1MTYzNTA0NjA=",
      "title": "Why is the PaddedSNI padded with zeros?",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/191",
      "state": "CLOSED",
      "author": "sayrer",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Couldn't these extra bytes be any value?",
      "createdAt": "2019-11-01T21:14:03Z",
      "updatedAt": "2019-11-05T08:13:05Z",
      "closedAt": "2019-11-04T20:52:21Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Yes, but zeroes are quite common. See, e.g., TLS 1.3 record-layer padding: https://tools.ietf.org/html/rfc8446#section-5.4.",
          "createdAt": "2019-11-04T20:52:21Z",
          "updatedAt": "2019-11-04T20:52:21Z"
        },
        {
          "author": "sayrer",
          "authorAssociation": "NONE",
          "body": "Would you mind reopening this issue? I think a MUST requirement with a rationale of \"everyone else does it\" seems wrong.\r\n\r\nI can think of some reasons to mandate zeros:\r\n\r\n- prevent ad-hoc extensions\r\n- prevent clients from intentionally weakening traffic\r\n\r\nstuff like that. I just think the draft should state the rationale.\r\n",
          "createdAt": "2019-11-04T22:54:43Z",
          "updatedAt": "2019-11-04T22:54:43Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "I would prefer that we not add any rationale. This is a reasonable choice and if we add a rationale for everything that is reasonable the draft will get quite long.\r\n\r\nSecond, we are actively considering a number of PRs here, at least one of which does not even have these bytes, so effort spent justifying them is potentially wasted.",
          "createdAt": "2019-11-04T23:02:01Z",
          "updatedAt": "2019-11-04T23:02:01Z"
        },
        {
          "author": "sayrer",
          "authorAssociation": "NONE",
          "body": "> I would prefer that we not add any rationale. This is a reasonable choice and if we add a rationale for everything that is reasonable the draft will get quite long.\r\n\r\nIt's a not a reasonable choice if there is no reason for it.\r\n\r\n> Second, we are actively considering a number of PRs here, at least one of which does not even have these bytes, so effort spent justifying them is potentially wasted.\r\n\r\nThat makes sense. What's the link?",
          "createdAt": "2019-11-04T23:14:10Z",
          "updatedAt": "2019-11-04T23:14:10Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "\r\nIt's a not a reasonable choice if there is no reason for it.",
          "createdAt": "2019-11-05T02:23:17Z",
          "updatedAt": "2019-11-05T02:23:17Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@sayrer I don't think this needs rationale. Padding with zeros is more or less convention in TLS, and we've stuck with it. ",
          "createdAt": "2019-11-05T02:24:44Z",
          "updatedAt": "2019-11-05T02:24:44Z"
        },
        {
          "author": "sayrer",
          "authorAssociation": "NONE",
          "body": "> It's a not a reasonable choice if there is no reason for it.\r\n\r\nJokes aside, what would the rationale be for this requirement?\r\n\r\n\"The SNI must be padded with zeros, because ________\".\r\n\r\nIt may be the case that other TLS specs have used zeros.",
          "createdAt": "2019-11-05T05:20:26Z",
          "updatedAt": "2019-11-05T05:20:26Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "It's not the case that every design decision in the specification needs to have a rationale in the specification. That's not any kind of IETF requirement.\r\n\r\nIf you have some objection to this design choice, I suggest you raise it on the mailing list and see if others agree.\r\n\r\n\r\n\r\n\r\n",
          "createdAt": "2019-11-05T05:32:43Z",
          "updatedAt": "2019-11-05T05:33:22Z"
        },
        {
          "author": "sayrer",
          "authorAssociation": "NONE",
          "body": "It's true that not every requirement needs a rationale. Some of them are obviously in service of the goals of the draft itself: for example, no one is claiming that the document should justify encryption. It's also reasonable to cite other documents as the way to do things: there's no need to provide a rationale for the use of AEAD, for instance.\r\n\r\nBut, the choice of server-controlled zeros for this padding is specific to this draft. It seems like this requirement would be better as a server-specified minimum length, where the field is variable length and filled with opaque data (zeros are acceptable).",
          "createdAt": "2019-11-05T05:42:52Z",
          "updatedAt": "2019-11-05T05:42:52Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "We've been bitten by requirements for opaque data in the past.  See POODLE.",
          "createdAt": "2019-11-05T06:52:03Z",
          "updatedAt": "2019-11-05T06:52:03Z"
        },
        {
          "author": "sayrer",
          "authorAssociation": "NONE",
          "body": "> We've been bitten by requirements for opaque data in the past. See POODLE.\r\n\r\nThis comment seems ambiguous enough to warrant reopening the issue.",
          "createdAt": "2019-11-05T08:13:04Z",
          "updatedAt": "2019-11-05T08:13:04Z"
        }
      ]
    },
    {
      "number": 192,
      "id": "MDU6SXNzdWU1MTY1MzAyMDY=",
      "title": "How to parse esni_retry_request generically?",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/192",
      "state": "CLOSED",
      "author": "ocheron",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "As of draft-ietf-tls-esni-04, when the server rejects ESNI with esni_retry_request, it includes one or more ESNIKeys for retry:\r\n```\r\n      struct {\r\n          ServerESNIResponseType response_type;\r\n          select (response_type) {\r\n              case esni_accept:        uint8 nonce[16];\r\n              case esni_retry_request: ESNIKeys retry_keys<1..2^16-1>;\r\n          }\r\n      } ServerEncryptedSNI;\r\n\r\n   retry_keys  One or more ESNIKeys structures containing the keys that\r\n      the client should use on subsequent connections to encrypt the\r\n      ClientESNIInner structure.\r\n```\r\n\r\nThe client behavior described in section 5.1.2 is to pick one of the ESNIKeys values from this vector:\r\n\r\n> If one of the values contains a version supported by the client,\r\n> it can regard the ESNI keys as securely replaced by the server.\r\n> It SHOULD retry the handshake with a new transport connection,\r\n> using that value to encrypt the SNI.\r\n\r\nEncoding of `retry_keys` contains the total size of the vector field but not the size of the individual ESNIKeys elements. This makes it difficult (impossible?) to parse a vector with unknown future versions, so this part is not really extensible.",
      "createdAt": "2019-11-02T08:27:46Z",
      "updatedAt": "2019-11-21T10:17:47Z",
      "closedAt": "2019-11-21T10:17:47Z",
      "comments": [
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thanks for the comment! https://github.com/tlswg/draft-ietf-tls-esni/pull/198 should resolve this. It's a little goofy-looking but ah well.",
          "createdAt": "2019-11-05T22:04:23Z",
          "updatedAt": "2019-11-05T22:04:23Z"
        },
        {
          "author": "ocheron",
          "authorAssociation": "NONE",
          "body": "Thank you for confirming the issue. Not the nicest but will be effective.\r\nIt's the only real blocking point I see when implementing draft -04.",
          "createdAt": "2019-11-09T08:33:36Z",
          "updatedAt": "2019-11-09T08:33:36Z"
        }
      ]
    },
    {
      "number": 193,
      "id": "MDU6SXNzdWU1MTY2OTg5MTk=",
      "title": "Reasoning for 260",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/193",
      "state": "CLOSED",
      "author": "sayrer",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "The initial commit for the padding in the spec gave the reason for the \"260\" figure (maximum domain + TLS struct overhead). There have been many comments mentioning slightly lower numbers (255, 253, etc). It's subtle enough that the spec should probably detail the reason.",
      "createdAt": "2019-11-02T19:39:45Z",
      "updatedAt": "2019-11-04T21:41:21Z",
      "closedAt": "2019-11-04T21:41:21Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed in #194.",
          "createdAt": "2019-11-04T21:41:21Z",
          "updatedAt": "2019-11-04T21:41:21Z"
        }
      ]
    },
    {
      "number": 202,
      "id": "MDU6SXNzdWU1MjMwMDI5NTM=",
      "title": "Removing ESNI RRType Considerations",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/202",
      "state": "CLOSED",
      "author": "mrsylerpowers",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Because this document now delegates the way the keys are advertised from the RRType ESNI to HTTPSSVC shouldn't the RRType Considerations be removed from this document. ",
      "createdAt": "2019-11-14T17:30:58Z",
      "updatedAt": "2019-11-14T20:35:25Z",
      "closedAt": "2019-11-14T20:35:25Z",
      "comments": []
    },
    {
      "number": 204,
      "id": "MDU6SXNzdWU1MjgzMjI0MTk=",
      "title": "Anonymity sets",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/204",
      "state": "CLOSED",
      "author": "sayrer",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Even if #146 and #139 are closed without further edits, I think the draft should clarify the intended anonymity set for ESNIConfig and its associated record_digest. The draft does address this in section 7.5.2. \"Avoid widely-deployed shared secrets\", but I missed that. Additionally, the draft uses the term \"anonymity set\" only once, in section 6.1. \"Misconfiguration and Deployment Concerns\".\r\n\r\nThe explanation Ben Schwartz wrote on the list is very clear:\r\n\r\n\"The record_digest, like the ESNIConfig itself, is intended to be constant across all domains that form an anonymity set (i.e. O(1) ESNIConfigs per CDN).  Thus, the record_digest reveals no additional information to an onlooker who can observe the server IP.\"\r\n\r\nPerhaps a short section on anonymity sets would clarify this. I think some combination of section 7.5.2 and the last paragraph of the introduction would work.",
      "createdAt": "2019-11-25T20:35:36Z",
      "updatedAt": "2020-04-27T21:58:03Z",
      "closedAt": "2020-04-27T21:58:03Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@sayrer text to clarify this would be most welcome. Please provide a PR!",
          "createdAt": "2019-11-25T20:59:05Z",
          "updatedAt": "2019-11-25T20:59:05Z"
        },
        {
          "author": "ret394",
          "authorAssociation": "NONE",
          "body": "is the clarification still required? just curious.",
          "createdAt": "2020-04-09T04:35:42Z",
          "updatedAt": "2020-04-09T04:35:42Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Indeed, I'm not sure further clarification is needed. Given no action on this issue, I'm closing. Please propose a PR or text if you feel this still needs to be fixed!",
          "createdAt": "2020-04-27T21:58:03Z",
          "updatedAt": "2020-04-27T21:58:03Z"
        }
      ]
    },
    {
      "number": 205,
      "id": "MDU6SXNzdWU1Mjg5ODA1MTY=",
      "title": "Include \"receiver anonymity\" as motivation for empty record_digest values",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/205",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "chris-wood"
      ],
      "labels": [],
      "body": "And possibly also include a bit inside ESNIConfig that tells clients whether or not to populate record_digest. (See https://bford.info/pub/sec/purb.pdf for some relevant definitions.)",
      "createdAt": "2019-11-26T21:26:01Z",
      "updatedAt": "2020-05-03T14:05:15Z",
      "closedAt": "2020-05-03T14:05:15Z",
      "comments": []
    },
    {
      "number": 206,
      "id": "MDU6SXNzdWU1NTkzNjc1OTc=",
      "title": "Suggestion to support user@domain.name",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/206",
      "state": "CLOSED",
      "author": "vanrein",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "I would like to suggest supporting not only the `server_name`, but also permit user names to be included.  This would provide excellent support for peer-to-peer applications for protocols that use `user@domain.name` identities and whose design can work peer-to-peer.\r\n\r\nThere are [TLS relays using SNI](https://github.com/dlundquist/sniproxy) that need no knowledge about the content of the TLS stream, so they are no men in the middle.  With user names added into ESNI, it would be possible to do similar things with registered users; [SIP](https://tools.ietf.org/html/rfc3261) springs to mind as an example, because phones/terminals `REGISTER` [to a domain's server](https://tools.ietf.org/html/rfc3261#section-10.3) that subsequently [relays](https://tools.ietf.org/html/rfc3261#page-12) `INVITE` and other messages between them but is effectively a MITM, which can modify traffic and tap [SDP](https://tools.ietf.org/html/rfc4566)-transmitted [keys](https://tools.ietf.org/html/rfc4566#section-5.12) and [communication end points](https://tools.ietf.org/html/rfc4566#section-4.1).\r\n\r\nThe general story is of course that end-to-end encryption is better than hop-by-hop encryption, as in current uses of TLS.  Peers representing users that register with an intermediate server sound like a good opportunity to be doing that.  All that is required is a way of deciding where to forward TLS traffic, without changing its contents.  ESNI comes really close to that goal (if it adds user names).",
      "createdAt": "2020-02-03T22:16:36Z",
      "updatedAt": "2020-04-27T21:56:35Z",
      "closedAt": "2020-04-27T21:56:35Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Since the draft now encrypts the entire CH, this issue is irrelevant. (In particular, if clients want to send user names, they can do so today, with or without ECHO.)",
          "createdAt": "2020-04-27T21:56:35Z",
          "updatedAt": "2020-04-27T21:56:35Z"
        }
      ]
    },
    {
      "number": 214,
      "id": "MDU6SXNzdWU1OTYwMzA5MTk=",
      "title": "Clarify 1.2 connection support (don't break connections, but also don't protect the certificate)",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/214",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "chris-wood"
      ],
      "labels": [],
      "body": "If the backend server does not include any signal for ECHO negotiation, either as a ServerHello extension or part of ServerHello.random, then it's possible to tunnel CHs to TLS 1.2 servers. This can be a feature, so let's consider whether or not it's in scope. (Note that we may discover that lack of server-side handshake message padding may make traffic analysis trivial.)\r\n\r\ncc @grittygrease ",
      "createdAt": "2020-04-07T17:24:36Z",
      "updatedAt": "2020-05-21T21:40:57Z",
      "closedAt": "2020-05-21T21:40:57Z",
      "comments": [
        {
          "author": "sftcd",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Not sure that'd be worthwhile. Wouldn't the TLS server cert be sent in clear to the client? So the server-name will be visible anyway. I'm not sure if the remaining CH content is sufficient to justify the added complexity of having to handle a TLSv1.2 CH.",
          "createdAt": "2020-04-12T20:17:03Z",
          "updatedAt": "2020-04-12T20:17:03Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "If we didn't encrypt the server flight, that's right! But we might consider designs wherein the client-facing server encrypts (or tunnels) the server flight, just as we've done for the client flight.",
          "createdAt": "2020-04-12T22:01:57Z",
          "updatedAt": "2020-04-12T22:01:57Z"
        },
        {
          "author": "sftcd",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Ah, so support for TLSv1.2 here implies a new middle->client encryption. My first reaction is that we're nearly inventing masque again, so maybe this is a feature to leave for that?",
          "createdAt": "2020-04-12T22:34:16Z",
          "updatedAt": "2020-04-12T22:34:16Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> Ah, so support for TLSv1.2 here implies a new middle->client encryption. My first reaction is that we're nearly inventing masque again, so maybe this is a feature to leave for that?\r\n\r\nPossibly. There may be a middle ground. Considering the amount of TLS 1.2 servers in existence, I think this is worth some thought.",
          "createdAt": "2020-04-13T13:48:14Z",
          "updatedAt": "2020-04-13T13:48:14Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "This seems clever, but on balance it seems like we are getting close to a \"tunnel everything\" design. We want people to move to 1.3 and so going out of our way to accommodate 1.2 seems backwards.",
          "createdAt": "2020-04-24T14:38:41Z",
          "updatedAt": "2020-04-24T14:38:41Z"
        },
        {
          "author": "grittygrease",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The main problem this solves is in the fronting case. Specifically, in the\ncase that an ECHO-aware fronting server is operated by a different entity\nthan the backend server and the fronting server does not know whether the\nbackend server supports TLS 1.3 or not. Enabling support for TLS 1.2\nenables this fronting server to be deployed in front of a wide set of\nservers.\n\nOn Fri, Apr 24, 2020 at 7:38 AM ekr <notifications@github.com> wrote:\n\n> This seems clever, but on balance it seems like we are getting close to a\n> \"tunnel everything\" design. We want people to move to 1.3 and so going out\n> of our way to accommodate 1.2 seems backwards.\n>\n> \u2014\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/tlswg/draft-ietf-tls-esni/issues/214#issuecomment-619050908>,\n> or unsubscribe\n> <https://github.com/notifications/unsubscribe-auth/ABHDHZ4SMC6TFEUWSRDFLIDROGQAFANCNFSM4MDJN5UQ>\n> .\n>\n",
          "createdAt": "2020-04-24T23:02:26Z",
          "updatedAt": "2020-04-24T23:02:26Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "As others have pointed out, the cost of adding support for TLS 1.2 servers it that there needs to be a layer below the TLS record layer, so that the plaintext records sent by the backend server can be encrypted.\r\n\r\nI'd be a bit concerned about the required cost and complexity that that has, therefore my +1 goes to just supporting TLS 1.3.",
          "createdAt": "2020-04-27T06:14:18Z",
          "updatedAt": "2020-04-27T06:14:18Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Two concerns here:\r\n\r\n1. Security: Suppose an adversary can inject a TLS 1.2 ServerHello, without the echo_nonce, and a Certificate message.  Does the client react differently depending on whether the hidden name is in the SAN list (e.g. certificate mismatch fails faster than verification failure)?  If so, the adversary might be able to learn the hidden name.\r\n\r\n2. Management: Suppose a TLS 1.2 backend is not coordinating closely with forwarder, which seems to be the goal of this model.  When the backend upgrades to TLS 1.3, will connections start failing because it is not including the echo_nonce in the transcript?",
          "createdAt": "2020-04-27T21:14:24Z",
          "updatedAt": "2020-04-27T21:14:24Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "The client reaction issue is interesting, though maybe we can get around that by requiring constant time verification? On some systems that might be very hard to enforce, as verification doesn't even happen in the same process. Hmm... penny for your thoughts, @ekr and @davidben?\r\n\r\nAs for the nonce issue -- it's already included in the ClientHello. The server doesn't include it an extension explicitly.",
          "createdAt": "2020-04-27T21:26:05Z",
          "updatedAt": "2020-04-27T21:26:55Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thanks for the clarification.  I still think there's a potential best-practices concern if this encourages deployments that transmit the decrypted ClientHello in cleartext between the forwarder and backend, but that's less obvious.",
          "createdAt": "2020-04-27T23:28:44Z",
          "updatedAt": "2020-04-27T23:28:44Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Agreed! Clarifying text there would help. I'll see if I can craft something along those lines for this issue.",
          "createdAt": "2020-04-27T23:30:47Z",
          "updatedAt": "2020-04-27T23:30:47Z"
        },
        {
          "author": "sftcd",
          "authorAssociation": "CONTRIBUTOR",
          "body": "\nFWIW, I still think making complexity-inducing changes\nto better support TLSv1.2 (even in this reduced manner)\nwould be a bad plan. In large part because it'd take ages to figure it\nout. If someone could demonstrate a reduction\nin complexity and increase in security I might change my\nmind. Absent that, I continue to think we're better off\nexclusively supporting TLSv1.3.\n\nCheers,\nS.\n",
          "createdAt": "2020-04-27T23:34:12Z",
          "updatedAt": "2020-04-27T23:34:12Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The issue of not being able to clearly tell whether ServerHello used the outer or inner ClientHello does seem somewhat fatal. Deferring figuring this out to certificate verification is especially a nuisance, and I shudder at the thought having a coherent notion of constant-time X.509 verification.",
          "createdAt": "2020-05-21T21:25:26Z",
          "updatedAt": "2020-05-21T21:25:26Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "I think we should continue to base this on the assumption that the server does TLS 1.3. Trying to analyze the question of how this integrates with TLS 1.2  -- especially given that we have concerns about the naive integration -- seems prohibitive.",
          "createdAt": "2020-05-21T21:27:31Z",
          "updatedAt": "2020-05-21T21:27:31Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "On reflection, I tend to agree. On platforms I'm familiar with, constant-time certificate verification would be intractable. I'm closing this issue with the recommendation that we stick to the document's intent: ESNI for TLS 1.3. ",
          "createdAt": "2020-05-21T21:40:57Z",
          "updatedAt": "2020-05-21T21:40:57Z"
        }
      ]
    },
    {
      "number": 215,
      "id": "MDU6SXNzdWU1OTYwMzMzNTQ=",
      "title": "Limit \"Don't stick out\" to explicit signals",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/215",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "chris-wood"
      ],
      "labels": [],
      "body": "There's no explicit signal indicating that ECHO was negotiated for a connection. Thus, clients must perform trial decryption with both possible handshake keys. If we intend to keep this, then we should crisply state that \"don't stick out\" is limited to explicit signals, i.e., implicit signals such as size-related information is probably out of scope. (It's certainly an open question what is the \"best\" padding scheme for handshake messages.)\r\n\r\ncc @grittygrease ",
      "createdAt": "2020-04-07T17:28:54Z",
      "updatedAt": "2020-05-05T20:10:04Z",
      "closedAt": "2020-05-05T20:10:04Z",
      "comments": []
    },
    {
      "number": 216,
      "id": "MDU6SXNzdWU1OTg1MDI5MDk=",
      "title": "Clarify ECHOConfig (HTTPSSVC) extension purpose",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/216",
      "state": "CLOSED",
      "author": "sftcd",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "chris-wood"
      ],
      "labels": [],
      "body": "ECHOConfig.public_name provides information that goes in the outer CH. HTTPSSVC.alpn provides information to go in the inner CH (I assume). We don't specify a way for the server to  explicitly say what alpn to use in the outer CH.  I think it'd be worth re-considering where servers/admins might want to put that kind of information and how much of the inner/outer CH they may want to describe. There could be a range of potential outcomes if we re-visit this - at one extreme HTTPSSVC or ECHOConfig might provide a template for the entire CH (possibly via some template naming/numbering scheme), at the other extreme we might decide that ECHOConfig should only contain the keying information and just define alpn, public_alpn and public_name as optional fields for inclusion in HTTPSSVC. But it seems a bit broken for the only two parts of the CH the server specifies to be handled so differently,",
      "createdAt": "2020-04-12T14:54:22Z",
      "updatedAt": "2020-05-07T18:43:48Z",
      "closedAt": "2020-05-07T18:43:47Z",
      "comments": [
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> HTTPSSVC.alpn provides information to go in the inner CH (I assume).\r\n\r\nIt doesn't. It's important for downgrade protection that the DNS (not secured) *not* impact the client's ALPN preferences. The interaction between HTTPSSVC and ALPN is... rather a mess and the text around this still needs work.",
          "createdAt": "2020-04-13T14:54:07Z",
          "updatedAt": "2020-04-13T14:54:07Z"
        },
        {
          "author": "sftcd",
          "authorAssociation": "CONTRIBUTOR",
          "body": "\n\nOn 13/04/2020 15:54, David Benjamin wrote:\n>> HTTPSSVC.alpn provides information to go in the inner CH (I\n>> assume).\n> \n> It doesn't. It's important for downgrade protection that the DNS (not\n> secured) *not* impact the client's ALPN preferences. The interaction\n> between HTTPSSVC and ALPN is... rather a mess and the text around\n> this still needs work.\n\nAh. Fair enough. Though I guess ECHO will likely only be\nused via DoH or something equivalent which could change\nthings maybe.\n\nBut regardless... doesn't the point still stand that we'd\nbe better off with some consistency in how we manage the\nserver-name in the outer CH, the ALPNs in both inner and outer, and any\nother CH content where the server wants to\npublish some hints?\n\nI'm not particularly wedded to a specific approach (though\nI'd likely be more biased to simplifying the ECHOConfig).\n\n\n",
          "createdAt": "2020-04-13T15:00:58Z",
          "updatedAt": "2020-04-13T15:00:58Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Even DoH won't authenticate the origin, only the resolver. One hopes the resolver is reasonably trusted, but I'd still prefer not giving it new powers. (Today, only the origin server pick HTTP/1.1 vs HTTP/2. That's useful given HTTP/1.1's safety against truncation attacks is... complicated.)\r\n\r\nI guess I see the public name less as an instruction for what to put in the outer ClientHello but a delegation to another name to authenticate any ECHO key replacements or ECHO shutoffs. That then implies putting it in the outer ClientHello so the server can pick the right fallback certificate. I think I'd also rather keep that information in ECHOConfig so the TLS stack gets a single bundle of data. (Similar thinking as https://github.com/tlswg/draft-ietf-tls-esni/issues/219#issuecomment-612963381.) But maybe the overall change would make more sense? I don't fully understand the proposal.\r\n\r\nOf course, the same authentication mismatch applies to the public name as any ALPN signals. While this was ESNI rather than ECHO, the reasoning was that the DNS server learns the hostname anyway, and can always drop ESNI records. The latter still holds for ECHO. The former... I'm not sure. Over in browser land, I really only care about the hostname, but there are probably other scenarios.",
          "createdAt": "2020-04-13T16:04:40Z",
          "updatedAt": "2020-04-13T16:05:24Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Assuming we are trying to do GREASE, the important thing is that the outer ClientHello is the same for clients with real and fake ECHO.  This could be achieved by providing a template in the ECHOConfig for the outer ClientHello that matches a popular client's behavior, or by telling clients \"when constructing the outer ClientHello, pretend you're connecting to the public name without the HTTPSSVC info\".  For now, I would lean to the latter for simplicity.  We can always define an outer ClientHello template later as an ECHOConfig extension.\r\n\r\nIf we give up on GREASE, I would remove the outer ALPN entirely.",
          "createdAt": "2020-04-15T03:06:20Z",
          "updatedAt": "2020-04-15T03:06:20Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The latter sounds reasonable.\r\n\r\nA template would not fly because the outer ClientHello must still adhere to [protocol invariants](https://tools.ietf.org/html/rfc8446#section-9.3), so any parameters in there must ones the client would legitimately accept. (Unless they ignore the fallback case and retry all errors with a more accurate outer ClientHello.)",
          "createdAt": "2020-04-15T14:58:54Z",
          "updatedAt": "2020-04-15T14:58:54Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "As per the call today, we'll use this issue to track guidance (that will be mirrored in the HTTPSSVC document) about how one populates extension information. In particular, information that pertains to the outer CH, which exists only for ECHO's sake, should be limited to ECHOConfig, whereas information that pertains to the inner CH should be put in the HTTPSSVC. We'll work with @bemasc to get this text in shape!",
          "createdAt": "2020-04-27T21:53:53Z",
          "updatedAt": "2020-04-27T21:54:08Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed in #226. Closing.",
          "createdAt": "2020-05-07T18:43:47Z",
          "updatedAt": "2020-05-07T18:43:47Z"
        }
      ]
    },
    {
      "number": 217,
      "id": "MDU6SXNzdWU1OTg1MjU2MTY=",
      "title": "ECHOConfigContents.extensions is not needed",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/217",
      "state": "CLOSED",
      "author": "sftcd",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "draft-06 includes an extensions field in ECHOConfigContents but no extension types are defined. If or when something new is needed it could just as easily be introduced via a new ECHOConfig.version or a new HTTPSSVC tag. The mandatory-to-understand design wit a \"critical\" bit was also used in X.509 and has not clearly worked as planned there. I don't see why that would differ here. Expecting implementers to include all the code required for generic extension handling and introducing new failure modes via critical bits, all for no concrete reason... seems wrong. I suggest we just delete the extensions field entirely. If needed, one can be added back via a new version later. \r\n\r\nBearing in mind the target for this draft is an experimental RFC, and so there's a reasonable likelihood of changes when/if we try promote ECHO to a standards-track RFC, we also don't need to be quite as future proof as normal, so deleting this field for now is not that risky.",
      "createdAt": "2020-04-12T16:50:26Z",
      "updatedAt": "2020-04-27T21:55:36Z",
      "closedAt": "2020-04-27T21:55:36Z",
      "comments": [
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "I don't agree with this proposed change.\r\n\r\n1.  Extensions for TLS have proved very useful.\r\n2. The analogy to X.509 seems false. Criticality has a different context here and IMO it works fine for (say) STUN.\r\n\r\nIntroducing a new version has all kinds of other annoyances.\r\n\r\nAs for the experimental bit, that seems like an oversight. I expected this to be PS and I'm not sure why the draft has a different tag. I expect I just screwed up when I wrote the first draft. I note the adoption call doesn't say one way or the other. As a practical matter, we expect this to have widespread deployment.\r\n \r\n",
          "createdAt": "2020-04-24T14:36:47Z",
          "updatedAt": "2020-04-24T14:36:47Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "As per the call today, we're closing this due to (a) the potential need for an extension to deliver padding hints in the future and (b) the benefits extensibility brought TLS in the past. ",
          "createdAt": "2020-04-27T21:55:36Z",
          "updatedAt": "2020-04-27T21:55:36Z"
        }
      ]
    },
    {
      "number": 218,
      "id": "MDU6SXNzdWU1OTg1NTY3MDI=",
      "title": "Use HPKE codepoints for all HPKE-relevant operations",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/218",
      "state": "CLOSED",
      "author": "sftcd",
      "authorAssociation": "NONE",
      "assignees": [
        "chris-wood"
      ],
      "labels": [],
      "body": "HPKE has it's own cipher suite code points, as well as the KEM id. I don't see why we're using TLS codepoints (ECHOConfigContents.suites and ClientEncryptedCH.suite) and yet also use one HPKE code point (ECHOConfigContents.kem_id). But maybe I'm missing something?\r\n\r\nIf not, I think one of two things would make sense:\r\n\r\n1. Change HPKE to use TLS code points. (That could be done but'd involve a bit of nose-holding, however it might be better in the longer term.)\r\n2. Only use HPKE code points in ECHO - I don't see that TLS ciphersuites are actually needed for ECHO, so this seems easiest. (That'd mean s/suite/aead_id/g I guess.)\r\n",
      "createdAt": "2020-04-12T19:39:49Z",
      "updatedAt": "2020-05-02T01:36:23Z",
      "closedAt": "2020-05-02T01:36:23Z",
      "comments": [
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "I tend to agree with Stephen here. ISTM that probably (1) is better, actually.",
          "createdAt": "2020-04-24T14:39:36Z",
          "updatedAt": "2020-04-24T14:39:36Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "I don't think we want HPKE to depend on TLS code points. Algorithms that come down the pipe may not be suitable for TLS. I'd prefer option (2).",
          "createdAt": "2020-04-24T15:06:48Z",
          "updatedAt": "2020-04-24T15:06:48Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "NONE",
          "body": "There's also a third option here:\r\n\r\n3. Use TLS code points (or something else) and define a mapping to HPKE code points\r\n\r\nLike @chris-wood, I am disinclined to tie HPKE to TLS, since it is a more general tool.\r\n\r\nIt seems like the answer here depends on what the negotiation in ECHO is being used for.  If it's just for the HPKE, use HPKE code points.  If it's used in TLS further down the line, use TLS code points and map to HPKE for the HPKE bits.",
          "createdAt": "2020-04-24T15:22:48Z",
          "updatedAt": "2020-04-24T15:22:48Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "How is (3) different than the current design?",
          "createdAt": "2020-04-26T20:51:52Z",
          "updatedAt": "2020-04-26T20:51:52Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Per the call today, we'll use this issue to track moving everything to HPKE codepoints. (We can remove the mapping table at the same time).",
          "createdAt": "2020-04-27T21:54:43Z",
          "updatedAt": "2020-04-27T21:54:43Z"
        }
      ]
    },
    {
      "number": 219,
      "id": "MDU6SXNzdWU1OTg1NjU3NTU=",
      "title": "cardinality of ECHOConfig vs. HTTPSSVC",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/219",
      "state": "CLOSED",
      "author": "sftcd",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "A server can publish multuple HTTPSSVC RRs. Each of those RRs can contain multiple ECHOConfigContent values (i.e. multiple public keys and public_names). I don't see a real need for two different ways to publish more than one public key for a given server. There is a minor efficiency benefit in terms of the number of octets published in the DNS, but there is a lot of additional complexity in terms of code, and if nobody really publishes multiple public keys in one RR value, then that code is likely where we'll find CVEs. Reducing down to one public key per RR value also reduces the complexity when writing code to create/publish RRs.\r\n\r\nI think we have to support multiple RR values, because that's how the DNS works, and so the one to drop is the multiple public keys in one ECHOConfigs. IOW, I'd suggest one ECHOConfig has exactly one public key.\r\n ",
      "createdAt": "2020-04-12T20:32:56Z",
      "updatedAt": "2020-04-27T21:52:40Z",
      "closedAt": "2020-04-27T21:52:40Z",
      "comments": [
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "A single ECHOConfig already has only one public key from https://github.com/tlswg/draft-ietf-tls-esni/pull/201 and the HPKE bits.\r\n\r\nI'm guessing you meant ECHOConfigs? There are multiple ECHOConfig values in a single ECHOConfigs, which came from https://github.com/tlswg/draft-ietf-tls-esni/pull/200. (Gosh, that was a terrible name. My bad. Maybe we should rename it?) I think the rationale there still holds? The problem is that an HTTPSSVC RR implies transport-level decisions, while not every ECHOConfig can be consumed by your TLS logic. Folding them together means transport connect needs to be aware of the exact ECHO capabilities. For instance, the origin could advertise:\r\n\r\n* route1.example.com echo=ECHOv1\r\n* route2.example.com echo=ECHOv2\r\n\r\nThe logic picking HTTPSSVC routes no longer gets a free choice. It must be aware of the TLS layer's capabilities (down to mandatory extensions and HPKE code points). ECHOConfigs means the expectation is:\r\n\r\n* route1.example.com echo={ECHOv1,ECHOv2}\r\n* route2.example.com echo={ECHOv2,ECHOv2}\r\n\r\nNow you pick a route freely and pass the entire opaque ECHO blob to TLS to interpret. Of course, one could still advertise:\r\n\r\n* route1.example.com echo={ECHOv1}\r\n* route2.example.com echo={ECHOv2}\r\n\r\nBut you're no longer forced to explode it out like that, so we can say an ECHOv1-only client that happens to pick route2 can act as if route1 didn't exist. I.e. we set an expectation that all your routes must be equally capable. (Just as we have that expectation elsewhere. If route1 only speaks TLS 1.0, you're not getting TLS's downgrade protection because the attacker can always redirect you to the less secure config.)",
          "createdAt": "2020-04-13T16:03:22Z",
          "updatedAt": "2020-04-13T16:03:22Z"
        },
        {
          "author": "sftcd",
          "authorAssociation": "NONE",
          "body": "\n\nOn 13/04/2020 17:03, David Benjamin wrote:\n> \n> But you're no longer forced to explode it out like that, so we can \n> say an ECHOv1-only client that happens to pick route2 can act as if \n> route1 didn't exist. I.e. we set an expectation that all your routes \n> must be equally capable. (Just as we have that expectation \n> elsewhere.\n\nGotta admit I'm not at all getting what you're saying,\nsorry. As-is, clients need to write the code to handle\nmultiple keys (and all other variations possible) at\nboth levels, or if not, then we're missing text in the\nspec saying what doesn't need to be supported.\n\nI don't see a real benefit in that complexity.\n",
          "createdAt": "2020-04-13T19:35:35Z",
          "updatedAt": "2020-04-13T19:35:35Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "As per today's call, we're closing this due to the simplifications it brings for client implementations, in particular around collating all logic about ECHOConfig compatibility inside the TLS stack without the need for additional interfaces.",
          "createdAt": "2020-04-27T21:52:40Z",
          "updatedAt": "2020-04-27T21:52:40Z"
        }
      ]
    },
    {
      "number": 220,
      "id": "MDU6SXNzdWU1OTg1Njc0Nzc=",
      "title": "two type codes needed for interop",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/220",
      "state": "OPEN",
      "author": "sftcd",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "We need to pick some values for the \"encrypted_client_hello(TBD)\" and for the HTTPSSVC RR type before we can do interop. Allocating some values from the private ranges for those before draft-07 is pushed out would be good so we can do some interop testing. (Or for whatever is the next draft for which we want to do interop.)",
      "createdAt": "2020-04-12T20:43:00Z",
      "updatedAt": "2020-04-12T20:43:00Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 223,
      "id": "MDU6SXNzdWU2MDY0MDExNjE=",
      "title": "Restrict ECHO inner/outer variance for interop purposes",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/223",
      "state": "CLOSED",
      "author": "sftcd",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "First, I do think the security analysis for ECHO ought consider that the inner can be entirely different from the outer. That does not mean that we need to make full use of that flexibility when considering interop.\r\n\r\nIn the ECHO coding I've done so far, handling more restricted variation between inner and outer is a lot simpler, code-wise, and I would expect, will make interop easier and more successful. It seems (at least with OpenSSL) that once the cryptographic parameters (e.g. key shares) are allowed to vary between inner and outer, then things get significantly more complex. (That's not only down to\r\nthe trial decryption on the client btw, but is clearly demonstrated by the need for trial decryption.)\r\n\r\nI suggest we consider, for now, restricting how the inner and outer can vary, for example, only requiring implementations be able to handle minimal variation, perhaps only with server name and alpn and the nonce and ECHO that have to differ.\r\n\r\nIf, having coded this up, people figure it is actually  easy enough to support more flexibility then we could change to require support for that later. I think we should be able to decide before WGLC or IETF LC but don't believe we can currently be confident that full flexibility would be a good interop choice.\r\n ",
      "createdAt": "2020-04-24T15:32:49Z",
      "updatedAt": "2020-04-27T21:51:17Z",
      "closedAt": "2020-04-27T21:51:17Z",
      "comments": [
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "You need trial decryption on the client no matter what, because the transcript will be different, so that's not relevant here.\r\n\r\nI am not in favor of restricting how the inner and outer can vary. This is precisely the kind of thing that implementations might then get wrong by assuming and then we have problems.\r\n\r\nIt seems to me that your primary argument here is implementation difficulty, plus some speculation about interop. I don't anticipate any difficulty implementing this in NSS based on my experience with HRR, and it seems like we'll find out whether there are interop difficulties soon enough, so adding restrictions is premature.\r\n\r\n\r\n\r\n\r\n",
          "createdAt": "2020-04-24T16:47:23Z",
          "updatedAt": "2020-04-24T16:47:23Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Per the call today, we're closing this for now. We may revisit this later on if more implementation experience from the WG leads folks towards a restrictions on inner/outer variance.",
          "createdAt": "2020-04-27T21:51:17Z",
          "updatedAt": "2020-04-27T21:51:17Z"
        }
      ]
    },
    {
      "number": 229,
      "id": "MDU6SXNzdWU2MTEyODgwNDU=",
      "title": "Describe HRR cut-and-paste 1 in Security Considerations.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/229",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "chris-wood"
      ],
      "labels": [],
      "body": "<img width=\"909\" alt=\"Screen Shot 2020-05-02 at 3 33 05 PM\" src=\"https://user-images.githubusercontent.com/2172048/80893782-3fae8980-8c8a-11ea-8bca-cb5fc1e33685.png\">\r\n",
      "createdAt": "2020-05-02T22:33:24Z",
      "updatedAt": "2020-05-21T13:08:20Z",
      "closedAt": "2020-05-21T13:08:19Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Addressed in #234.",
          "createdAt": "2020-05-21T13:08:19Z",
          "updatedAt": "2020-05-21T13:08:19Z"
        }
      ]
    },
    {
      "number": 232,
      "id": "MDU6SXNzdWU2MTQzMjI5ODM=",
      "title": "Bikeshed: finalize on naming of \"ECHO\"",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/232",
      "state": "CLOSED",
      "author": "enygren",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "While cutsy, the name \"ECHO\" for \"Encrypted Client Hello\" seems like it could cause problems and significant confusion.  To those not actively involved in the working group, \"ECHO\" has very different connotations.  Some potential risks include:\r\n* Other IETF standards have some form of \"ECHO\" functionality.  When bouncing this question off someone else, they responded with \"TLS ECHO, like ICMP ECHO, except totally not\"\r\n* The immediate guess people may have on hearing about a TLS ECHO functionality would be to think \"oh, like to echo back a message for heartbeat purposes?\".  Given the potential risk for confusion with heartbeat (especially given \"Heartbleed\") this has some risk of giving TLS ECHO a bad rap from the start due to confusion.\r\n* This functionality is going to have high profile with product managers and perhaps even government regulators and public policy.  Applying a name that has confusing lay-connotations is going to muddle conversations.\r\n* This has a risk of confusion when used in other contexts.  For example, \"echoconfig\" as a SVCB parameter key has potential risk for confusing people reading the config and lacking context.\r\n* ECHO is going to be harder to do searches for, both in Internet and intranet search engines.\r\n\r\nJust calling it \"ECH\" or \"EHELLO\" may be safer?\r\n\r\n(If this changes, SVCB will also need to change the \"echoconfig\".)",
      "createdAt": "2020-05-07T20:27:33Z",
      "updatedAt": "2020-05-21T19:49:50Z",
      "closedAt": "2020-05-21T19:49:50Z",
      "comments": [
        {
          "author": "enygren",
          "authorAssociation": "NONE",
          "body": "One reason for \"EHELLO\" is that if we support Split Mode with the ClientHelloInner being TLS 1.2 then it also provides protection for the ServerHello as well.",
          "createdAt": "2020-05-07T20:31:28Z",
          "updatedAt": "2020-05-07T20:31:28Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "ETCH",
          "createdAt": "2020-05-07T21:46:15Z",
          "updatedAt": "2020-05-07T21:46:15Z"
        },
        {
          "author": "enygren",
          "authorAssociation": "NONE",
          "body": "ETCH == \"Encrypted TLS Client Hello\"?    (That also sounds like a fine option.)",
          "createdAt": "2020-05-07T21:47:52Z",
          "updatedAt": "2020-05-07T21:47:52Z"
        }
      ]
    },
    {
      "number": 233,
      "id": "MDU6SXNzdWU2MTUzNDQ4NDk=",
      "title": "Trial decryption after HelloRetryRequest",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/233",
      "state": "OPEN",
      "author": "ocheron",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "In a normal ECHO handshake with HelloRetryRequest there are 4 ClientHellos sent: ClientHelloOuter1, ClientHelloInner1, ClientHelloOuter2, ClientHelloInner2.\r\n\r\nEncryption of ClientHelloInner2 is bound to echo_hrr_key so the server must have the ECHOConfig used for ClientHelloInner1 in order to process ECHO the second time.\r\nAnd by the time the client receives encrypted handshake traffic it is not useful to signal if ClientHelloInner1 was successfully decrypted, what matters is to know if ECHO is globally successful or not.\r\n\r\nSo one aspect that I find not explained enough is whether the server replying with HRR should use ClientHelloInner1 in the transcript, or instead always takes ClientHelloOuter1 (data on the wire) regardless of the first decryption status. The ECHO status accept/reject can be conveyed based on distinction ClientHello2 inner/outer only.\r\n\r\nThis point impacts the number of transcripts the client may have to try, i.e. can be sure the combination (ClientHelloInner1, ClientHelloOuter2) is never valid.",
      "createdAt": "2020-05-10T08:39:16Z",
      "updatedAt": "2020-05-10T08:39:16Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 237,
      "id": "MDU6SXNzdWU2MjI5MTg3NDM=",
      "title": "Remove 1.3 from the title",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/237",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The design can apply to TLS 1.4 and beyond (presumably).",
      "createdAt": "2020-05-22T03:12:25Z",
      "updatedAt": "2020-05-26T21:19:26Z",
      "closedAt": "2020-05-26T21:19:25Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Done in #238.",
          "createdAt": "2020-05-26T21:19:25Z",
          "updatedAt": "2020-05-26T21:19:25Z"
        }
      ]
    }
  ],
  "pulls": [
    {
      "number": 1,
      "id": "MDExOlB1bGxSZXF1ZXN0MTg3NTg2MDE3",
      "title": "Text",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/1",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-05-11T22:49:19Z",
      "updatedAt": "2018-05-11T23:09:25Z",
      "closedAt": "2018-05-11T23:09:25Z",
      "mergedAt": "2018-05-11T23:09:25Z",
      "mergedBy": "ekr",
      "comments": [],
      "reviews": [],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "cdd930894881e8f1abab1c2d1e8e5b0107fe46b3",
      "headRepository": null,
      "headRefName": "master",
      "headRefOid": "ded62dd0faa173577a5f31c3fd80fce854464fd3",
      "mergeCommit": {
        "oid": "ded62dd0faa173577a5f31c3fd80fce854464fd3"
      }
    },
    {
      "number": 2,
      "id": "MDExOlB1bGxSZXF1ZXN0MTg3NTkwMjY5",
      "title": "Add assessment section",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/2",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-05-11T23:29:04Z",
      "updatedAt": "2018-05-11T23:41:58Z",
      "closedAt": "2018-05-11T23:41:58Z",
      "mergedAt": "2018-05-11T23:41:58Z",
      "mergedBy": "ekr",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTE5NjA1MDg1",
          "commit": {
            "abbreviatedOid": "74bd303"
          },
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "This is good. Added a few comments.",
          "createdAt": "2018-05-11T23:31:32Z",
          "updatedAt": "2018-05-11T23:33:50Z",
          "comments": [
            {
              "originalPosition": 73,
              "body": "Why is this a problem? You have a label?",
              "createdAt": "2018-05-11T23:31:33Z",
              "updatedAt": "2018-05-11T23:40:24Z"
            },
            {
              "originalPosition": 83,
              "body": "I think you should sharpen this point a bit. The argument I would make is that this is a property of the browser and the server, so it's not suspicious at all. Now, it's true that you need more clients to avoid *blocking* but if you're using a generic browser, there's nothing suspicious about running Safari, Firefox, etc.",
              "createdAt": "2018-05-11T23:33:09Z",
              "updatedAt": "2018-05-11T23:40:24Z"
            },
            {
              "originalPosition": 88,
              "body": "I don't think this is true, because the server's share is static.",
              "createdAt": "2018-05-11T23:33:19Z",
              "updatedAt": "2018-05-11T23:40:24Z"
            },
            {
              "originalPosition": 99,
              "body": "This is true, but I think it's worth pointing to the cleartext DNS for why that's not even needed.",
              "createdAt": "2018-05-11T23:33:37Z",
              "updatedAt": "2018-05-11T23:40:24Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTE5NjA1NTM0",
          "commit": {
            "abbreviatedOid": "74bd303"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-05-11T23:35:39Z",
          "updatedAt": "2018-05-11T23:35:39Z",
          "comments": [
            {
              "originalPosition": 73,
              "body": "Oh, yes, oops. I was forgot we said above just to fail open if there's a label mismatch.",
              "createdAt": "2018-05-11T23:35:39Z",
              "updatedAt": "2018-05-11T23:40:24Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTE5NjA1NjAy",
          "commit": {
            "abbreviatedOid": "74bd303"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-05-11T23:36:20Z",
          "updatedAt": "2018-05-11T23:36:20Z",
          "comments": [
            {
              "originalPosition": 88,
              "body": "I'm assuming a short TTL for these keys -- so maybe I'll just say not FS by usual definition, but window of exposure is bound by DNS RR TTL",
              "createdAt": "2018-05-11T23:36:20Z",
              "updatedAt": "2018-05-11T23:40:24Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTE5NjA1ODAz",
          "commit": {
            "abbreviatedOid": "74bd303"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-05-11T23:38:24Z",
          "updatedAt": "2018-05-11T23:38:24Z",
          "comments": [
            {
              "originalPosition": 99,
              "body": "Done.",
              "createdAt": "2018-05-11T23:38:24Z",
              "updatedAt": "2018-05-11T23:40:24Z"
            }
          ]
        }
      ],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "5dec6a11f91e314205d86de1d73b9fe0abe0ac26",
      "headRepository": null,
      "headRefName": "caw/assess",
      "headRefOid": "8ef656997e7a3f6c63047939757e9d410eaa2127",
      "mergeCommit": {
        "oid": "483739199977a81d5b6d379e8556e259bd7fc28b"
      }
    },
    {
      "number": 3,
      "id": "MDExOlB1bGxSZXF1ZXN0MTg3NTkxODI4",
      "title": "Cleartext DNS is A-OK.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/3",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-05-11T23:46:35Z",
      "updatedAt": "2018-05-11T23:57:25Z",
      "closedAt": "2018-05-11T23:57:25Z",
      "mergedAt": "2018-05-11T23:57:25Z",
      "mergedBy": "ekr",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTE5NjA2Nzk5",
          "commit": {
            "abbreviatedOid": "8bd1a4b"
          },
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-05-11T23:49:18Z",
          "updatedAt": "2018-05-11T23:49:22Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "I think I would phrase this slightly differently, namely that you can provide a per-domain name IP address. It's not the SNI that's published.\r\n\r\n\r\n\r\n",
              "createdAt": "2018-05-11T23:49:18Z",
              "updatedAt": "2018-05-11T23:54:25Z"
            }
          ]
        }
      ],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "483739199977a81d5b6d379e8556e259bd7fc28b",
      "headRepository": null,
      "headRefName": "caw/dns",
      "headRefOid": "02efa31d518f23d395cd20d41b5510f083097320",
      "mergeCommit": {
        "oid": "2a927e6f3884c74c155ca199e61b997d4089546b"
      }
    },
    {
      "number": 4,
      "id": "MDExOlB1bGxSZXF1ZXN0MTg3NTkzNzk3",
      "title": "Small rewrite",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/4",
      "state": "MERGED",
      "author": "ekr",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-05-12T00:10:45Z",
      "updatedAt": "2018-05-12T00:16:05Z",
      "closedAt": "2018-05-12T00:16:05Z",
      "mergedAt": "2018-05-12T00:16:05Z",
      "mergedBy": "ekr",
      "comments": [
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "maybe also point out that once you control DNS, getting a certificate is usually fairly easy",
          "createdAt": "2018-05-12T00:12:07Z",
          "updatedAt": "2018-05-12T00:12:07Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTE5NjA4ODI3",
          "commit": {
            "abbreviatedOid": "4f173e0"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-05-12T00:13:20Z",
          "updatedAt": "2018-05-12T00:13:20Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "I'd add that the attacker can also inject its own keys, which causes the client to encrypt the SNI to them.",
              "createdAt": "2018-05-12T00:13:20Z",
              "updatedAt": "2018-05-12T00:13:20Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTE5NjA4ODcx",
          "commit": {
            "abbreviatedOid": "4f173e0"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-05-12T00:14:03Z",
          "updatedAt": "2018-05-12T00:14:04Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "Maybe add: In fact, SNI encryption is less useful without encryption of DNS queries in transit via DoH or DPRIVE mechanisms.",
              "createdAt": "2018-05-12T00:14:04Z",
              "updatedAt": "2018-05-12T00:14:04Z"
            }
          ]
        }
      ],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "2a927e6f3884c74c155ca199e61b997d4089546b",
      "headRepository": "tlswg/draft-ietf-tls-esni",
      "headRefName": "cleartext_dns",
      "headRefOid": "4f173e07500acdd309f458950fd84b59e6d6c664",
      "mergeCommit": {
        "oid": "4f173e07500acdd309f458950fd84b59e6d6c664"
      }
    },
    {
      "number": 9,
      "id": "MDExOlB1bGxSZXF1ZXN0MTg3NjAzNTg4",
      "title": "Address MT's issues.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/9",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Instead of a Fronting SNI field, we should just re-use the Alt-Svc record, which already carries an SNI value to be used.",
      "createdAt": "2018-05-12T04:15:15Z",
      "updatedAt": "2018-05-12T15:12:12Z",
      "closedAt": "2018-05-12T15:12:12Z",
      "mergedAt": "2018-05-12T15:12:12Z",
      "mergedBy": "ekr",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTE5NjI1Mjk3",
          "commit": {
            "abbreviatedOid": "3002a0e"
          },
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-05-12T12:26:27Z",
          "updatedAt": "2018-05-12T12:27:12Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "I'm having trouble following this. Is this each record?",
              "createdAt": "2018-05-12T12:26:28Z",
              "updatedAt": "2018-05-12T13:06:58Z"
            },
            {
              "originalPosition": 15,
              "body": "This sentence seems ot just end.",
              "createdAt": "2018-05-12T12:26:57Z",
              "updatedAt": "2018-05-12T13:06:58Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTE5NjI2MDI2",
          "commit": {
            "abbreviatedOid": "3002a0e"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-05-12T13:04:33Z",
          "updatedAt": "2018-05-12T13:04:33Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "Missed period -- fixed now.",
              "createdAt": "2018-05-12T13:04:33Z",
              "updatedAt": "2018-05-12T13:06:58Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTE5NjI2MDU0",
          "commit": {
            "abbreviatedOid": "3002a0e"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-05-12T13:06:24Z",
          "updatedAt": "2018-05-12T13:06:24Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "Indeed, the sentence is confusing. I just removed it. The point I was trying to make is that if there are multiple IP addresses to choose from with multiple keys, and the server does not configure each of those addresses with the set of keys, the client might pick the wrong address/key combo.",
              "createdAt": "2018-05-12T13:06:24Z",
              "updatedAt": "2018-05-12T13:06:58Z"
            }
          ]
        }
      ],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "9da97156f4553c7f3424be53047099fe72328f47",
      "headRepository": null,
      "headRefName": "caw/issues",
      "headRefOid": "a6ee53b988d804d8fd8e368c39fd5566f53cdb73",
      "mergeCommit": {
        "oid": "a6ee53b988d804d8fd8e368c39fd5566f53cdb73"
      }
    },
    {
      "number": 11,
      "id": "MDExOlB1bGxSZXF1ZXN0MTg3NjE5Njkx",
      "title": "Simplify key schedule. Remove Nonce. Fixes #6",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/11",
      "state": "MERGED",
      "author": "ekr",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-05-12T12:43:35Z",
      "updatedAt": "2018-05-12T13:14:04Z",
      "closedAt": "2018-05-12T13:13:32Z",
      "mergedAt": "2018-05-12T13:13:32Z",
      "mergedBy": "ekr",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTE5NjI2MTcz",
          "commit": {
            "abbreviatedOid": "314f8e7"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-05-12T13:13:13Z",
          "updatedAt": "2018-05-12T13:13:14Z",
          "comments": [
            {
              "originalPosition": 53,
              "body": "This is an implementation detail, I think. If a client chooses to expand twice when it's not needed then that's their fault. We could simply state (in the other draft, or here) that \"if clients have computed Z for other purposes, an additional extraction is not needed.\"",
              "createdAt": "2018-05-12T13:13:14Z",
              "updatedAt": "2018-05-12T13:13:14Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTE5NjI2MTg1",
          "commit": {
            "abbreviatedOid": "314f8e7"
          },
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-05-12T13:14:04Z",
          "updatedAt": "2018-05-12T13:14:04Z",
          "comments": [
            {
              "originalPosition": 53,
              "body": "Sorry, I'm not worried about the implementation, but about whether we're guaranteeing key separation",
              "createdAt": "2018-05-12T13:14:04Z",
              "updatedAt": "2018-05-12T13:14:04Z"
            }
          ]
        }
      ],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "9da97156f4553c7f3424be53047099fe72328f47",
      "headRepository": "tlswg/draft-ietf-tls-esni",
      "headRefName": "simplify_keys",
      "headRefOid": "314f8e741554c4defb828f536bae8506d20bc3e2",
      "mergeCommit": {
        "oid": "c30baff03a7471998a775e9f18e25f3f4e8e7eb5"
      }
    },
    {
      "number": 12,
      "id": "MDExOlB1bGxSZXF1ZXN0MTg3NjI1NjQz",
      "title": "Don't allow bad labels",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/12",
      "state": "MERGED",
      "author": "ekr",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-05-12T15:15:00Z",
      "updatedAt": "2018-05-12T15:30:08Z",
      "closedAt": "2018-05-12T15:30:08Z",
      "mergedAt": "2018-05-12T15:30:08Z",
      "mergedBy": "ekr",
      "comments": [
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "@chris-wood ",
          "createdAt": "2018-05-12T15:15:19Z",
          "updatedAt": "2018-05-12T15:15:19Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTE5NjI5MDg0",
          "commit": {
            "abbreviatedOid": "1772724"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "LGTM!",
          "createdAt": "2018-05-12T15:25:25Z",
          "updatedAt": "2018-05-12T15:25:25Z",
          "comments": []
        }
      ],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "0a0d116d7ddcf73554597e4716573529ba8f31ce",
      "headRepository": "tlswg/draft-ietf-tls-esni",
      "headRefName": "fail_on_bad_label",
      "headRefOid": "1772724e8da753d3deacb4280a87f8ba91ba12de",
      "mergeCommit": {
        "oid": "eb9af6279dd98f92cfc627f52714b884581b7f89"
      }
    },
    {
      "number": 13,
      "id": "MDExOlB1bGxSZXF1ZXN0MTg3NjI2MzAw",
      "title": "Add padding to the encrypted SNI to avoid attacks based on length.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/13",
      "state": "MERGED",
      "author": "ekr",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "@chris-wood PTAL",
      "createdAt": "2018-05-12T15:29:57Z",
      "updatedAt": "2018-05-12T15:38:41Z",
      "closedAt": "2018-05-12T15:38:40Z",
      "mergedAt": "2018-05-12T15:38:40Z",
      "mergedBy": "ekr",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTE5NjI5MzIy",
          "commit": {
            "abbreviatedOid": "29c165f"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-05-12T15:34:38Z",
          "updatedAt": "2018-05-12T15:35:50Z",
          "comments": [
            {
              "originalPosition": 112,
              "body": "Should we send decrypt_error instead? (Thinking of POs here.)",
              "createdAt": "2018-05-12T15:34:38Z",
              "updatedAt": "2018-05-12T15:35:50Z"
            }
          ]
        }
      ],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "0a0d116d7ddcf73554597e4716573529ba8f31ce",
      "headRepository": "tlswg/draft-ietf-tls-esni",
      "headRefName": "obscure_length",
      "headRefOid": "29c165f147e794c4d266b7b635704ee97b5892a4",
      "mergeCommit": {
        "oid": "a37f5e34927438ee13fe7fa2622eaf9f5e84bad0"
      }
    },
    {
      "number": 16,
      "id": "MDExOlB1bGxSZXF1ZXN0MTg3NjMyODYz",
      "title": "Misc. fixes",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/16",
      "state": "MERGED",
      "author": "ghedo",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "A few fixes made while reading through.",
      "createdAt": "2018-05-12T18:00:04Z",
      "updatedAt": "2018-05-12T18:33:25Z",
      "closedAt": "2018-05-12T18:33:25Z",
      "mergedAt": "2018-05-12T18:33:25Z",
      "mergedBy": "ekr",
      "comments": [],
      "reviews": [],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "a37f5e34927438ee13fe7fa2622eaf9f5e84bad0",
      "headRepository": null,
      "headRefName": "fixes",
      "headRefOid": "a430e93215f6553185cae4e4e5c5241ce1ba32b4",
      "mergeCommit": {
        "oid": "ea9fc6d00233bad98d90fbb0b6246179359fe796"
      }
    },
    {
      "number": 18,
      "id": "MDExOlB1bGxSZXF1ZXN0MTg3NjM1MDYy",
      "title": "Add clarity to the DNS encoding section, require base64 encoding, and\u2026",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/18",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "\u2026 deal with TXT string limits.\r\n",
      "createdAt": "2018-05-12T18:53:41Z",
      "updatedAt": "2018-05-13T00:07:31Z",
      "closedAt": "2018-05-13T00:07:31Z",
      "mergedAt": "2018-05-13T00:07:31Z",
      "mergedBy": "ekr",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@huitema @ghedo please take a look.",
          "createdAt": "2018-05-12T18:56:01Z",
          "updatedAt": "2018-05-12T18:56:01Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@martinthomson @huitema updated based on your feedback -- please take a look!",
          "createdAt": "2018-05-12T23:49:40Z",
          "updatedAt": "2018-05-12T23:49:40Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTE5NjM3NjU1",
          "commit": {
            "abbreviatedOid": "12e87e0"
          },
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "The general idea looks good, but I am a bit concerned with the concatenation + reordering process, as in theory servers may return records in random order. On the other hand, RFC 4408 has been out for a long time, so maybe that's not really a problem in practice.",
          "createdAt": "2018-05-12T21:53:20Z",
          "updatedAt": "2018-05-12T21:55:42Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "I read the text in RFC 4408 and I am a bit concerned that this is one of those things that does not work in theory but does work in practice. In theory, when there are multiple records of the same type for the same name, DNS servers or recursive resolvers can return the records in whichever order they see fit. If they actually do that, the concatenation becomes unpredictable.",
              "createdAt": "2018-05-12T21:53:21Z",
              "updatedAt": "2018-05-12T23:54:12Z"
            },
            {
              "originalPosition": 30,
              "body": "At most one [each] ... TXT ESNI... Is that compatible with the idea that the string may be split over multiple concatenated records?",
              "createdAt": "2018-05-12T21:53:24Z",
              "updatedAt": "2018-05-12T23:54:12Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTE5NjM4OTg0",
          "commit": {
            "abbreviatedOid": "12e87e0"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-05-12T23:21:01Z",
          "updatedAt": "2018-05-12T23:23:02Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "Nit extra period after 3.1.3",
              "createdAt": "2018-05-12T23:21:01Z",
              "updatedAt": "2018-05-12T23:54:12Z"
            },
            {
              "originalPosition": 32,
              "body": "I think that you need to more directly address the notion that the anonymity set is the set of domains that share the same IP address.  That deserves a paragraph that includes this last sentence.",
              "createdAt": "2018-05-12T23:22:59Z",
              "updatedAt": "2018-05-12T23:54:12Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTE5NjM5MjYz",
          "commit": {
            "abbreviatedOid": "12e87e0"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-05-12T23:39:05Z",
          "updatedAt": "2018-05-12T23:39:06Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "Fixed.",
              "createdAt": "2018-05-12T23:39:06Z",
              "updatedAt": "2018-05-12T23:54:12Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTE5NjM5Mjc4",
          "commit": {
            "abbreviatedOid": "12e87e0"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-05-12T23:40:12Z",
          "updatedAt": "2018-05-12T23:40:12Z",
          "comments": [
            {
              "originalPosition": 30,
              "body": "Hmm, interesting. I didn't see records being concatenated. Do we think servers will offer up key sets that need to split up across records?",
              "createdAt": "2018-05-12T23:40:12Z",
              "updatedAt": "2018-05-12T23:54:12Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTE5NjM5Mjk0",
          "commit": {
            "abbreviatedOid": "12e87e0"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-05-12T23:41:47Z",
          "updatedAt": "2018-05-12T23:41:47Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "The text here suggests that we'd split up text within a single record, not across multiple records. Indeed, if the latter were the case, I don't think this would work.",
              "createdAt": "2018-05-12T23:41:47Z",
              "updatedAt": "2018-05-12T23:54:12Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTE5NjM5NTA5",
          "commit": {
            "abbreviatedOid": "674f746"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "That's more words than I expected, but they all seem useful.  LGTM.",
          "createdAt": "2018-05-13T00:01:03Z",
          "updatedAt": "2018-05-13T00:01:03Z",
          "comments": []
        }
      ],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "ea9fc6d00233bad98d90fbb0b6246179359fe796",
      "headRepository": null,
      "headRefName": "caw/encoding",
      "headRefOid": "674f746cf41dd33551002f080cc79919865eea94",
      "mergeCommit": {
        "oid": "a44aea22621347cef696c8fd1a210f92a43e1460"
      }
    },
    {
      "number": 21,
      "id": "MDExOlB1bGxSZXF1ZXN0MTg3NjgzODY0",
      "title": "Add Kazuho",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/21",
      "state": "MERGED",
      "author": "ekr",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "@kazuho: please double check",
      "createdAt": "2018-05-13T18:33:16Z",
      "updatedAt": "2018-05-13T22:01:12Z",
      "closedAt": "2018-05-13T22:01:01Z",
      "mergedAt": "2018-05-13T22:01:01Z",
      "mergedBy": "kazuho",
      "comments": [
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "Thank you very much!",
          "createdAt": "2018-05-13T22:01:12Z",
          "updatedAt": "2018-05-13T22:01:12Z"
        }
      ],
      "reviews": [],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "a44aea22621347cef696c8fd1a210f92a43e1460",
      "headRepository": "tlswg/draft-ietf-tls-esni",
      "headRefName": "add_kazuho",
      "headRefOid": "e78c4f36dc7d5f117727de1c0c8b52e79a669019",
      "mergeCommit": {
        "oid": "77a9cef4ba9de590a1cf327a655e10ce0df6d11d"
      }
    },
    {
      "number": 22,
      "id": "MDExOlB1bGxSZXF1ZXN0MTg3NzA3NzE5",
      "title": "add ESNIKeys.extensions",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/22",
      "state": "MERGED",
      "author": "kazuho",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "At the moment, there is no extensibility in ESNIKeys. That means that if we want to add additional attributes, we would be forced to define a new DNS record that gets queried simultaneously. I think we do not want to do that.\r\n\r\nHence the extensions field.\r\n\r\nThe text is tentative; please feel free to change in any ways.\r\n\r\nCloses #10.",
      "createdAt": "2018-05-14T02:36:58Z",
      "updatedAt": "2018-05-14T13:16:57Z",
      "closedAt": "2018-05-14T13:16:57Z",
      "mergedAt": "2018-05-14T13:16:57Z",
      "mergedBy": "chris-wood",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "LGTM.",
          "createdAt": "2018-05-14T13:15:38Z",
          "updatedAt": "2018-05-14T13:15:38Z"
        }
      ],
      "reviews": [],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "77a9cef4ba9de590a1cf327a655e10ce0df6d11d",
      "headRepository": "kazuho/draft-rescorla-tls-esni",
      "headRefName": "kazuho/extensions",
      "headRefOid": "e2362439b34c7e280bb2a9fee2152cbae55016f4",
      "mergeCommit": {
        "oid": "87f70eeeff775e26b57a92cb0d01586f0cf8f58c"
      }
    },
    {
      "number": 23,
      "id": "MDExOlB1bGxSZXF1ZXN0MTg3NzE1MDgy",
      "title": "client-side validation of ESNIKeys",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/23",
      "state": "MERGED",
      "author": "kazuho",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "I expect that the resistance against ESNIKeys will come from web-site owners worrying about ESNIKeys being additional source of service disruption.\r\n\r\nOne might argue that the probability of disruption becomes 2x because now two resource records (A and _esni) are involved instead of just one. One might argue that the probability is higher than that because there could be more issues with carrying large TXT records than carrying A records. One might argue that the probability is below 2x because the two records are transmitted through the same path.\r\n\r\nAnyways, these arguments are about the quantitative difference about the probability.\r\n\r\nI prefer having a qualitative guarantee, that assures that there would be no increase in the probability of service disruption assuming that the owner of the `_esni` record does not misconfigure the service.\r\n\r\nHaving a checksum and validity period fields that can be validated by the client provides such guarantee.\r\n\r\nChecksum provides protection against accidental corruption.\r\n\r\nValidity period provides protection against misconfiguration or bugs in the DNS servers. It acts as a protection against an outdated ESNIKeys sent by an out-of-sync authoritative server or a buggy resolver causing disruption.\r\n\r\nThe downside of having checksum and validity is that the additional payload (currently 20 bytes, I think we can minimize this to 10 bytes by removing `not_before` (it's not that needed) and changing the type of `not_after` from `uint64` to `uint48`), and that the client would be required to do the validation.\r\n\r\nBut I assume that having qualitative guarantee that the probability of service disruption remains the same is worth the effort.\r\n\r\nCloses #20.",
      "createdAt": "2018-05-14T04:02:16Z",
      "updatedAt": "2018-05-14T16:04:43Z",
      "closedAt": "2018-05-14T16:04:43Z",
      "mergedAt": "2018-05-14T16:04:43Z",
      "mergedBy": "chris-wood",
      "comments": [
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "@chris-wood The PR is now aligned with master. I think we should merge this and rebase #24 upon this regardless of what we end up with on the PR.",
          "createdAt": "2018-05-14T16:03:15Z",
          "updatedAt": "2018-05-14T16:03:15Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTE5ODMwOTA2",
          "commit": {
            "abbreviatedOid": "dfd9bc5"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2018-05-14T13:24:37Z",
          "updatedAt": "2018-05-14T13:24:45Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "While I think this is useful, it requires DNSSEC for this to be safe. Otherwise, a malicious recursive resolver could alter not_before or not_after to prevent a client from using the key as one normally would. It also seems redundant with the TTL field in the RR itself. @ekr thoughts?",
              "createdAt": "2018-05-14T13:24:38Z",
              "updatedAt": "2018-05-14T16:01:08Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTE5ODc2MjY3",
          "commit": {
            "abbreviatedOid": "dfd9bc5"
          },
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-05-14T15:05:55Z",
          "updatedAt": "2018-05-14T15:05:56Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "> a malicious recursive resolver could alter not_before or not_after to prevent a client from using the key as one normally would\r\n\r\nI do not think that as an issue, considering the fact that a malicious resolver can do anything including changing the A record or dropping the ESNIKeys entirely.\r\n\r\n> It also seems redundant with the TTL field in the RR itself.\r\n\r\nI do not think so.\r\n\r\nThe issue with TTL is that TTL is always relative to the time when the DNS authoritative server emits the record.\r\n\r\nConsider the case where the authoritative server and the TLS server getting out-of-sync.\r\n\r\nIf we have `not_after`, the servers can be deployed in the a way that it does not cause service disruption. What you need to do setup your system to always generate the ESNIKeys on the TLS server and push it to the authoritative server for distributing it. Then, when the two servers become brain-split, the _esni resource records would become considered as invalid by the clients.\r\n\r\nBut if we do not have `not_after`, the _esni record that the authoritative server will continue to be considered valid, because TTL is set every time the authoritative server emits the record.",
              "createdAt": "2018-05-14T15:05:56Z",
              "updatedAt": "2018-05-14T16:01:08Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTE5ODc5NTYw",
          "commit": {
            "abbreviatedOid": "dfd9bc5"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-05-14T15:12:29Z",
          "updatedAt": "2018-05-14T15:12:30Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "Fair points! You've convinced me this is needed.",
              "createdAt": "2018-05-14T15:12:30Z",
              "updatedAt": "2018-05-14T16:01:08Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTE5OTAxNzY5",
          "commit": {
            "abbreviatedOid": "ca6c490"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-05-14T16:02:06Z",
          "updatedAt": "2018-05-14T16:02:06Z",
          "comments": []
        }
      ],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "16b8a6ff244862647683be24fcded2ab8b5657e9",
      "headRepository": "kazuho/draft-rescorla-tls-esni",
      "headRefName": "kazuho/client-side-validation",
      "headRefOid": "ca6c490833165bf920e6c05af2ebb57c259549a0",
      "mergeCommit": {
        "oid": "3ad81cc1e3a141ca9ad90c5d184773a25cca4af8"
      }
    },
    {
      "number": 24,
      "id": "MDExOlB1bGxSZXF1ZXN0MTg3ODA0MzEx",
      "title": "prevent downgrade attack",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/24",
      "state": "MERGED",
      "author": "kazuho",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "In ESNI, the server offers a list of ECDH keys and the client selects one of them. However, there seems to be nothing that prevents a downgrade attack.\r\n\r\nThis PR adds the protection, by sending the list of the Named Groups being offered by ESNIKeys in the EncryptedSNI extension.\r\n\r\nThe bonus is that the size of ESNIKeys becomes smaller when more than one keys are offered (because we now only send one label per the entire key set).",
      "createdAt": "2018-05-14T12:01:06Z",
      "updatedAt": "2018-05-17T13:08:17Z",
      "closedAt": "2018-05-17T13:08:17Z",
      "mergedAt": "2018-05-17T13:08:17Z",
      "mergedBy": "ekr",
      "comments": [
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "> I don't think the NamedGroupList is necessary to prevent downgrade attacks.\r\n\r\nConsider the case where the authoritative server sends an _esni record containing X448 and X25519 keys. Malicious middlebox rewrites the _esni record to only contain the X25519 key. The client will accept the X25519 key and use that for the TLS handshake.\r\n\r\nI think that is not prevented now, and that we need to prevent it.",
          "createdAt": "2018-05-14T15:08:44Z",
          "updatedAt": "2018-05-14T15:08:44Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "@kazuho: thanks for identifying this. I agree it's a real issue and wish I'd caught it before :(\r\n\r\nThinking about defenses, do you think it might make more sense to ditch the label and instead just carry a hash of the record? Then we could guarantee that it wasn't changed more easily? OTOH, that would preclude self-encryption of the ESNI Key....",
          "createdAt": "2018-05-14T15:11:47Z",
          "updatedAt": "2018-05-14T15:11:47Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@ekr Servers might want more than one label per record to allow for migration. Why don't we have clients send the hash of the ESNKey structure for the label it chooses? The server could also include that in full in place of the truncated hash.",
          "createdAt": "2018-05-14T15:14:24Z",
          "updatedAt": "2018-05-14T15:14:24Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@kazuho I meant that we don't need to send the NamedGroupsList for mitigation -- we could send something else, e.g., the ESNIKey hash.",
          "createdAt": "2018-05-14T15:15:48Z",
          "updatedAt": "2018-05-14T15:15:48Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "> Thinking about defenses, do you think it might make more sense to ditch the label and instead just carry a hash of the record? Then we could guarantee that it wasn't changed more easily? OTOH, that would preclude self-encryption of the ESNI Key....\r\n\r\n@ekr The other issue is that you then need to consider negotiating the hash algorithm to be used. I did not want to deal with that and therefore went for the Named Group list.\r\n\r\n@chris-wood Thank you for the clarification. I think the paragraph right above is my answer.",
          "createdAt": "2018-05-14T15:18:19Z",
          "updatedAt": "2018-05-14T15:19:09Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@kazuho The checksum you propose is already computed with SHA256 -- why do you think this is something we ought to negotiate? ",
          "createdAt": "2018-05-14T15:27:43Z",
          "updatedAt": "2018-05-14T15:27:43Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "@chris-wood The checksum is only 32-bits and it's for detecting errors, not preventing attacks.\r\n\r\nNamed Group selection is a cryptographic property of the TLS handshake and it needs to be protected by the digest algorithm of the negotiated cipher-suite. It is either a full-length SHA-256 or SHA-384 at the moment, but could change in the future.",
          "createdAt": "2018-05-14T15:34:11Z",
          "updatedAt": "2018-05-14T15:34:11Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@kazuho The intent of this is to convey to the server that the client saw the right set of options before it chose its key. We don't need to consider any properties of NamedGroup selection with TLS to do so. And picking a suitable cryptographic hash function here is good enough. I really don't think we need agility here. \r\n\r\nAlso, I wasn't suggesting the client echo the 32bit hash found in the record. It should send the full SHA256 hash. ",
          "createdAt": "2018-05-14T15:36:01Z",
          "updatedAt": "2018-05-14T15:37:32Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Oh, also, what if we decide to add an extension that could influence how clients choose keys? Wouldn't we want downgrade protection for that, too? (A hash would work for that, whereas echoing the NamedGroup list would not.)",
          "createdAt": "2018-05-14T15:39:56Z",
          "updatedAt": "2018-05-14T15:39:56Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "My understanding is as follows:\r\n* In TLS 1.3, client offers the Named Groups and server selects one. It is protected by the digest algorithm of the negotiated cipher-suite.\r\n* In TLS 1.3 + ESNI, server offers the Named Groups and client selects one.\r\n\r\nTherefore, I assume that which Named Groups we offered needs to be protected by the digest algorithm of the negotiated cipher-suite, or else we are changing the security properties of TLS 1.3.\r\n\r\n> Oh, also, what if we decide to add an extension that could influence how clients choose keys? Wouldn't we want downgrade protection for that, too? (A hash would work for that, whereas echoing the NamedGroup list would not.)\r\n\r\nI agree. So to me the choice seems to be between a) choose a specific solution (i.e. send Named Group list) or b) add digest algorithm negotiation and send the hash value.\r\n\r\nI went for a, but I won't argue hardly against b.",
          "createdAt": "2018-05-14T15:43:47Z",
          "updatedAt": "2018-05-14T15:44:02Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "Well, we could just use the hash associated with the cipher suite, no?\n\nOn Mon, May 14, 2018 at 8:39 AM, Christopher Wood <notifications@github.com>\nwrote:\n\n> Oh, also, what if we decide to add an extension that could influence how\n> clients choose keys? Wouldn't we want downgrade protection for that, too?\n> (A hash would work for that, whereas echoing the NamedGroup list would not.)\n>\n> \u2014\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/ekr/draft-rescorla-tls-esni/pull/24#issuecomment-388862886>,\n> or mute the thread\n> <https://github.com/notifications/unsubscribe-auth/ABD1offG-C6SQ7_u_hTtaxaKcdOw36wYks5tyaVNgaJpZM4T9qTj>\n> .\n>\n",
          "createdAt": "2018-05-14T15:44:37Z",
          "updatedAt": "2018-05-14T15:44:37Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "> Well, we could just use the hash associated with the cipher suite, no?\r\n\r\n@ekr That's possible, but then the server needs to offer a list of hash algorithms that it understands in ESNIKeys, or the client needs to send hash digests for all the cipher-suites it offers.",
          "createdAt": "2018-05-14T15:48:15Z",
          "updatedAt": "2018-05-14T15:48:15Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@kazuho I don't think that's necessary. We can assume SHA256 or some other MTI hash function for this to work. \r\n\r\nIn the interest of future proofing, let's use a hash. I care much less about agility for the algorithm in question.",
          "createdAt": "2018-05-14T15:49:30Z",
          "updatedAt": "2018-05-14T15:49:30Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "> I don't think that's necessary. We can assume SHA256 or some other MTI hash function for this to work.\r\n\r\nAssuming that is true, I am happy to go for using hash. The primary reason is that we can remove `label` and use the hash value as the key to identify the ESNIKeys record that the client used.\r\n\r\nOTOH, I am still not convinced why we do not need to negotiate the hash algorithm, especially when we are talking about the possibility of transferring additional extensions in the future that will be under the same protection. But I am not a crypto person and I could well be wrong, especially when it is midnight here.\r\n\r\nAnyways thank you very much for your quick response and for quickly merging the other PR. This PR is now in sync with master. Please feel free to use this as a basis of creating a PR that implements hash-based protection, if the current text looks worth enough.",
          "createdAt": "2018-05-14T16:14:33Z",
          "updatedAt": "2018-05-14T16:14:33Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Interesting point about using the hash as the label, though it might help to keep the label in the event that we come up with another way to publish ESNI keys. \r\n\r\nRegarding negotiation, I think SHA256 is sufficient for now and the future. Negotiating yet another algorithm seems like unnecessary complexity here. I can take a stab at writing that text, though I think what you have here is nearly there.",
          "createdAt": "2018-05-14T16:18:47Z",
          "updatedAt": "2018-05-14T16:18:47Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "Sorry, I'm confused: the DNS record contains a list oc cipher suites, each of which is associated with a hash. The client chooses one to use to encrypt the SNI. Why can't that be the one you use to hash the ESNIKeys record",
          "createdAt": "2018-05-14T19:50:36Z",
          "updatedAt": "2018-05-14T19:50:36Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@ekr That'd work fine, I just think it's unnecessary here.",
          "createdAt": "2018-05-14T19:57:09Z",
          "updatedAt": "2018-05-14T19:57:09Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "So there's the argument that always using SHA-256 should be fine, and there's the argument that that the cipher-suites list can sent in ESNIKeys to solve the issue.\r\n\r\nI disagree to both. I have already explained why I think using SHA256 always is not fine. Let me explain why I think sending cipher-suites list in ESNIKeys is not fine.\r\n\r\n@ekr Traditionally, we have allowed different cipher-suites to be selected depending on the value of SNI. This becomes an even more important property in the ESNI proposal, because we split the server into fronting server and hidden server. Cipher-suite selection is a negotiation between the client and the hidden server, whereas the ESNIKeys is a key-exchange between the client and the fronting server.\r\n\r\nTherefore, we cannot / should not use ESNIKeys as a conveyer of cipher-suite negotiation.\r\n\r\nConsidering that we have disagreement on the how we can uses hashes, maybe it is a good idea to merge this as-is to fix the security hole, and get back to do the improvements later on if necessary. I thought that we wanted to submit this soon.",
          "createdAt": "2018-05-14T22:42:29Z",
          "updatedAt": "2018-05-14T22:42:29Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@kazuho The ciphersuite that's sent by the client in the EncryptedSNI extension only applies to that extension, not to the rest of the handshake or data, right? ",
          "createdAt": "2018-05-14T22:51:33Z",
          "updatedAt": "2018-05-14T22:51:33Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "@chris-wood Ah! That's correct. We now have two cipher-suites. I am fine with using the cipher-suite then.",
          "createdAt": "2018-05-14T22:58:23Z",
          "updatedAt": "2018-05-14T22:58:23Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Cool -- I'll propose some text. :-)\r\n",
          "createdAt": "2018-05-14T22:59:36Z",
          "updatedAt": "2018-05-14T22:59:36Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "Applied @chris-wood's patch that changes the protection from using a list of Named Groups to using a digest specified by the cipher-suite.",
          "createdAt": "2018-05-15T20:44:35Z",
          "updatedAt": "2018-05-15T20:44:35Z"
        },
        {
          "author": "kontaxis",
          "authorAssociation": "NONE",
          "body": "record_digest is sent together with encrypted_sni in EncryptedSNI which is supposed to be the sensitive information you want to protect from a downgrade attack.\r\n\r\nSo assuming there is a downgrade attack (I'm guessing you get bad key information from the DNS record) the client falls for it, sends the ESNI in a way that allows it to be compromised, and also sends the hash for the server to check whether an attack is going on.\r\n\r\nFronting Server Behavior text says \"If the EncryptedSNI.record_digest value does not match the cryptographic hash of the associated ENSIKeys structure, it MUST abort the connection\"\r\n\r\nBy the time the server realizes the hash is incorrect and drops the connection the ESNI has already been sent over the wire by the client. (And the adversary has intercepted it) So what's the benefit of dropping the connection at that point?\r\n\r\n\r\nAs a side-note, can you explain the specific downgrade attacks you have in mind? My understanding is that the threat here is learning the value of SNI. If you are able to tamper with the DNS record then by definition you know (or can learn) the client's query for the domain name. Why would you need to attack the key material and try to decrypt the ESNI? And on the other hand, if you don't have r/w access to the DNS records, how can you carry out a downgrade attack?",
          "createdAt": "2018-05-16T01:39:51Z",
          "updatedAt": "2018-05-16T01:39:51Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "> By the time the server realizes the hash is incorrect and drops the connection the ESNI has already been sent over the wire by the client. (And the adversary has intercepted it) So what's the benefit of dropping the connection at that point?\r\n\r\nThat's a good question.\r\n\r\nThe issue here is the Named Group that is being selected for ESNI protection key will also be used for negotiating the handshake. So the TLS handshake gets compromised (and that is what we are calling downgrade attack here).\r\n\r\nPlease refer to the first paragraph for https://github.com/ekr/draft-rescorla-tls-esni/pull/24#issuecomment-388864250.",
          "createdAt": "2018-05-16T03:24:29Z",
          "updatedAt": "2018-05-16T03:27:03Z"
        },
        {
          "author": "kontaxis",
          "authorAssociation": "NONE",
          "body": "> The issue here is the Named Group that is being selected for ESNI protection key will also be used for negotiating the handshake. So the TLS handshake gets compromised (and that is what we are calling downgrade attack here).\r\n\r\nCan we treat the ESNI key derivation and TLS key derivation as separate processes?\r\n\r\nSeems like the reason we need to protect against downgrade attacks is because we are reusing the (potentially poisoned) ESNIKeys KeyShareEntry structure in the TLS key schedule.\r\n\r\nIf we were to limit its use to just ESNI key derivation would we still need to protect against downgrade attacks?",
          "createdAt": "2018-05-16T04:03:13Z",
          "updatedAt": "2018-05-16T04:03:13Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "> Can we treat the ESNI key derivation and TLS key derivation as separate processes?\r\n\r\nMy understanding is that that is possible, and then we do not need to send the digest value of the ESNIKeys structure assuming that we do not add extensions that need downgrade protection.\r\n\r\nHowever, that would require the client to send and generate one more ECDH key, as well as increasing the probability of HRR due to group mismatch.\r\n\r\nTo put it another way, the approach used in this PR is on par with the amount of the data transmitted (the size of the digest and the ECDH key are roughly equal), has the possibility of cutting a round-trip, requires less CPU cost.",
          "createdAt": "2018-05-17T02:20:52Z",
          "updatedAt": "2018-05-17T02:20:52Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTE5ODI1ODI1",
          "commit": {
            "abbreviatedOid": "5013603"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "I'm not sure this change is needed to prevent the attack in question. ",
          "createdAt": "2018-05-14T13:11:54Z",
          "updatedAt": "2018-05-14T13:13:29Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "This makes it so that each label maps to a set of keys, which was not the original intent. We want there to be a 1-1 mapping between label and key, as that allows a server to abort a connection with illegal_parameter if there's a label mismatch, i.e., if a client offers a label that the server does not recognize. ",
              "createdAt": "2018-05-14T13:11:54Z",
              "updatedAt": "2018-05-15T22:44:46Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTE5ODQxNTU0",
          "commit": {
            "abbreviatedOid": "5013603"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-05-14T13:50:27Z",
          "updatedAt": "2018-05-14T13:50:28Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "Please disregard! I did not read your comments in #19. The (label, group) => key mapping seems plausible. Though I don't think the NamedGroupList is necessary to prevent downgrade attacks.",
              "createdAt": "2018-05-14T13:50:27Z",
              "updatedAt": "2018-05-15T22:44:46Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTIwNDMzNzg3",
          "commit": {
            "abbreviatedOid": "f95eb78"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "This LGTM. @ekr, PTAL when you have time.",
          "createdAt": "2018-05-15T22:11:00Z",
          "updatedAt": "2018-05-15T22:11:00Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTIwNDM5ODUw",
          "commit": {
            "abbreviatedOid": "f95eb78"
          },
          "author": "ghedo",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-05-15T22:36:44Z",
          "updatedAt": "2018-05-15T22:36:45Z",
          "comments": [
            {
              "originalPosition": 42,
              "body": "What is this struct used for?",
              "createdAt": "2018-05-15T22:36:45Z",
              "updatedAt": "2018-05-15T22:44:46Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTIwNDQxNjY0",
          "commit": {
            "abbreviatedOid": "f55f9c3"
          },
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-05-15T22:45:25Z",
          "updatedAt": "2018-05-15T22:45:25Z",
          "comments": [
            {
              "originalPosition": 42,
              "body": "Nice catch! We no longer need it. Addressed in f55f9c3.",
              "createdAt": "2018-05-15T22:45:25Z",
              "updatedAt": "2018-05-15T22:45:25Z"
            }
          ]
        }
      ],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "3ad81cc1e3a141ca9ad90c5d184773a25cca4af8",
      "headRepository": "kazuho/draft-rescorla-tls-esni",
      "headRefName": "kazuho/one-key-per-group",
      "headRefOid": "f55f9c31735eba8fcf04b8e2110966e0dcafa7a4",
      "mergeCommit": {
        "oid": "6276955dbfee725e5db060d38d66cd479d8acf58"
      }
    },
    {
      "number": 26,
      "id": "MDExOlB1bGxSZXF1ZXN0MTg3ODExNTYw",
      "title": "clarify that limitation of hash-based protection",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/26",
      "state": "MERGED",
      "author": "kazuho",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The approach does not work if the mapping between the fronting server and the hidden server contains a wildcard.",
      "createdAt": "2018-05-14T12:31:08Z",
      "updatedAt": "2018-05-14T13:17:38Z",
      "closedAt": "2018-05-14T13:17:38Z",
      "mergedAt": "2018-05-14T13:17:38Z",
      "mergedBy": "chris-wood",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "LGTM!",
          "createdAt": "2018-05-14T13:05:17Z",
          "updatedAt": "2018-05-14T13:05:25Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTE5ODIzNDI3",
          "commit": {
            "abbreviatedOid": "ffc7972"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-05-14T13:05:07Z",
          "updatedAt": "2018-05-14T13:05:07Z",
          "comments": []
        }
      ],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "77a9cef4ba9de590a1cf327a655e10ce0df6d11d",
      "headRepository": "kazuho/draft-rescorla-tls-esni",
      "headRefName": "kazuho/hash-based-vs-wildcard-delegation",
      "headRefOid": "ffc797263c950cb44cfd5c199f8f55c57209598f",
      "mergeCommit": {
        "oid": "16b8a6ff244862647683be24fcded2ab8b5657e9"
      }
    },
    {
      "number": 31,
      "id": "MDExOlB1bGxSZXF1ZXN0MTg3OTY2MTM4",
      "title": "Clarify requirements for domains with multiple A, AAAA, ... reconrds",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/31",
      "state": "MERGED",
      "author": "ghedo",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "See #29 ",
      "createdAt": "2018-05-14T22:17:28Z",
      "updatedAt": "2018-05-14T22:50:00Z",
      "closedAt": "2018-05-14T22:50:00Z",
      "mergedAt": "2018-05-14T22:50:00Z",
      "mergedBy": "chris-wood",
      "comments": [
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "This looks good to me.\r\n\r\nClarifying the requirements rather than specifying how to act makes more sense here.\r\n\r\nFWIW, I thought the intent of the original text was to encourage _not_ having ESNIKeys shared between multiple hosts whenever possible. This change loses that property. But anyways, that is mentioned in the appendix. Hence my :+1: to the PR.",
          "createdAt": "2018-05-14T22:48:37Z",
          "updatedAt": "2018-05-14T22:48:37Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTIwMDMyMzMy",
          "commit": {
            "abbreviatedOid": "103b04c"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-05-14T22:27:31Z",
          "updatedAt": "2018-05-14T22:49:55Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "The ALTSVC records don't matter as much here, and probably shouldn't be bound to the MUST. The rest LGTM.",
              "createdAt": "2018-05-14T22:27:31Z",
              "updatedAt": "2018-05-14T22:49:55Z"
            }
          ]
        }
      ],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "3ad81cc1e3a141ca9ad90c5d184773a25cca4af8",
      "headRepository": null,
      "headRefName": "mulitple_records",
      "headRefOid": "103b04c10bfa6c946c7b290b13a5365661f0d71a",
      "mergeCommit": {
        "oid": "e19b8088bb5e81983c9b279614766cc8fa7839bf"
      }
    },
    {
      "number": 36,
      "id": "MDExOlB1bGxSZXF1ZXN0MTg4MjU3MTU1",
      "title": "normative reference to RFC 4408",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/36",
      "state": "MERGED",
      "author": "kazuho",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Lack of the specifier (`!`, `?`) was causing a build error when trying to build the HTML.",
      "createdAt": "2018-05-15T21:11:54Z",
      "updatedAt": "2018-05-15T22:09:55Z",
      "closedAt": "2018-05-15T22:09:55Z",
      "mergedAt": "2018-05-15T22:09:55Z",
      "mergedBy": "chris-wood",
      "comments": [],
      "reviews": [],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "e19b8088bb5e81983c9b279614766cc8fa7839bf",
      "headRepository": "kazuho/draft-rescorla-tls-esni",
      "headRefName": "kazuho/normative-reference-to-rfc4408",
      "headRefOid": "279d79a0697d792288df0054161568c76fe5a87e",
      "mergeCommit": {
        "oid": "6ba58db63026fed2bcbabe3290e2af451ee6f5bf"
      }
    },
    {
      "number": 43,
      "id": "MDExOlB1bGxSZXF1ZXN0MTg4ODMxMDY2",
      "title": "Remove `label`",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/43",
      "state": "MERGED",
      "author": "kazuho",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Now that #24 has been merged, label seems to be an unnecessary complication.\r\n\r\n* label has no actual use on the client\r\n* because labels cannot collide, the key generator needs to either keep some state across all invocations (you need a trustable store), or generate a UUID (it's just a random junk) to be used as a label\r\n* a TLS server is required to at first compare the label and then check the digest.\r\n\r\nThese three issues go away if we eliminate label. Key generators do not need to care about uniqueness. TLS servers can just look for the matching digest and that's it.\r\n\r\nNote that a server operator can still associate an identifier to the ESNIKeys structure for internal use. The private key will be kept in relation to the structure anyways. So having a private identifier does not complicate things at all.",
      "createdAt": "2018-05-17T18:59:43Z",
      "updatedAt": "2018-05-21T02:17:03Z",
      "closedAt": "2018-05-21T02:17:03Z",
      "mergedAt": "2018-05-21T02:17:02Z",
      "mergedBy": "ekr",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTIxMTg4MDY2",
          "commit": {
            "abbreviatedOid": "b5ce410"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "LGMT -- I much prefer content-based identifiers to labels. ",
          "createdAt": "2018-05-17T19:42:22Z",
          "updatedAt": "2018-05-17T19:42:33Z",
          "comments": []
        }
      ],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "6276955dbfee725e5db060d38d66cd479d8acf58",
      "headRepository": "kazuho/draft-rescorla-tls-esni",
      "headRefName": "kazuho/no-label",
      "headRefOid": "b5ce41040b3f28706ae2f4aa99980e1f705d2e32",
      "mergeCommit": {
        "oid": "1e1a8ffcc57a616ab418e3097f583da96ce40f42"
      }
    },
    {
      "number": 44,
      "id": "MDExOlB1bGxSZXF1ZXN0MTg4ODQ1MzM3",
      "title": "Remove reference to ALTSVC",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/44",
      "state": "MERGED",
      "author": "ghedo",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #34\r\n\r\nAlso see https://github.com/ekr/draft-rescorla-tls-esni/pull/31#discussion_r188117285",
      "createdAt": "2018-05-17T19:59:40Z",
      "updatedAt": "2018-05-17T20:29:24Z",
      "closedAt": "2018-05-17T20:29:24Z",
      "mergedAt": "2018-05-17T20:29:24Z",
      "mergedBy": "chris-wood",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "LGTM -- thanks!",
          "createdAt": "2018-05-17T20:29:20Z",
          "updatedAt": "2018-05-17T20:29:20Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTIxMjAzNzA4",
          "commit": {
            "abbreviatedOid": "46b519f"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-05-17T20:29:07Z",
          "updatedAt": "2018-05-17T20:29:07Z",
          "comments": []
        }
      ],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "6276955dbfee725e5db060d38d66cd479d8acf58",
      "headRepository": null,
      "headRefName": "no-altsvc",
      "headRefOid": "46b519f3105f06796ef8c5dee7d2987179556a52",
      "mergeCommit": {
        "oid": "67ca02fdc6be26906aa401ad8e6a68f839c33a5d"
      }
    },
    {
      "number": 45,
      "id": "MDExOlB1bGxSZXF1ZXN0MTg5MjU5OTIw",
      "title": "Tone down Fronting Mode",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/45",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "@ghedo, PTAL! I tried Transparent mode, though this seemed subjectively better at the time. I'm happy to be convinced otherwise.",
      "createdAt": "2018-05-20T23:59:08Z",
      "updatedAt": "2018-05-21T00:08:27Z",
      "closedAt": "2018-05-21T00:08:27Z",
      "mergedAt": "2018-05-21T00:08:27Z",
      "mergedBy": "ekr",
      "comments": [],
      "reviews": [],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "67ca02fdc6be26906aa401ad8e6a68f839c33a5d",
      "headRepository": null,
      "headRefName": "caw/nix-fronting",
      "headRefOid": "5b49eeb30048f04acff1fbcc4cfe74bce5111261",
      "mergeCommit": {
        "oid": "14cc61eec9b80485d1356857b20c356a1eda0b23"
      }
    },
    {
      "number": 46,
      "id": "MDExOlB1bGxSZXF1ZXN0MTg5NDk3Mzg4",
      "title": "add a missing \"and\"",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/46",
      "state": "MERGED",
      "author": "reaperhulk",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Just a trivial fix \ud83d\ude04 ",
      "createdAt": "2018-05-21T21:50:35Z",
      "updatedAt": "2018-05-21T21:51:29Z",
      "closedAt": "2018-05-21T21:51:29Z",
      "mergedAt": "2018-05-21T21:51:29Z",
      "mergedBy": "chris-wood",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTIxOTU5NjM3",
          "commit": {
            "abbreviatedOid": "1a8b50a"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-05-21T21:51:24Z",
          "updatedAt": "2018-05-21T21:51:24Z",
          "comments": []
        }
      ],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "1e1a8ffcc57a616ab418e3097f583da96ce40f42",
      "headRepository": "reaperhulk/draft-rescorla-tls-esni",
      "headRefName": "patch-1",
      "headRefOid": "1a8b50a4e7240902024dcbdf753db69e34b07605",
      "mergeCommit": {
        "oid": "dd379d3031f72b6137d2bbee6d067d0787187b39"
      }
    },
    {
      "number": 48,
      "id": "MDExOlB1bGxSZXF1ZXN0MTkwNDYwNjkw",
      "title": "Add text regarding padding of wildcard delegations, and pad Certificate messages using padding(21)",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/48",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-05-25T01:32:18Z",
      "updatedAt": "2018-06-16T01:49:21Z",
      "closedAt": "2018-06-12T17:28:51Z",
      "mergedAt": "2018-06-12T17:28:51Z",
      "mergedBy": "ekr",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTIzMjQ4MDY4",
          "commit": {
            "abbreviatedOid": "74fc57e"
          },
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Thank you for working on this! LGTM aside from the two comments shown below.",
          "createdAt": "2018-05-25T05:30:19Z",
          "updatedAt": "2018-05-25T05:35:11Z",
          "comments": [
            {
              "originalPosition": 64,
              "body": "Shouldn't we pad the Certificate message so that it would become as large as the largest Certificate message that ~~would be offered from the server's IP address~~ is covered by the same ESNI key?\r\n\r\nThe same goes for the provision in the Split Mode.",
              "createdAt": "2018-05-25T05:30:19Z",
              "updatedAt": "2018-06-12T17:27:03Z"
            },
            {
              "originalPosition": 27,
              "body": "Considering the fact that the distribution of the ESNI keys is not limited to DNS, it might be worth specifying that the 256 chars limitation is specific to when DNS is being used; e.g. \"If the server supports wildcard names *resolved by DNS*\".",
              "createdAt": "2018-05-25T05:34:24Z",
              "updatedAt": "2018-06-12T17:27:03Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTIzMzU1MDcy",
          "commit": {
            "abbreviatedOid": "74fc57e"
          },
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-05-25T12:38:57Z",
          "updatedAt": "2018-05-25T12:39:03Z",
          "comments": [
            {
              "originalPosition": 64,
              "body": "I agree with what @kazuho says here. It's not straightforward.\r\n\r\nit's worth noting that this is one case in which random padding might be of some value, because the attacker doesn't know which connections correspond to the same SNI, and therefore can't do simple averageing.",
              "createdAt": "2018-05-25T12:38:57Z",
              "updatedAt": "2018-06-12T17:27:03Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTIzNDMxMTM4",
          "commit": {
            "abbreviatedOid": "74fc57e"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-05-25T16:10:12Z",
          "updatedAt": "2018-05-25T16:10:13Z",
          "comments": [
            {
              "originalPosition": 64,
              "body": "@kazuho I like it -- that's more precise. I'll update accordingly.",
              "createdAt": "2018-05-25T16:10:12Z",
              "updatedAt": "2018-06-12T17:27:03Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTIzNDMxMzAx",
          "commit": {
            "abbreviatedOid": "74fc57e"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-05-25T16:10:45Z",
          "updatedAt": "2018-05-25T16:10:45Z",
          "comments": [
            {
              "originalPosition": 27,
              "body": "\ud83d\udc4d ",
              "createdAt": "2018-05-25T16:10:45Z",
              "updatedAt": "2018-06-12T17:27:03Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTIzNTQ4ODM5",
          "commit": {
            "abbreviatedOid": "74fc57e"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-05-26T06:10:35Z",
          "updatedAt": "2018-05-26T06:10:35Z",
          "comments": [
            {
              "originalPosition": 27,
              "body": "\ud83d\udc4d ",
              "createdAt": "2018-05-26T06:10:35Z",
              "updatedAt": "2018-06-12T17:27:03Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTIzNTkwMDg2",
          "commit": {
            "abbreviatedOid": "e10707d"
          },
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-05-27T17:10:22Z",
          "updatedAt": "2018-05-27T17:10:25Z",
          "comments": [
            {
              "originalPosition": 65,
              "body": "Why do you think we should use this rather than pad at the record layer?",
              "createdAt": "2018-05-27T17:10:22Z",
              "updatedAt": "2018-06-12T17:27:03Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTIzNTkwOTkw",
          "commit": {
            "abbreviatedOid": "e10707d"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-05-27T17:51:20Z",
          "updatedAt": "2018-05-27T17:51:20Z",
          "comments": [
            {
              "originalPosition": 65,
              "body": "IIUC one could pad Certificate messages offline, if you wanted. One could also pad at the record later. I\u2019ll just note one or the other. ",
              "createdAt": "2018-05-27T17:51:20Z",
              "updatedAt": "2018-06-12T17:27:03Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTI4MDY3MDEw",
          "commit": {
            "abbreviatedOid": "3d1c6d4"
          },
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Sorry, I missed the padding thing, so you'll need to adjust",
          "createdAt": "2018-06-12T17:21:14Z",
          "updatedAt": "2018-06-12T17:22:02Z",
          "comments": [
            {
              "originalPosition": 65,
              "body": "Actually, you can't use padding here. It's only allowed in CH.",
              "createdAt": "2018-06-12T17:21:15Z",
              "updatedAt": "2018-06-12T17:27:03Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTI4MDcxNzYw",
          "commit": {
            "abbreviatedOid": "095eae5"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-06-12T17:33:54Z",
          "updatedAt": "2018-06-15T23:28:17Z",
          "comments": [
            {
              "originalPosition": 115,
              "body": "This change is unrelated. ",
              "createdAt": "2018-06-12T17:33:55Z",
              "updatedAt": "2018-06-15T23:28:17Z"
            },
            {
              "originalPosition": 83,
              "body": "Again, this recommendation describes a single anonymity set.  Because the size of esni and certificate both contribute to information that distinguishes connections, you should include text on padding that addresses the combination of the two fields.",
              "createdAt": "2018-06-15T23:25:47Z",
              "updatedAt": "2018-06-15T23:28:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTI5MzUwMzgz",
          "commit": {
            "abbreviatedOid": "095eae5"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-06-16T01:49:04Z",
          "updatedAt": "2018-06-16T01:49:04Z",
          "comments": [
            {
              "originalPosition": 115,
              "body": "Yeah. The document failed to build with this, so I removed it. ",
              "createdAt": "2018-06-16T01:49:04Z",
              "updatedAt": "2018-06-16T01:49:04Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTI5MzUwMzkw",
          "commit": {
            "abbreviatedOid": "095eae5"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-06-16T01:49:21Z",
          "updatedAt": "2018-06-16T01:49:21Z",
          "comments": [
            {
              "originalPosition": 83,
              "body": "Yep, good point. I\u2019ll update in a separate PR. ",
              "createdAt": "2018-06-16T01:49:21Z",
              "updatedAt": "2018-06-16T01:49:21Z"
            }
          ]
        }
      ],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "dd379d3031f72b6137d2bbee6d067d0787187b39",
      "headRepository": null,
      "headRefName": "caw/padded",
      "headRefOid": "095eae5ab689aaec89bdabbefb7f9b8caace394b",
      "mergeCommit": {
        "oid": "44589659396b2f58fccb980860f270cdcbe42684"
      }
    },
    {
      "number": 49,
      "id": "MDExOlB1bGxSZXF1ZXN0MTk0MTQ2ODg5",
      "title": "Briefly discuss pros and cons of alternative designs",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/49",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-06-12T01:56:08Z",
      "updatedAt": "2018-06-20T22:53:19Z",
      "closedAt": "2018-06-20T22:50:19Z",
      "mergedAt": "2018-06-20T22:50:19Z",
      "mergedBy": "kazuho",
      "comments": [
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "@chris-wood Thank you for the changes. It's super clear to me now.",
          "createdAt": "2018-06-20T22:53:18Z",
          "updatedAt": "2018-06-20T22:53:18Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTI3ODA1NTQ5",
          "commit": {
            "abbreviatedOid": "e0403f5"
          },
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Thank you for working on the improvement.\r\n\r\nIt was easy to read, and I like the way you categorize the approaches. I have left my comments in-line.",
          "createdAt": "2018-06-12T02:57:21Z",
          "updatedAt": "2018-06-12T03:02:50Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "I am not sure if \"TLS tunnel\" requires a previous session or the use of 0-RTT data.\r\n\r\nWould you mind considering either adjusting the name or adjusting the text? Because what I expect for a scheme called \"TLS tunnel\" is as follows:\r\n\r\n\"TLS tunnel\" is an approach that first establishes a TLS connection to a fronting host, and then, on top of that connection, establishes another TLS connection that uses the hostname of the hidden host.\r\n\r\nIf that is the case, I'd assume that all prior knowledge that is necessary is the binding between two names: name of the fronting host and that of the hidden host.\r\n\r\nIn other words, I'd expect that the \"TLS Tunnel\" scheme will be distributing using DNS the name of the fronting host instead of the ESNI key.\r\n\r\nThe downside of the tunneling is approach will be that there will be additional roundtrip when 0-RTT is not used, as well as the cost of double handshake and double encryption.",
              "createdAt": "2018-06-12T02:57:22Z",
              "updatedAt": "2018-06-20T00:28:06Z"
            },
            {
              "originalPosition": 47,
              "body": "Doesn't the scheme also has the bootstrap problem: i.e. distributing the name of the client-facing server that corresponds to the name of the server that the client actually wants to connect to?\r\n\r\nI can see that such binding can sometimes advertised eagerly using the CERTIFICATE frames, but I do not think that can be done for every host that the client might want to connect to.",
              "createdAt": "2018-06-12T03:01:38Z",
              "updatedAt": "2018-06-20T00:28:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTI5MzE1NjI2",
          "commit": {
            "abbreviatedOid": "e0403f5"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-06-15T20:59:16Z",
          "updatedAt": "2018-06-15T20:59:16Z",
          "comments": [
            {
              "originalPosition": 47,
              "body": "Depending on how it's done, yeah, bootstrapping is also an issue here. I'll mention that.",
              "createdAt": "2018-06-15T20:59:16Z",
              "updatedAt": "2018-06-20T00:28:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTI5MzE3MjY5",
          "commit": {
            "abbreviatedOid": "2c95fcd"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-06-15T21:05:49Z",
          "updatedAt": "2018-06-15T21:05:49Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "@kazuho The tunnel approach you describe is a simple proxy. We can describe it here, though it's different from what was the \"hide TLS in early data\" proposal. I updated the title to try to make it more clear.",
              "createdAt": "2018-06-15T21:05:49Z",
              "updatedAt": "2018-06-20T00:28:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTI5NDI4NTgy",
          "commit": {
            "abbreviatedOid": "2c95fcd"
          },
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-06-18T05:09:11Z",
          "updatedAt": "2018-06-18T05:09:11Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "Thank you for the changes.\r\n\r\nNow I think I understand the approach suggested here; it's about encapsulating CH using 0-RTT data of an outer TLS connection, but sending the rest of the TLS transmissions directly (i.e. without double encryption).\r\n\r\nAssuming that that is true, it might be worth clarifying that (e.g., state something like \"Rest of the TLS messages / records are exchanged directly between the peers without double encryption\").\r\n\r\nOther than that, the PR looks to be ready for merge.",
              "createdAt": "2018-06-18T05:09:11Z",
              "updatedAt": "2018-06-20T00:28:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTMwMTYyMjE3",
          "commit": {
            "abbreviatedOid": "7a96223"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-06-19T21:13:53Z",
          "updatedAt": "2018-06-19T21:13:53Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "@kazuho I added some clarifying text. Please have a look!",
              "createdAt": "2018-06-19T21:13:53Z",
              "updatedAt": "2018-06-20T00:28:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTMwMTgyMjIw",
          "commit": {
            "abbreviatedOid": "7a96223"
          },
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-06-19T22:22:58Z",
          "updatedAt": "2018-06-19T22:22:58Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "Thank you for explicitly stating that only Client Hello is sent as 0-RTT data.\r\n\r\nMaybe we might want to change the sentence starting from \"All Server Hello ...\" to something like \"Rest of the exchanges between the client and the hidden server, starting from Server Hello, are forwarded by the client-facing server -- unmodified.\", to clarify that exchanges following Server Hello are also forwarded directly.\r\n\r\nOther than that, the PR looks ready for merge to me.",
              "createdAt": "2018-06-19T22:22:58Z",
              "updatedAt": "2018-06-20T00:28:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTMwMTgyODM3",
          "commit": {
            "abbreviatedOid": "7a96223"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-06-19T22:25:33Z",
          "updatedAt": "2018-06-19T22:25:33Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "@kazuho  I don't think that's necessary, since the remaining messages must necessarily also be forwarded.",
              "createdAt": "2018-06-19T22:25:33Z",
              "updatedAt": "2018-06-20T00:28:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTMwMTg1NzM4",
          "commit": {
            "abbreviatedOid": "7a96223"
          },
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-06-19T22:38:48Z",
          "updatedAt": "2018-06-19T22:38:49Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "The reason I suggested the change is because the paragraph seemed to be unclear to me on whether or not the handshake messages and application data that follows Server Hello is double-encrypted, because it only discusses about Client Hello and Server Hello explicitly.",
              "createdAt": "2018-06-19T22:38:48Z",
              "updatedAt": "2018-06-20T00:28:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTMwMjA1NzIx",
          "commit": {
            "abbreviatedOid": "35eb736"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-06-20T00:28:08Z",
          "updatedAt": "2018-06-20T00:28:08Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "@kazuho Should be more clear now!",
              "createdAt": "2018-06-20T00:28:08Z",
              "updatedAt": "2018-06-20T00:28:08Z"
            }
          ]
        }
      ],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "44589659396b2f58fccb980860f270cdcbe42684",
      "headRepository": null,
      "headRefName": "caw/alternates",
      "headRefOid": "35eb736a1fd180e0364d3a0ba036cbcd483c1ca2",
      "mergeCommit": {
        "oid": "368ed7d1ba6bd0124fe1afe7f0a7c33c2dd03650"
      }
    },
    {
      "number": 50,
      "id": "MDExOlB1bGxSZXF1ZXN0MTk1MjkxMjE2",
      "title": "Add Nick",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/50",
      "state": "MERGED",
      "author": "grittygrease",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-06-15T21:54:29Z",
      "updatedAt": "2018-06-15T21:54:49Z",
      "closedAt": "2018-06-15T21:54:49Z",
      "mergedAt": "2018-06-15T21:54:49Z",
      "mergedBy": "chris-wood",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTI5MzI4MTM0",
          "commit": {
            "abbreviatedOid": "d4af1ee"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-06-15T21:54:45Z",
          "updatedAt": "2018-06-15T21:54:45Z",
          "comments": []
        }
      ],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "44589659396b2f58fccb980860f270cdcbe42684",
      "headRepository": "grittygrease/draft-rescorla-tls-esni",
      "headRefName": "nick/author",
      "headRefOid": "d4af1ee50283017f52d56ee587f567876514bc90",
      "mergeCommit": {
        "oid": "99de7bde18aed8a52e362ae0b33a89540efbbbba"
      }
    },
    {
      "number": 51,
      "id": "MDExOlB1bGxSZXF1ZXN0MTk2NjI4NTkw",
      "title": "Self-add author.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/51",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Please do not merge yet!",
      "createdAt": "2018-06-22T03:22:55Z",
      "updatedAt": "2018-06-25T19:42:07Z",
      "closedAt": "2018-06-25T19:42:07Z",
      "mergedAt": "2018-06-25T19:42:07Z",
      "mergedBy": "chris-wood",
      "comments": [],
      "reviews": [],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "368ed7d1ba6bd0124fe1afe7f0a7c33c2dd03650",
      "headRepository": "tlswg/draft-ietf-tls-esni",
      "headRefName": "caw/author",
      "headRefOid": "1a8b0959b887f86ca8bf9f93c4e6652c9a341020",
      "mergeCommit": {
        "oid": "f0e80361e890e99d86477c8c03b86a4b51699f76"
      }
    },
    {
      "number": 52,
      "id": "MDExOlB1bGxSZXF1ZXN0MTk4NTIzMjg2",
      "title": "Fix use of padded_length",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/52",
      "state": "MERGED",
      "author": "ghedo",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "\"padding_length\" appears out of nowhere and is not defined.",
      "createdAt": "2018-07-01T12:59:36Z",
      "updatedAt": "2018-07-02T14:11:47Z",
      "closedAt": "2018-07-02T14:11:47Z",
      "mergedAt": "2018-07-02T14:11:47Z",
      "mergedBy": "ekr",
      "comments": [],
      "reviews": [],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "f0e80361e890e99d86477c8c03b86a4b51699f76",
      "headRepository": null,
      "headRefName": "padding_len",
      "headRefOid": "0348f408b95c833744de9571f9ce9a09de4f1f34",
      "mergeCommit": {
        "oid": "df2fcf152d436683090eb0ae395dddd699ed33f4"
      }
    },
    {
      "number": 53,
      "id": "MDExOlB1bGxSZXF1ZXN0MTk4NTIzNjc3",
      "title": "Prevent clients from caching keys based on not_after",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/53",
      "state": "MERGED",
      "author": "ghedo",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-07-01T13:09:03Z",
      "updatedAt": "2018-07-02T14:15:50Z",
      "closedAt": "2018-07-02T14:15:50Z",
      "mergedAt": "2018-07-02T14:15:50Z",
      "mergedBy": "ekr",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTMzNDU1NzA2",
          "commit": {
            "abbreviatedOid": "9f452fa"
          },
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-07-01T14:19:43Z",
          "updatedAt": "2018-07-01T14:19:43Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "I am sympathetic to the proposed change, but might prefer using \"SHOULD NOT\" rather than a \"MUST NOT\" here.\r\n\r\nConsider a client that uses `getaddrinfo`. The client cannot access the TTL value. OTOH, it makes sense for such a client to cache the query result for a short amount of time to reduce the load on the resolver running on the client machine. My understanding is that some clients are implemented that way.",
              "createdAt": "2018-07-01T14:19:43Z",
              "updatedAt": "2018-07-01T14:19:43Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTMzNTk1MTk2",
          "commit": {
            "abbreviatedOid": "9f452fa"
          },
          "author": "ghedo",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-07-02T11:54:59Z",
          "updatedAt": "2018-07-02T11:54:59Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "This PR only prevents the client from using \"not_after\" for caching, it doesn't really forbid using another random value (not sure if we want to be more specific on this).\r\n\r\nAnyway, I'm fine changing this to SHOULD NOT.",
              "createdAt": "2018-07-02T11:54:59Z",
              "updatedAt": "2018-07-02T11:54:59Z"
            }
          ]
        }
      ],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "f0e80361e890e99d86477c8c03b86a4b51699f76",
      "headRepository": null,
      "headRefName": "client_cache",
      "headRefOid": "9f452faf97a5cc082dea2c548a2d9e487a480617",
      "mergeCommit": {
        "oid": "237cb9dd389c23224379eb0cfd1f72211403d0db"
      }
    },
    {
      "number": 54,
      "id": "MDExOlB1bGxSZXF1ZXN0MTk4NTI2MjE1",
      "title": "ServerNameList should be 260 octets long for fronting servers with wildcard support",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/54",
      "state": "CLOSED",
      "author": "kazuho",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Because the longest name is 255 octets (see RFC 1035), and there is 5-octet overhead in the ServerNameList structure (defined in RFC 6066 as shown below).\r\n\r\n```\r\n      struct {\r\n          NameType name_type;\r\n          select (name_type) {\r\n              case host_name: HostName;\r\n          } name;\r\n      } ServerName;\r\n\r\n      enum {\r\n          host_name(0), (255)\r\n      } NameType;\r\n\r\n      opaque HostName<1..2^16-1>;\r\n\r\n      struct {\r\n          ServerName server_name_list<1..2^16-1>\r\n      } ServerNameList;\r\n```\r\n\r\namends #48 ",
      "createdAt": "2018-07-01T14:12:23Z",
      "updatedAt": "2018-07-02T14:15:27Z",
      "closedAt": "2018-07-02T14:15:27Z",
      "mergedAt": null,
      "mergedBy": null,
      "comments": [
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Why not just pad the name ? Then the field can be 1 octet. ",
          "createdAt": "2018-07-01T23:50:55Z",
          "updatedAt": "2018-07-01T23:50:55Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "@martinthomson \r\n> Why not just pad the name ? Then the field can be 1 octet.\r\n\r\nThat's definitely possible, but I am not sure if we want to do that.\r\n\r\nUntil now, we have tried to consider ServerNameList  (the server_name extension) as an abstract structure. Current draft allows us to use the ESNIKeys to encrypt a server_name extension of any name_type.\r\n\r\nDefining padded_length to designate the length of the HostName field that exists only when server_name.name_type == host_name destroys that abstraction.\r\n\r\nNote also that specifying the amount of padding appended to ServerNameList based on the value of `ServerNameList[0].name.HostName` makes implementations complex. This is because you would be required to parse the struct before validating the length of the padding.\r\n\r\nGenerally speaking, I am not opposed to dealing directly with \"hostname\"s stored in the server_name extension. However, if that is the case, I think we should consider adding a `encrypted_host_name` type to the NameType so that we do not need to deal with the complex structure of ServerNameList.",
          "createdAt": "2018-07-02T01:47:30Z",
          "updatedAt": "2018-07-02T01:47:58Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "I tend to think we should leave it as-is rather than breaking the\nencapsulation barrier.\n\nOn Sun, Jul 1, 2018 at 6:47 PM, Kazuho Oku <notifications@github.com> wrote:\n\n> @martinthomson <https://github.com/martinthomson>\n>\n> Why not just pad the name ? Then the field can be 1 octet.\n>\n> That's definitely possible, but I am not sure if we want to do that.\n>\n> Until now, we have tried to consider ServerNameList (the server_name\n> extension) as an abstract structure. Current draft allows us to use the\n> ESNIKeys to encrypt a server_name extension of any name_type.\n>\n> Defining padded_length to designate the length of the HostName field that\n> exists only when server_name.name_type == host_name destroys that\n> abstraction.\n>\n> Note also that specifying the amount of padding appended to ServerNameList\n> based on the value of ServerNameList[0].name.HostName makes\n> implementations complex. This is because you would be required to parse the\n> struct before validating the length of the padding.\n>\n> Generally speaking, I am not opposed removing the restriction to directly\n> deal with \"hostname\"s stored in the server_name extension. However, if that\n> is the case, I think we should consider adding a encrypted_host_name type\n> to the NameType so that we do not need to deal with the complex structure\n> of ServerNameList.\n>\n> \u2014\n> You are receiving this because you are subscribed to this thread.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/ekr/draft-rescorla-tls-esni/pull/54#issuecomment-401650517>,\n> or mute the thread\n> <https://github.com/notifications/unsubscribe-auth/ABD1oYVLU7B1rR_BJVCq4dYXulz-mKLJks5uCXuygaJpZM4U-VrF>\n> .\n>\n",
          "createdAt": "2018-07-02T02:33:45Z",
          "updatedAt": "2018-07-02T02:33:45Z"
        }
      ],
      "reviews": [],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "f0e80361e890e99d86477c8c03b86a4b51699f76",
      "headRepository": "kazuho/draft-rescorla-tls-esni",
      "headRefName": "kazuho/fix-max-length",
      "headRefOid": "c153340a60062c6698015e805ca9690d5782a721",
      "mergeCommit": null
    },
    {
      "number": 55,
      "id": "MDExOlB1bGxSZXF1ZXN0MTk4NjU0NDEx",
      "title": "Make server send empty encrypted_server_name in EE",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/55",
      "state": "CLOSED",
      "author": "ghedo",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Since encrypted_server_name mirrors server_name, I think it makes sense\r\nfor the server to send this back.\r\n\r\n---\r\n\r\nI don't quite understand the objection regarding \"stock servers\", @ekr ?",
      "createdAt": "2018-07-02T11:46:59Z",
      "updatedAt": "2018-07-09T14:01:34Z",
      "closedAt": "2018-07-03T08:53:07Z",
      "mergedAt": null,
      "mergedBy": null,
      "comments": [
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "This will make it impossible to run in split mode without modifying your server, which I think is bad.",
          "createdAt": "2018-07-02T12:47:55Z",
          "updatedAt": "2018-07-02T12:47:55Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "Not putting this in -00",
          "createdAt": "2018-07-02T14:10:04Z",
          "updatedAt": "2018-07-02T14:10:04Z"
        },
        {
          "author": "ghedo",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Oh, I see what you mean now. FWIW, we could just make the Shared Mode server echo the extension. RFC6066 says:\r\n```\r\n   A server that receives a client hello containing the \"server_name\"\r\n   extension MAY use the information contained in the extension to guide\r\n   its selection of an appropriate certificate to return to the client,\r\n   and/or other aspects of security policy.  In this event, the server\r\n   SHALL include an extension of type \"server_name\" in the (extended)\r\n   server hello.\r\n```\r\n\r\nSo if we adopt a similar text, the split mode hidden server technically doesn't use ESNI to select the certificate, so it wouldn't need to echo the extension.",
          "createdAt": "2018-07-02T19:57:46Z",
          "updatedAt": "2018-07-02T19:57:46Z"
        },
        {
          "author": "ghedo",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Though now I'm questioning how useful this is at all... even with plain \"server_name\", do clients care if they get back the empty extension?",
          "createdAt": "2018-07-02T20:02:52Z",
          "updatedAt": "2018-07-02T20:02:52Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Clients just ignore SNI from a server: there is no point in a server ever sending it.  It's just another bit of cruftiness in RFC 6066.  (Oh, how I wish that I could enumerate the ways in which that RFC is bad...)",
          "createdAt": "2018-07-03T01:07:43Z",
          "updatedAt": "2018-07-03T01:07:43Z"
        },
        {
          "author": "ghedo",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Ok, so, I guess we don't really want this at all then. I'll make a PR to remove the OPEN ISSUE.",
          "createdAt": "2018-07-03T08:53:07Z",
          "updatedAt": "2018-07-03T08:53:07Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "Concur.",
          "createdAt": "2018-07-09T14:01:33Z",
          "updatedAt": "2018-07-09T14:01:33Z"
        }
      ],
      "reviews": [],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "f0e80361e890e99d86477c8c03b86a4b51699f76",
      "headRepository": null,
      "headRefName": "server_echo",
      "headRefOid": "106d313f0a7c37833b0ebb2e77a22fe12592cb8f",
      "mergeCommit": null
    },
    {
      "number": 56,
      "id": "MDExOlB1bGxSZXF1ZXN0MTk4NjU1Mzky",
      "title": "Add IANA considerations and pick a codepoint from the reserved range",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/56",
      "state": "CLOSED",
      "author": "ghedo",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "**NOTE**, this depends on https://github.com/ekr/draft-rescorla-tls-esni/pull/55 and if we decide that we don't want to send the empty extension in EE, then it needs to be removed from this PR too.",
      "createdAt": "2018-07-02T11:51:37Z",
      "updatedAt": "2018-07-02T14:14:14Z",
      "closedAt": "2018-07-02T14:14:14Z",
      "mergedAt": null,
      "mergedBy": null,
      "comments": [],
      "reviews": [],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "f0e80361e890e99d86477c8c03b86a4b51699f76",
      "headRepository": null,
      "headRefName": "iana",
      "headRefOid": "bb30359063a7189be2e7440b3f9f676ae1544ac8",
      "mergeCommit": null
    },
    {
      "number": 57,
      "id": "MDExOlB1bGxSZXF1ZXN0MTk4Nzc3ODIy",
      "title": "clock skew is about not_after, record TTL will not be affected by that",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/57",
      "state": "MERGED",
      "author": "kazuho",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-07-02T20:12:11Z",
      "updatedAt": "2018-07-02T20:46:08Z",
      "closedAt": "2018-07-02T20:14:19Z",
      "mergedAt": "2018-07-02T20:14:19Z",
      "mergedBy": "ekr",
      "comments": [
        {
          "author": "ghedo",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'm not sure this is much better. I would changes the \"Note that servers...\" sentence to something like:\r\n\r\n> Note that servers MAY need to retain the decryption key for some time after \"not_after\", and will need to consider clock skew, internal caches and the like, when selecting the \"not_before\" and \"not_after\" values.",
          "createdAt": "2018-07-02T20:43:35Z",
          "updatedAt": "2018-07-02T20:43:35Z"
        },
        {
          "author": "ghedo",
          "authorAssociation": "CONTRIBUTOR",
          "body": "See https://github.com/ekr/draft-rescorla-tls-esni/pull/59",
          "createdAt": "2018-07-02T20:46:08Z",
          "updatedAt": "2018-07-02T20:46:08Z"
        }
      ],
      "reviews": [],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "0cd1d37cfd9d8cd7eadb3f0f7204853969f5f14c",
      "headRepository": "kazuho/draft-rescorla-tls-esni",
      "headRefName": "kazuho/reorg-not-after-vs-ttl-discussion",
      "headRefOid": "d75151312c15814691390e2c53833a99598cd037",
      "mergeCommit": {
        "oid": "3f4ec98e02e5a0478e08041ac93cfdc8300938ee"
      }
    },
    {
      "number": 58,
      "id": "MDExOlB1bGxSZXF1ZXN0MTk4Nzc4MDI0",
      "title": "Remove the use of 'hidden'",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/58",
      "state": "MERGED",
      "author": "ekr",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "I decided \"hidden\" was bad.\r\n\r\n@mcmanus",
      "createdAt": "2018-07-02T20:13:07Z",
      "updatedAt": "2018-07-02T20:31:05Z",
      "closedAt": "2018-07-02T20:31:05Z",
      "mergedAt": "2018-07-02T20:31:05Z",
      "mergedBy": "ekr",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTMzNzYyODYw",
          "commit": {
            "abbreviatedOid": "9d83bc9"
          },
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "+1 to the change. I think that this is the right direction.",
          "createdAt": "2018-07-02T20:18:19Z",
          "updatedAt": "2018-07-02T20:27:32Z",
          "comments": [
            {
              "originalPosition": 85,
              "body": "\"private private\" => \"private domains\"",
              "createdAt": "2018-07-02T20:18:19Z",
              "updatedAt": "2018-07-02T20:30:48Z"
            }
          ]
        }
      ],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "0cd1d37cfd9d8cd7eadb3f0f7204853969f5f14c",
      "headRepository": "tlswg/draft-ietf-tls-esni",
      "headRefName": "terminology",
      "headRefOid": "b6c54c7c0a657c91f6e506b8852e7fa16d9e7eac",
      "mergeCommit": {
        "oid": "6611fb65fa444721fa22ebc3e2303e1d12dab219"
      }
    },
    {
      "number": 59,
      "id": "MDExOlB1bGxSZXF1ZXN0MTk4Nzg1MDg3",
      "title": "Try to clarify clock skew sentence some more",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/59",
      "state": "MERGED",
      "author": "ghedo",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-07-02T20:45:42Z",
      "updatedAt": "2018-07-02T21:12:08Z",
      "closedAt": "2018-07-02T21:12:07Z",
      "mergedAt": "2018-07-02T21:12:07Z",
      "mergedBy": "ekr",
      "comments": [],
      "reviews": [],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "6611fb65fa444721fa22ebc3e2303e1d12dab219",
      "headRepository": null,
      "headRefName": "more_nitpick_language",
      "headRefOid": "ce7622476cd7b0ecc172c5cb405cd200a11e7f82",
      "mergeCommit": {
        "oid": "91ea306749c85e77f7e749469cc2e3aa40362211"
      }
    },
    {
      "number": 60,
      "id": "MDExOlB1bGxSZXF1ZXN0MTk4ODkzNjY4",
      "title": "Remove OPEN ISSUE about sending empty ESNI in EE",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/60",
      "state": "MERGED",
      "author": "ghedo",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "As per discussion in https://github.com/ekr/draft-rescorla-tls-esni/pull/55\r\nthis would require changes to Split Mode backend servers, and it turns out\r\nthat even for plain \"server_name\" this behaviour is pretty much useless.",
      "createdAt": "2018-07-03T08:56:39Z",
      "updatedAt": "2018-07-09T14:19:17Z",
      "closedAt": "2018-07-09T14:19:16Z",
      "mergedAt": "2018-07-09T14:19:16Z",
      "mergedBy": "ekr",
      "comments": [],
      "reviews": [],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "91ea306749c85e77f7e749469cc2e3aa40362211",
      "headRepository": null,
      "headRefName": "remove_open_issue",
      "headRefOid": "54d7151f1a706036e6d3320d1eede151ec4ed39c",
      "mergeCommit": {
        "oid": "e72b0512cc779f2273f72a794af18a36598d19a2"
      }
    },
    {
      "number": 70,
      "id": "MDExOlB1bGxSZXF1ZXN0MTk5NjA5NzYz",
      "title": "allow use of different Key Share for ESNI and handshake",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/70",
      "state": "CLOSED",
      "author": "kazuho",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "As pointed out in #69, current draft allows a client-facing server to downgrade the TLS handshake under Split mode.\r\n\r\nFor example, if the hidden server supports X25519 and X448 but the ESNIKeys published by the client-facing server only includes X25519, client only sends X25519.\r\n\r\nThis PR fixes the issue in the least intrusive way, by allowing the parties to use different key shares for ESNI and TLS key schedule.\r\n\r\nIn short, KE for ESNI is selected by the server offering the list of supported groups in ESNIKeys and client choosing one; KE for key schedule is selected exactly the same way as is defined in TLS 1.3.\r\n\r\nfixes #67",
      "createdAt": "2018-07-05T23:17:42Z",
      "updatedAt": "2018-07-11T01:36:55Z",
      "closedAt": "2018-07-11T01:36:55Z",
      "mergedAt": null,
      "mergedBy": null,
      "comments": [
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "@kazuho: I haven't gone through this in detail, but doesn't this create the possibility of a cut-and-paste attack if the client uses a less-preferred group.\r\n\r\nConsider the case where the server's preferences are [X448, X25519] and the client's preferences are [X25519, X448]. The client sends one key share: X25519. The attacker then adds his own X448 share. The server decrypts SNI but sends an X448 share, thus allowing the attacker to decrypt the certificate. Is there a reason why this won't work?",
          "createdAt": "2018-07-05T23:33:49Z",
          "updatedAt": "2018-07-05T23:33:49Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "@ekr I think you are correct. Thank you for pointing that out. I now understand that the approach used in this PR does not work.\r\n\r\nI also notice that under Split mode, KEs and cipher-suites that can be offered in ESNIKeys will be the intersection of those supported by the various hidden servers. That would mean that the operator of the client-facing server will need to instruct the operators of hidden servers which KE and cipher-suites that they must support; otherwise only secp256r1 / aes128gcm-sha256 will be usable in practice.",
          "createdAt": "2018-07-06T00:18:57Z",
          "updatedAt": "2018-07-06T00:18:57Z"
        }
      ],
      "reviews": [],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "91ea306749c85e77f7e749469cc2e3aa40362211",
      "headRepository": "kazuho/draft-rescorla-tls-esni",
      "headRefName": "kazuho/different-ke-for-esni-and-handshake",
      "headRefOid": "6bd78b7a76b1ec9f66c652e28928a4a4d01ccc95",
      "mergeCommit": null
    },
    {
      "number": 71,
      "id": "MDExOlB1bGxSZXF1ZXN0MjAwMTQ0MTE0",
      "title": "Clarifications",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/71",
      "state": "CLOSED",
      "author": "tmshort",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Use active tense in some places to clarify meaning.\r\nConsolidate shared and split mode common description.\r\nAdd anonymity set size Security Consideration",
      "createdAt": "2018-07-09T15:51:41Z",
      "updatedAt": "2019-10-25T17:57:49Z",
      "closedAt": "2019-10-25T17:57:49Z",
      "mergedAt": null,
      "mergedBy": null,
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing due to staleness. @tmshort, please re-open and update if you still think we need this.",
          "createdAt": "2019-10-25T17:57:49Z",
          "updatedAt": "2019-10-25T17:57:49Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTM1NDk1OTAx",
          "commit": {
            "abbreviatedOid": "1c26075"
          },
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2018-07-09T16:29:34Z",
          "updatedAt": "2018-07-09T16:31:08Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "I think this creates confusion. From the TLS perspective, the Client-Facing server is the origin server.",
              "createdAt": "2018-07-09T16:29:34Z",
              "updatedAt": "2018-07-10T13:07:52Z"
            },
            {
              "originalPosition": 76,
              "body": "I think you need to soften this point. It's true in principle, but plenty of monitoring entities will not have access to this information.",
              "createdAt": "2018-07-09T16:30:51Z",
              "updatedAt": "2018-07-10T13:07:52Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTM1NTE3MTky",
          "commit": {
            "abbreviatedOid": "1c26075"
          },
          "author": "tmshort",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-07-09T17:27:49Z",
          "updatedAt": "2018-07-09T17:27:49Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "Understood. Proxy-mode (as I described) is a hybrid of Shared and Split mode. Any CDN that caches content will operate in this proxy mode. Few operate in split mode; which seems to be more like a firewall in PNAT mode.\r\nSo, proxy-mode be considered a special case of shared mode? \r\n\r\n",
              "createdAt": "2018-07-09T17:27:49Z",
              "updatedAt": "2018-07-10T13:07:52Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTM1NTIyNTg5",
          "commit": {
            "abbreviatedOid": "1c26075"
          },
          "author": "tmshort",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-07-09T17:42:38Z",
          "updatedAt": "2018-07-09T17:42:38Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "Thinking about it some more, the difference between these two modes is termination of the TLS connection, rather than where the origin server (and data) actually are. I will try to come up with something.",
              "createdAt": "2018-07-09T17:42:38Z",
              "updatedAt": "2018-07-10T13:07:52Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTM1ODczODk2",
          "commit": {
            "abbreviatedOid": "aa1bd7a"
          },
          "author": "tmshort",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-07-10T15:13:38Z",
          "updatedAt": "2018-07-10T15:13:38Z",
          "comments": [
            {
              "originalPosition": 76,
              "body": "softened.",
              "createdAt": "2018-07-10T15:13:38Z",
              "updatedAt": "2018-07-10T15:13:38Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTM2MDY2Njc5",
          "commit": {
            "abbreviatedOid": "aa1bd7a"
          },
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-07-11T01:43:37Z",
          "updatedAt": "2018-07-11T01:43:37Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "Use of words like \"origin\" and \"retrieves content\" (below) might sound like that the use of HTTP is implied. It might make sense avoid using such words, and rather talk about things like \"server that terminates TLS\" or \"application data\".",
              "createdAt": "2018-07-11T01:43:37Z",
              "updatedAt": "2018-07-11T01:44:16Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTM2Mjg5MDYw",
          "commit": {
            "abbreviatedOid": "aa1bd7a"
          },
          "author": "tmshort",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-07-11T15:15:03Z",
          "updatedAt": "2018-07-11T15:15:04Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "This is the text for the common case between shared and split mode. The origin server has different behavior in each case. \r\n\r\nIn shared mode the client-facing-server terminates TLS; the origin may be elsewhere. In split mode, the origin behind the client-facing-server is the server that terminates TLS. That distinction is made below, not here.\r\n\r\nThis text was moved, with minor modifications, from it's original location. The term \"origin\" is frequently used within the CDN community, and has a well-understood meaning. I purposely used \"retrieves content\", because the origin server may very well only use HTTP, if it's a private server protected by this client-facing server.  But I can change it to \"application data\"; I'm not sure it really maters.\r\n\r\n",
              "createdAt": "2018-07-11T15:15:03Z",
              "updatedAt": "2018-07-11T15:15:50Z"
            }
          ]
        }
      ],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "e72b0512cc779f2273f72a794af18a36598d19a2",
      "headRepository": "tmshort/draft-rescorla-tls-esni",
      "headRefName": "master-tmshort",
      "headRefOid": "aa1bd7ae6eff44e7e2112e6673f09ac3ad9e1af5",
      "mergeCommit": null
    },
    {
      "number": 72,
      "id": "MDExOlB1bGxSZXF1ZXN0MjAwNzU0OTcy",
      "title": "Support both specific RR type and TXT",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/72",
      "state": "CLOSED",
      "author": "ghedo",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The idea here is to have a new RR type which makes DNS people happier, but also be able to fallback to the plain TXT lookup to address @kazuho's concerns.\r\n\r\nThis should also fix #35 since the ESNI lookup will follow the CNAME, I _think_.\r\n\r\nThe ESNI RRData format is kind of dumb, so we probably need to make it better.",
      "createdAt": "2018-07-11T16:16:58Z",
      "updatedAt": "2018-07-11T17:35:15Z",
      "closedAt": "2018-07-11T17:35:15Z",
      "mergedAt": null,
      "mergedBy": null,
      "comments": [
        {
          "author": "ghedo",
          "authorAssociation": "CONTRIBUTOR",
          "body": "There is general opposition to doing both ESNI and TXT records, so I made https://github.com/ekr/draft-rescorla-tls-esni/pull/73 to just add a new ESNI RR type.",
          "createdAt": "2018-07-11T17:35:15Z",
          "updatedAt": "2018-07-11T17:35:15Z"
        }
      ],
      "reviews": [],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "e72b0512cc779f2273f72a794af18a36598d19a2",
      "headRepository": null,
      "headRefName": "rrtype",
      "headRefOid": "7d69391b239f21f8cf6c3fae18f1fb51558ec9ca",
      "mergeCommit": null
    },
    {
      "number": 73,
      "id": "MDExOlB1bGxSZXF1ZXN0MjAwNzc0MTIw",
      "title": "Replace TXT record with dedicated RRType",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/73",
      "state": "CLOSED",
      "author": "ghedo",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #35.\r\n\r\n---\r\n\r\nThe problem this introduces is that the domain owner won't be able to delegate just the ESNI record of the apex name, to a different DNS provider (like they would be able to do if we used a separate \"_esni.\" prefix), which might prevent adoption from CDNs that do not handle DNS (or that allow customers to use an external DNS provider), since they would need to update the ESNI record frequently for key rotation.\r\n\r\nOn the other hand it solves the CNAME problem outlined in #35.",
      "createdAt": "2018-07-11T17:31:54Z",
      "updatedAt": "2019-03-06T00:55:10Z",
      "closedAt": "2019-03-06T00:55:10Z",
      "mergedAt": null,
      "mergedBy": null,
      "comments": [
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "> The problem this introduces is that the domain owner won't be able to delegate just the ESNI record of the apex name, to a different DNS provider (like they would be able to do if we used a separate \"_esni.\" prefix), which might prevent adoption from CDNs that do not handle DNS (or that allow customers to use an external DNS provider), since they would need to update the ESNI record frequently for key rotation.\r\n\r\nThis is true, and I would like to avoid the problem. May I ask why you need to remove the prefix? I do not see a reason why we cannot use a prefix _and_ a dedicated type at the same time.\r\n\r\nI prefer discussing whether the `_esni.example.com` record should use TXT or a dedicated type, and if we decide to go with a dedicated type, then we might consider if having a prefix is OK.\r\n\r\n> On the other hand it solves the CNAME problem outlined in #35.\r\n\r\nI do not see how it solves the problem.\r\n\r\nConsider the case where the load of `foo.example.com` uses `cdnA.example` and `cdnB.example`. In such case, `foo.example.com` will sometimes be a CNAME to `cdnA.example` and sometimes to `cdnB.example`.\r\n\r\nWe want both the query for A and ESNI to use the same CNAME.\r\n\r\nBut there is no guarantee that the two queries will reach the recursive resolver at the same time. If they arrive at different time, the recursive resolver might return an A using CNAME `cdnA.example`, then query for `foo.example.com` for ESNI that might return `cdnB.example`.\r\n\r\nAm I missing something?",
          "createdAt": "2018-07-11T18:01:32Z",
          "updatedAt": "2018-07-11T18:16:01Z"
        },
        {
          "author": "ghedo",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> May I ask why you need to remove the prefix? I do not see a reason why we cannot use a prefix and a dedicated type at the same time.\r\n\r\nBecause then a single CNAME can cover both the A/AAAA records and ESNI. I don't think keeping the prefix with a dedicated RR type makes a whole lot of sense, since they are both meant to signal that this is an ESNI query (that is, they are redundant).\r\n\r\nFWIW, #35 is not the main motivator for this. Simplifying DNS automatic processing server-side is (e.g. automatically handling ESNI for multiple domains at a time, rather than configuring single ones on their own). The need to handle a prefix in a query makes processing kind of awkward.\r\n\r\n> But there is no guarantee that the two queries will reach the recursive resolver at the same time\r\n\r\nThat is true of the status quo as well (which would require you to e.g. CNAME the _esni record as well, and keep it in sync with the CNAME of the main domain).\r\n\r\nThe only possible way an atomic query could work that I can think of is if the DNS server returned the ESNI answer as \"additional data\" of the A/AAAA response (which would also need some way to negotiate e.g. an EDNS(0)/OPT flag or something), though I don't know if this would work with resolvers.",
          "createdAt": "2018-07-11T20:38:19Z",
          "updatedAt": "2018-07-11T20:38:19Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "> Because then a single CNAME can cover both the A/AAAA records and ESNI. I don't think keeping the prefix with a dedicated RR type makes a whole lot of sense, since they are both meant to signal that this is an ESNI query (that is, they are redundant).\r\n> \r\n> FWIW, #35 is not the main motivator for this. Simplifying DNS automatic processing server-side is (e.g. automatically handling ESNI for multiple domains at a time, rather than configuring single ones on their own). The need to handle a prefix in a query makes processing kind of awkward.\r\n\r\nAs we agree, having no prefix is a no-go for certain deployments.\r\n\r\nI would also argue that providing customers of CDN the ability to opt-in to ESNI is important, especially during the early stages. Otherwise, CDNs cannot starting ESNI for _any_ domains until _all_ their customers permit the use ESNI.\r\n\r\nI can understand your argument about simplicity, but seeing wider adoption seems more important to me. And all this discussion is _not_ about the record type about having prefix; hence the suggestion to limit the scope of the PR to changing the type only.",
          "createdAt": "2018-07-11T21:59:46Z",
          "updatedAt": "2018-07-11T21:59:46Z"
        },
        {
          "author": "ghedo",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@kazuho ok I restored the prefix for now and removed the reference to #35, though the page is not updating with the new commits for some reason.",
          "createdAt": "2018-07-12T12:11:45Z",
          "updatedAt": "2018-07-12T12:11:45Z"
        },
        {
          "author": "ghedo",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Rebased and updated after https://github.com/ekr/draft-rescorla-tls-esni/pull/76 got merged.",
          "createdAt": "2018-07-19T19:36:55Z",
          "updatedAt": "2018-07-19T19:36:55Z"
        },
        {
          "author": "ghedo",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Rebased on master.",
          "createdAt": "2018-09-24T12:39:47Z",
          "updatedAt": "2018-09-24T12:39:47Z"
        },
        {
          "author": "mhofman",
          "authorAssociation": "NONE",
          "body": ">> Because then a single CNAME can cover both the A/AAAA records and ESNI. I don't think keeping the prefix with a dedicated RR type makes a whole lot of sense, since they are both meant to signal that this is an ESNI query (that is, they are redundant).\r\n>\r\n> As we agree, having no prefix is a no-go for certain deployments.\r\n\r\nI'm wondering, couldn't both non-prefixed and prefixed records be allowed to cover all cases?\r\n\r\nThe client would start simultaneous queries on the non-prefixed name for A/AAAA records, non-prefixed ESNI records, and for the _esni prefixed TXT (or ESNI?) record.\r\nIf an ESNI record is present on the non-prefixed name, the client uses it immediately, discarding whatever answer may be provided for the _esni prefix.\r\n\r\nIt would solve the wildcard use case (#79), while keeping the option of the _esni prefix for cases where delegation is needed (e.g. APEX or when the DNS and CDN providers are separate).\r\n\r\nWhile in itself it doesn't solve the case of a domain balanced over multiple CDNs like mentioned in #35, it does open the door to improvements when/if [multiple QTYPEs in queries](https://tools.ietf.org/html/draft-bellis-dnsext-multi-qtypes-06) ever get supported.\r\nI have a hunch it also makes it more likely for the A/AAAA and ESNI records to be in sync for DNS providers that offer ALIAS \"virtual\" records.\r\n\r\n> I would also argue that providing customers of CDN the ability to opt-in to ESNI is important, especially during the early stages. Otherwise, CDNs cannot starting ESNI for any domains until all their customers permit the use ESNI.\r\n\r\nI think this should be possible with either approach.\r\nIn the non-prefixed case, the CDN can offer a dedicated CNAME target that has both the A/AAAA records of the ESNI enabled TLS servers and the ESNI records to use with them. If the customer doesn't want ESNI enabled, they can use the non-ESNI CNAME target. Or for CDN providers that offer a CNAME target personalized to the customer, this could be handled by a configuration at the CDN provider level.\r\nIn the prefixed case, it's of course a matter of the customer adding an _esni CNAME record pointing to the CDN's ESNI record.",
          "createdAt": "2018-09-25T18:21:44Z",
          "updatedAt": "2018-09-25T18:21:44Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed in #144.",
          "createdAt": "2019-03-06T00:55:10Z",
          "updatedAt": "2019-03-06T00:55:10Z"
        }
      ],
      "reviews": [],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "7b2c2f8b8ff9656a713b1449a50efb9ee8ca60bc",
      "headRepository": null,
      "headRefName": "rrtype-bis",
      "headRefOid": "e9f39739d5c24e739c777842b01c880b698dc31c",
      "mergeCommit": null
    },
    {
      "number": 76,
      "id": "MDExOlB1bGxSZXF1ZXN0MjAxNTAwODMy",
      "title": "add a iana instruction for _esni",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/76",
      "state": "MERGED",
      "author": "mcmanus",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "closes #75 ",
      "createdAt": "2018-07-15T14:28:55Z",
      "updatedAt": "2018-07-15T14:36:02Z",
      "closedAt": "2018-07-15T14:36:02Z",
      "mergedAt": "2018-07-15T14:36:02Z",
      "mergedBy": "ekr",
      "comments": [],
      "reviews": [],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "e72b0512cc779f2273f72a794af18a36598d19a2",
      "headRepository": "mcmanus/draft-rescorla-tls-esni",
      "headRefName": "attrleaf",
      "headRefOid": "d13c5c843b00248df342308beb897b3e8f494a3c",
      "mergeCommit": {
        "oid": "9b8f4362a7f7bed7507a5c6932fbb1be7b4989cf"
      }
    },
    {
      "number": 77,
      "id": "MDExOlB1bGxSZXF1ZXN0MjAxNTA3NTMy",
      "title": "Clarify that ServerNameList does not include extension wrapper.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/77",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-07-15T17:38:43Z",
      "updatedAt": "2018-07-16T20:32:47Z",
      "closedAt": "2018-07-16T20:32:47Z",
      "mergedAt": "2018-07-16T20:32:47Z",
      "mergedBy": "chris-wood",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTM3NTg1MDc3",
          "commit": {
            "abbreviatedOid": "5312695"
          },
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "LGTM.",
          "createdAt": "2018-07-16T20:31:59Z",
          "updatedAt": "2018-07-16T20:31:59Z",
          "comments": []
        }
      ],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "9b8f4362a7f7bed7507a5c6932fbb1be7b4989cf",
      "headRepository": null,
      "headRefName": "caw/clarify-encoding",
      "headRefOid": "53126950df6185be5c37a63da80172188ae2f446",
      "mergeCommit": {
        "oid": "49af7eb82f46c3fcc58f485d5abd7bcdbb65b5b2"
      }
    },
    {
      "number": 78,
      "id": "MDExOlB1bGxSZXF1ZXN0MjAxNzEyMDk5",
      "title": "Add versioning",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/78",
      "state": "CLOSED",
      "author": "tmshort",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Add versioning to the ESNI domain entry and the extension.\r\nAs this ID evolves, it will permit interoperability.\r\n\r\nAlso fix a minor type",
      "createdAt": "2018-07-16T18:01:16Z",
      "updatedAt": "2018-09-17T18:23:12Z",
      "closedAt": "2018-09-17T18:23:12Z",
      "mergedAt": null,
      "mergedBy": null,
      "comments": [
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "FWIW #63 discusses this.",
          "createdAt": "2018-07-17T05:27:42Z",
          "updatedAt": "2018-07-17T05:27:42Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "This was addressed in #90. Please re-open if that's not the case.",
          "createdAt": "2018-09-17T18:23:12Z",
          "updatedAt": "2018-09-17T18:23:12Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTM3ODUwOTE4",
          "commit": {
            "abbreviatedOid": "96c94d5"
          },
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-07-17T14:18:24Z",
          "updatedAt": "2018-07-17T14:18:24Z",
          "comments": [
            {
              "originalPosition": 45,
              "body": "~~I am not sure if we need to explicitly include the version of ESNIKeys in the TLS extension.\r\n\r\nCurrent approach assumes that the server looks for the corresponding ESNIKeys by checking the value of `record_digests`. That will lead you to the ESNIKeys that contains a version. Having another version seems unnecessary complication to me.~~\r\n\r\nSorry for the noise, I now notice that the proposal is to offer a list of versions using ESNIKeys and let the client select one in the TLS extension. Please let me retract my comment.",
              "createdAt": "2018-07-17T14:18:24Z",
              "updatedAt": "2018-07-17T14:21:12Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTM3ODUzMjI1",
          "commit": {
            "abbreviatedOid": "96c94d5"
          },
          "author": "tmshort",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-07-17T14:23:05Z",
          "updatedAt": "2018-07-17T14:23:06Z",
          "comments": [
            {
              "originalPosition": 45,
              "body": "A server can support multiple versions of the draft; it is a list in the DNS record, and the record digest would be the same for all versions in that list.\r\n\r\nYou are correct that the record_digest would be updated when a server adds support for a new version of ESNI, but that doesn't indicate *which* version of ESNI the client is trying to use.",
              "createdAt": "2018-07-17T14:23:05Z",
              "updatedAt": "2018-07-17T14:23:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTM3ODU1NjY4",
          "commit": {
            "abbreviatedOid": "96c94d5"
          },
          "author": "tmshort",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-07-17T14:27:55Z",
          "updatedAt": "2018-07-17T14:27:55Z",
          "comments": [
            {
              "originalPosition": 45,
              "body": "Example:\r\n```\r\nRecord digest for version list [0xFF01] = 0x01234567\r\nRecord digest for version list [0xFF01, 0xFF02] = 0x89ABCDEF\r\n```\r\nUsing record digest 0x89ABCDEF won't indicate which version is in use; 0xFF02 can't be assumed since 0xFF01 is still listed as being supported",
              "createdAt": "2018-07-17T14:27:55Z",
              "updatedAt": "2018-07-17T14:27:56Z"
            }
          ]
        }
      ],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "9b8f4362a7f7bed7507a5c6932fbb1be7b4989cf",
      "headRepository": "tmshort/draft-rescorla-tls-esni",
      "headRefName": "master-tmshort-rev",
      "headRefOid": "96c94d5ef23e68c7a7c89a2089429a3da1349a59",
      "mergeCommit": null
    },
    {
      "number": 85,
      "id": "MDExOlB1bGxSZXF1ZXN0MjA2MjYxNzg0",
      "title": "Mix the server record (digest), client key share, and client random into the ESNI key derivation.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/85",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Addresses #81.",
      "createdAt": "2018-08-05T22:40:32Z",
      "updatedAt": "2018-08-20T15:04:24Z",
      "closedAt": "2018-08-20T15:04:24Z",
      "mergedAt": null,
      "mergedBy": null,
      "comments": [
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "This is an improvement, but I thought we had agreed to move towards the separate keys/AAD approach?",
          "createdAt": "2018-08-07T13:14:03Z",
          "updatedAt": "2018-08-07T13:14:03Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "We did, but that\u2019s slightly orthogonal. I\u2019ll do that in a separate PR. ",
          "createdAt": "2018-08-07T13:44:44Z",
          "updatedAt": "2018-08-07T13:44:44Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTQzOTc3OTI4",
          "commit": {
            "abbreviatedOid": "134b15c"
          },
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "LGTM :+1:",
          "createdAt": "2018-08-07T12:50:59Z",
          "updatedAt": "2018-08-07T12:50:59Z",
          "comments": []
        }
      ],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "49af7eb82f46c3fcc58f485d5abd7bcdbb65b5b2",
      "headRepository": null,
      "headRefName": "caw/contributive",
      "headRefOid": "134b15c87b5c4cde7f52500138662f64757e2e9c",
      "mergeCommit": null
    },
    {
      "number": 86,
      "id": "MDExOlB1bGxSZXF1ZXN0MjA2Mjg2NzA2",
      "title": "Add advice about query strategy.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/86",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-08-06T04:33:00Z",
      "updatedAt": "2018-08-14T15:38:27Z",
      "closedAt": "2018-08-14T15:38:27Z",
      "mergedAt": "2018-08-14T15:38:27Z",
      "mergedBy": "ekr",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@mcmanus please have a look!",
          "createdAt": "2018-08-07T16:02:29Z",
          "updatedAt": "2018-08-07T16:02:29Z"
        }
      ],
      "reviews": [],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "49af7eb82f46c3fcc58f485d5abd7bcdbb65b5b2",
      "headRepository": null,
      "headRefName": "caw/query",
      "headRefOid": "3152be598fbfcef510b89589963389c1cedbe0a3",
      "mergeCommit": {
        "oid": "3d52a23db2ddda6279c1915b5224789ccf5d951a"
      }
    },
    {
      "number": 87,
      "id": "MDExOlB1bGxSZXF1ZXN0MjA2NzU4OTYw",
      "title": "Separate the key shares used by the TLS handshake and ESNI to avoid downgrade",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/87",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-08-07T16:37:46Z",
      "updatedAt": "2018-08-20T15:13:09Z",
      "closedAt": "2018-08-20T15:13:09Z",
      "mergedAt": "2018-08-20T15:13:09Z",
      "mergedBy": "ekr",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTQ2MTI2MDk4",
          "commit": {
            "abbreviatedOid": "3a96c00"
          },
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2018-08-14T15:39:55Z",
          "updatedAt": "2018-08-14T15:43:40Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "I would call this |key_share|",
              "createdAt": "2018-08-14T15:39:55Z",
              "updatedAt": "2018-08-20T15:12:23Z"
            },
            {
              "originalPosition": 65,
              "body": "I think this is not quite what we want.\r\n\r\nI think rather the hash should be:\r\n\r\n```Hash(record_digest || EncryptedSNI.entry || ClientHello.Random)```\r\n\r\nAnd then you want to have the AAD include ClientHello.key_shares.\r\n",
              "createdAt": "2018-08-14T15:43:17Z",
              "updatedAt": "2018-08-20T15:12:23Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTQ2MTMyMDYy",
          "commit": {
            "abbreviatedOid": "3a96c00"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-08-14T15:52:20Z",
          "updatedAt": "2018-08-14T15:52:20Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "That works for me.",
              "createdAt": "2018-08-14T15:52:20Z",
              "updatedAt": "2018-08-20T15:12:23Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTQ2MTM0Mzg1",
          "commit": {
            "abbreviatedOid": "3a96c00"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-08-14T15:57:33Z",
          "updatedAt": "2018-08-14T15:57:33Z",
          "comments": [
            {
              "originalPosition": 65,
              "body": "EncryptedSNI.entry is already mixed in by virtue of being used to derive the KDF input secret. Putting ClientHello.KeyShareClientHello here or in the AAD has the same affect on malleability.",
              "createdAt": "2018-08-14T15:57:33Z",
              "updatedAt": "2018-08-20T15:12:23Z"
            }
          ]
        }
      ],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "49af7eb82f46c3fcc58f485d5abd7bcdbb65b5b2",
      "headRepository": null,
      "headRefName": "caw/separate-keyshares",
      "headRefOid": "0a47e5b16eecb49678ec83fcbf3e3dd3e321f32f",
      "mergeCommit": {
        "oid": "6995fd93a9a69363581b531318115543c9afb6bf"
      }
    },
    {
      "number": 89,
      "id": "MDExOlB1bGxSZXF1ZXN0MjEzMDMxNDY3",
      "title": "Caw/echo nonce",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/89",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This is a proposal to address the misrouting and key share replacement attacks identified by Ekr, Karthik, and Benjamin. Please help me improve it!",
      "createdAt": "2018-09-04T16:15:15Z",
      "updatedAt": "2018-09-10T17:03:44Z",
      "closedAt": "2018-09-10T17:03:44Z",
      "mergedAt": "2018-09-10T17:03:44Z",
      "mergedBy": "chris-wood",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTUyMjUwMDAx",
          "commit": {
            "abbreviatedOid": "b5e60f8"
          },
          "author": "ghedo",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "Some minor nits.",
          "createdAt": "2018-09-04T20:55:53Z",
          "updatedAt": "2018-09-04T21:04:08Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "This should be `encrypted_server_name(0xffce)` to match IANA considerations.",
              "createdAt": "2018-09-04T20:55:53Z",
              "updatedAt": "2018-09-10T12:43:33Z"
            },
            {
              "originalPosition": 23,
              "body": "Should update the \"TLS 1.3\" column in IANA considerations for the extension to be \"CH, EE\".",
              "createdAt": "2018-09-04T20:58:01Z",
              "updatedAt": "2018-09-10T12:43:33Z"
            },
            {
              "originalPosition": 86,
              "body": "s/if/it/",
              "createdAt": "2018-09-04T21:01:55Z",
              "updatedAt": "2018-09-10T12:43:33Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTUyMjc2Mjcx",
          "commit": {
            "abbreviatedOid": "b5e60f8"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-09-04T22:23:11Z",
          "updatedAt": "2018-09-04T22:23:12Z",
          "comments": [
            {
              "originalPosition": 86,
              "body": "Fixed!",
              "createdAt": "2018-09-04T22:23:12Z",
              "updatedAt": "2018-09-10T12:43:33Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTUyMjc2MzEz",
          "commit": {
            "abbreviatedOid": "84053dd"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-09-04T22:23:22Z",
          "updatedAt": "2018-09-04T22:23:22Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "Fixed!\r\n",
              "createdAt": "2018-09-04T22:23:22Z",
              "updatedAt": "2018-09-10T12:43:33Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTUyMjc2MzMx",
          "commit": {
            "abbreviatedOid": "84053dd"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-09-04T22:23:25Z",
          "updatedAt": "2018-09-04T22:23:26Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "Fixed!\r\n",
              "createdAt": "2018-09-04T22:23:26Z",
              "updatedAt": "2018-09-10T12:43:33Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTUzNzI5MTU4",
          "commit": {
            "abbreviatedOid": "84053dd"
          },
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2018-09-10T11:24:03Z",
          "updatedAt": "2018-09-10T11:26:05Z",
          "comments": [
            {
              "originalPosition": 45,
              "body": "Because the nonce is constant-length, I wouldn't include it in the padding calculation",
              "createdAt": "2018-09-10T11:24:03Z",
              "updatedAt": "2018-09-10T12:43:33Z"
            },
            {
              "originalPosition": 68,
              "body": "I think either of these is correct.",
              "createdAt": "2018-09-10T11:24:14Z",
              "updatedAt": "2018-09-10T12:43:33Z"
            },
            {
              "originalPosition": 90,
              "body": "This could be read as saying that the client must abort if it doesn't check. Maybe \"provided by the server, and otherwise abort the connection ....\"",
              "createdAt": "2018-09-10T11:24:41Z",
              "updatedAt": "2018-09-10T12:43:33Z"
            },
            {
              "originalPosition": 118,
              "body": "This text seems OBE. This mechanism won't work unless the backend has nonce, so you might as well give it SNI too.",
              "createdAt": "2018-09-10T11:25:48Z",
              "updatedAt": "2018-09-10T12:43:33Z"
            },
            {
              "originalPosition": 180,
              "body": "This text also seems OBE.",
              "createdAt": "2018-09-10T11:25:59Z",
              "updatedAt": "2018-09-10T12:43:33Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTUzNzQ2MTM1",
          "commit": {
            "abbreviatedOid": "84053dd"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-09-10T12:20:32Z",
          "updatedAt": "2018-09-10T12:20:32Z",
          "comments": [
            {
              "originalPosition": 45,
              "body": "Works for me. ",
              "createdAt": "2018-09-10T12:20:32Z",
              "updatedAt": "2018-09-10T12:43:33Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTUzNzQ2NjY0",
          "commit": {
            "abbreviatedOid": "84053dd"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-09-10T12:21:59Z",
          "updatedAt": "2018-09-10T12:40:40Z",
          "comments": [
            {
              "originalPosition": 90,
              "body": "Yep, good suggestion. Fixed.",
              "createdAt": "2018-09-10T12:21:59Z",
              "updatedAt": "2018-09-10T12:43:33Z"
            },
            {
              "originalPosition": 118,
              "body": "Good catch. I'll make this point to the preceding section.",
              "createdAt": "2018-09-10T12:29:58Z",
              "updatedAt": "2018-09-10T12:43:33Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTUzNzUzMzU1",
          "commit": {
            "abbreviatedOid": "84053dd"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-09-10T12:41:46Z",
          "updatedAt": "2018-09-10T12:41:46Z",
          "comments": [
            {
              "originalPosition": 68,
              "body": "The article seems necessary. Or at least it reads odd without it.",
              "createdAt": "2018-09-10T12:41:46Z",
              "updatedAt": "2018-09-10T12:43:33Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTUzNzUzNDQy",
          "commit": {
            "abbreviatedOid": "84053dd"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-09-10T12:42:00Z",
          "updatedAt": "2018-09-10T12:42:00Z",
          "comments": [
            {
              "originalPosition": 180,
              "body": "Yep, addressed, and also removed the hand-wavy bit.",
              "createdAt": "2018-09-10T12:42:00Z",
              "updatedAt": "2018-09-10T12:43:33Z"
            }
          ]
        }
      ],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "6995fd93a9a69363581b531318115543c9afb6bf",
      "headRepository": null,
      "headRefName": "caw/echo-nonce",
      "headRefOid": "6eb942287b53da31eece48bab25d1a3ac945e284",
      "mergeCommit": {
        "oid": "e3cd3f544b0018a4b42621a9a12b62ff92d81cdf"
      }
    },
    {
      "number": 90,
      "id": "MDExOlB1bGxSZXF1ZXN0MjE1NzcwMTU5",
      "title": "Version number",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/90",
      "state": "MERGED",
      "author": "ekr",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-09-15T13:50:23Z",
      "updatedAt": "2018-09-16T20:03:23Z",
      "closedAt": "2018-09-16T20:03:23Z",
      "mergedAt": "2018-09-16T20:03:23Z",
      "mergedBy": "chris-wood",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTU1NzE1ODEw",
          "commit": {
            "abbreviatedOid": "f83f937"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "Looks good \u2014 two minor comments.",
          "createdAt": "2018-09-15T14:54:47Z",
          "updatedAt": "2018-09-15T14:56:32Z",
          "comments": [
            {
              "originalPosition": 27,
              "body": "I\u2019d replace \u201cmultiple TXT records\u201d with \u201cmultiple ESNIKeys structures.\u201d",
              "createdAt": "2018-09-15T14:54:47Z",
              "updatedAt": "2018-09-16T19:39:43Z"
            },
            {
              "originalPosition": 29,
              "body": "This should be fine, as clients tell servers which one via the digest. If a client-facing server can\u2019t handle any ESNI for a version it has published then that seems to be a configuration error, no? ",
              "createdAt": "2018-09-15T14:56:11Z",
              "updatedAt": "2018-09-16T19:39:43Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTU1NzU2MDQ3",
          "commit": {
            "abbreviatedOid": "792ec78"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-09-16T19:46:38Z",
          "updatedAt": "2018-09-16T19:46:38Z",
          "comments": []
        }
      ],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "1e7bf63593a342fd15ee065450686ed9b99a8d7f",
      "headRepository": "tlswg/draft-ietf-tls-esni",
      "headRefName": "version_number",
      "headRefOid": "792ec78c70cb3f8d8c26d6c07b3f507f14ead029",
      "mergeCommit": {
        "oid": "a5c6ac1843f5cc251c32723f2686b3d8066aa0fa"
      }
    },
    {
      "number": 91,
      "id": "MDExOlB1bGxSZXF1ZXN0MjE1ODQxMTc1",
      "title": "Reorder the extension in a more logical way to make padding easier.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/91",
      "state": "MERGED",
      "author": "ekr",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-09-16T19:37:54Z",
      "updatedAt": "2018-09-16T22:10:06Z",
      "closedAt": "2018-09-16T22:10:06Z",
      "mergedAt": "2018-09-16T22:10:06Z",
      "mergedBy": "chris-wood",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTU1NzU2NTIx",
          "commit": {
            "abbreviatedOid": "e844c86"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2018-09-16T20:05:23Z",
          "updatedAt": "2018-09-16T20:07:55Z",
          "comments": [
            {
              "originalPosition": 118,
              "body": "This should be ClientESNIInner.",
              "createdAt": "2018-09-16T20:05:23Z",
              "updatedAt": "2018-09-16T22:03:17Z"
            },
            {
              "originalPosition": 23,
              "body": "If you're renaming this, I'd rename the client one, too. (ClientEncryptedSNI)",
              "createdAt": "2018-09-16T20:07:19Z",
              "updatedAt": "2018-09-16T22:03:17Z"
            },
            {
              "originalPosition": 28,
              "body": "Missing ClientESNIInner prefix to .nonce.",
              "createdAt": "2018-09-16T20:07:48Z",
              "updatedAt": "2018-09-16T22:03:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTU1NzU2ODA1",
          "commit": {
            "abbreviatedOid": "1ee113b"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2018-09-16T20:15:26Z",
          "updatedAt": "2018-09-16T20:17:01Z",
          "comments": [
            {
              "originalPosition": 111,
              "body": "Capital Client",
              "createdAt": "2018-09-16T20:15:26Z",
              "updatedAt": "2018-09-16T22:03:17Z"
            }
          ]
        }
      ],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "a5c6ac1843f5cc251c32723f2686b3d8066aa0fa",
      "headRepository": "tlswg/draft-ietf-tls-esni",
      "headRefName": "reorder_psnl",
      "headRefOid": "a35fbb358e8a13fe9097a3b6f284c0c11625b14e",
      "mergeCommit": {
        "oid": "71105a168d81a7bb11e37d18fe147f27ab395f72"
      }
    },
    {
      "number": 92,
      "id": "MDExOlB1bGxSZXF1ZXN0MjE2MDM4NTQ1",
      "title": "Clarify",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/92",
      "state": "MERGED",
      "author": "ekr",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-09-17T16:17:48Z",
      "updatedAt": "2018-09-17T16:37:24Z",
      "closedAt": "2018-09-17T16:37:24Z",
      "mergedAt": "2018-09-17T16:37:24Z",
      "mergedBy": "chris-wood",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTU2MDE0NTcz",
          "commit": {
            "abbreviatedOid": "4f9b8f0"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-09-17T16:37:13Z",
          "updatedAt": "2018-09-17T16:37:13Z",
          "comments": []
        }
      ],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "d1caee56da2f49ea38f9c064d26049aaf8d2418e",
      "headRepository": "tlswg/draft-ietf-tls-esni",
      "headRefName": "clarify_key_share",
      "headRefOid": "4f9b8f06329aba4952ddab94a58146f24cafab30",
      "mergeCommit": {
        "oid": "1dd0d218b8a12dcbf695338b4880bd677e440b76"
      }
    },
    {
      "number": 93,
      "id": "MDExOlB1bGxSZXF1ZXN0MjE2MzMwMjY3",
      "title": "Clarify what encrypted_sni is",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/93",
      "state": "MERGED",
      "author": "ghedo",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-09-18T14:32:14Z",
      "updatedAt": "2018-09-18T14:33:17Z",
      "closedAt": "2018-09-18T14:33:17Z",
      "mergedAt": "2018-09-18T14:33:17Z",
      "mergedBy": "ekr",
      "comments": [],
      "reviews": [],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "1dd0d218b8a12dcbf695338b4880bd677e440b76",
      "headRepository": null,
      "headRefName": "encrypted_sni",
      "headRefOid": "34522b7c617dd80873818f49cf506bd93aa69447",
      "mergeCommit": {
        "oid": "682928e63c897ff5fba83693625a70073b0978c1"
      }
    },
    {
      "number": 94,
      "id": "MDExOlB1bGxSZXF1ZXN0MjE2MzMzNTMz",
      "title": "Calculate checksum over the whole structure",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/94",
      "state": "MERGED",
      "author": "ghedo",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-09-18T14:41:02Z",
      "updatedAt": "2018-09-18T15:38:01Z",
      "closedAt": "2018-09-18T15:38:00Z",
      "mergedAt": "2018-09-18T15:38:00Z",
      "mergedBy": "chris-wood",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@ekr @kazuho what do you think?",
          "createdAt": "2018-09-18T14:42:35Z",
          "updatedAt": "2018-09-18T14:42:35Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTU2NDA0Njgz",
          "commit": {
            "abbreviatedOid": "dfe0948"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-09-18T14:42:17Z",
          "updatedAt": "2018-09-18T14:42:17Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTU2NDExMTc1",
          "commit": {
            "abbreviatedOid": "dfe0948"
          },
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": ":+1:",
          "createdAt": "2018-09-18T14:54:21Z",
          "updatedAt": "2018-09-18T14:54:21Z",
          "comments": []
        }
      ],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "682928e63c897ff5fba83693625a70073b0978c1",
      "headRepository": null,
      "headRefName": "checksum",
      "headRefOid": "dfe09481d3eead6825da3e7a79e8640a1693ef1f",
      "mergeCommit": {
        "oid": "67fb40a4bee107293a3f835673a76015f9acd79f"
      }
    },
    {
      "number": 95,
      "id": "MDExOlB1bGxSZXF1ZXN0MjE2MzM0OTM2",
      "title": "Clarify clarification",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/95",
      "state": "MERGED",
      "author": "ghedo",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-09-18T14:44:55Z",
      "updatedAt": "2018-09-18T15:38:44Z",
      "closedAt": "2018-09-18T15:38:44Z",
      "mergedAt": "2018-09-18T15:38:44Z",
      "mergedBy": "chris-wood",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTU2NDA4MzE5",
          "commit": {
            "abbreviatedOid": "6e2e80c"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-09-18T14:49:04Z",
          "updatedAt": "2018-09-18T14:49:04Z",
          "comments": []
        }
      ],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "682928e63c897ff5fba83693625a70073b0978c1",
      "headRepository": null,
      "headRefName": "clarify_clarify",
      "headRefOid": "6e2e80c32f0e2bdec5db3649ac0e7a7474f1583a",
      "mergeCommit": {
        "oid": "bff4cee30cec7e8a4ba0397dbc58dc93201fa8cd"
      }
    },
    {
      "number": 96,
      "id": "MDExOlB1bGxSZXF1ZXN0MjE2Mzg0MjMx",
      "title": "Update version to 0xff01 for draft",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/96",
      "state": "MERGED",
      "author": "ghedo",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-09-18T17:23:14Z",
      "updatedAt": "2018-09-18T17:24:22Z",
      "closedAt": "2018-09-18T17:24:22Z",
      "mergedAt": "2018-09-18T17:24:21Z",
      "mergedBy": "kazuho",
      "comments": [],
      "reviews": [],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "bff4cee30cec7e8a4ba0397dbc58dc93201fa8cd",
      "headRepository": null,
      "headRefName": "version",
      "headRefOid": "5442864faab95a1bc79922f25748886d3b4adfff",
      "mergeCommit": {
        "oid": "7b2c2f8b8ff9656a713b1449a50efb9ee8ca60bc"
      }
    },
    {
      "number": 98,
      "id": "MDExOlB1bGxSZXF1ZXN0MjE3NjY4MDAx",
      "title": "Clarify what the server must do with server_name",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/98",
      "state": "MERGED",
      "author": "ghedo",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-09-24T14:04:24Z",
      "updatedAt": "2018-09-24T14:32:05Z",
      "closedAt": "2018-09-24T14:32:05Z",
      "mergedAt": "2018-09-24T14:32:05Z",
      "mergedBy": "chris-wood",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Discussed offline.",
          "createdAt": "2018-09-24T14:31:57Z",
          "updatedAt": "2018-09-24T14:31:57Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTU4MTE5OTUw",
          "commit": {
            "abbreviatedOid": "a5cfc3a"
          },
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-09-24T14:07:06Z",
          "updatedAt": "2018-09-24T14:07:09Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "Maybe instead MUST NOT send the \"server_name\" extension to the client.",
              "createdAt": "2018-09-24T14:07:06Z",
              "updatedAt": "2018-09-24T14:16:56Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTU4MTIwNDUx",
          "commit": {
            "abbreviatedOid": "a5cfc3a"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2018-09-24T14:08:06Z",
          "updatedAt": "2018-09-24T14:08:13Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "I'm not sure this is consistent with the text above, which reads: \"The client MAY either omit the \"server_name\" extension or provide  an innocuous dummy one (this is required for technical conformance with {{!RFC7540}}; Section 9.2.).\" It seems we can only prohibit servers from echoing server_name iff the client is also prohibited from sending it in conjunction with ESNI.",
              "createdAt": "2018-09-24T14:08:07Z",
              "updatedAt": "2018-09-24T14:16:56Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTU4MTI0MDA1",
          "commit": {
            "abbreviatedOid": "a5cfc3a"
          },
          "author": "ghedo",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-09-24T14:15:33Z",
          "updatedAt": "2018-09-24T14:15:33Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "The server doesn't have to send server_name even if the client does. That is, irrespective of ESNI, the server can decide to ignore the server_name from the client and not send server_name at all. So, the client can send a dummy server_name, but the server is not going to use it (if nothing else, because it's \"dummy\"), so it shouldn't send server_name.",
              "createdAt": "2018-09-24T14:15:33Z",
              "updatedAt": "2018-09-24T14:16:56Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTU4MTI0NzYy",
          "commit": {
            "abbreviatedOid": "3655e4c"
          },
          "author": "ghedo",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-09-24T14:17:02Z",
          "updatedAt": "2018-09-24T14:17:02Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "Ok, fixed.",
              "createdAt": "2018-09-24T14:17:02Z",
              "updatedAt": "2018-09-24T14:17:02Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTU4MTI3NTMz",
          "commit": {
            "abbreviatedOid": "3655e4c"
          },
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-09-24T14:22:41Z",
          "updatedAt": "2018-09-24T14:22:41Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "I don't think that's true. There's no hard requirement that the server echo SNI. It only must echo it if it used \"the information contained in the extension to guide  its selection of an appropriate certificate to return to the client, and/or other aspects of security policy\".  But a server that ignores SNI doesn't have to do anything. Concretely, NSS only echoes SNI if there is an SNI callback installed.\r\n\r\n",
              "createdAt": "2018-09-24T14:22:41Z",
              "updatedAt": "2018-09-24T14:22:41Z"
            }
          ]
        }
      ],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "7b2c2f8b8ff9656a713b1449a50efb9ee8ca60bc",
      "headRepository": null,
      "headRefName": "sni_ack",
      "headRefOid": "3655e4c9d64c470790fb7dc432fe304a126e9a1c",
      "mergeCommit": {
        "oid": "b74e843a0e6db2553e216df6508296e5a3cc5292"
      }
    },
    {
      "number": 100,
      "id": "MDExOlB1bGxSZXF1ZXN0MjIzNzc3Njcz",
      "title": "clarify for alt-svc that we lookup txt/esni from origin name. closes #61",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/100",
      "state": "MERGED",
      "author": "mcmanus",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-10-17T22:54:58Z",
      "updatedAt": "2018-10-21T20:52:40Z",
      "closedAt": "2018-10-21T20:52:40Z",
      "mergedAt": "2018-10-21T20:52:40Z",
      "mergedBy": "ekr",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTY1OTE1MDk2",
          "commit": {
            "abbreviatedOid": "88cc4bb"
          },
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-10-18T03:41:53Z",
          "updatedAt": "2018-10-18T03:41:53Z",
          "comments": []
        }
      ],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "b74e843a0e6db2553e216df6508296e5a3cc5292",
      "headRepository": "mcmanus/draft-rescorla-tls-esni",
      "headRefName": "mcmanus-61",
      "headRefOid": "88cc4bb5ef44c88d878d76bc33e87d169ac01563",
      "mergeCommit": {
        "oid": "35ab3043ffb8e4a266407e1750c9aa8c932cb440"
      }
    },
    {
      "number": 101,
      "id": "MDExOlB1bGxSZXF1ZXN0MjI0NTY1NzU2",
      "title": "Abort the handshake if the server does not negotiate TLS 1.3.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/101",
      "state": "MERGED",
      "author": "ekr",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-10-21T20:10:13Z",
      "updatedAt": "2018-10-21T20:22:00Z",
      "closedAt": "2018-10-21T20:17:50Z",
      "mergedAt": "2018-10-21T20:17:50Z",
      "mergedBy": "chris-wood",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTY2Nzk5MTAz",
          "commit": {
            "abbreviatedOid": "342e1eb"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-10-21T20:17:46Z",
          "updatedAt": "2018-10-21T20:17:46Z",
          "comments": []
        }
      ],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "b74e843a0e6db2553e216df6508296e5a3cc5292",
      "headRepository": "tlswg/draft-ietf-tls-esni",
      "headRefName": "reject_tls12",
      "headRefOid": "342e1ebc6e9675741d96d6c532047c24645e6188",
      "mergeCommit": {
        "oid": "3fcacbeb8f4feb5f80ea89460a4252c3bea12b72"
      }
    },
    {
      "number": 102,
      "id": "MDExOlB1bGxSZXF1ZXN0MjI0NTY2NDY2",
      "title": "Clarify that if you can't negotiate ESNI, you should act as if none o\u2026",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/102",
      "state": "MERGED",
      "author": "ekr",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "\u2026f the ESNI Keys values were present",
      "createdAt": "2018-10-21T20:22:16Z",
      "updatedAt": "2018-10-21T22:29:24Z",
      "closedAt": "2018-10-21T22:29:24Z",
      "mergedAt": "2018-10-21T22:29:24Z",
      "mergedBy": "kazuho",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTY2Nzk5Mjgy",
          "commit": {
            "abbreviatedOid": "4b7f49a"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2018-10-21T20:23:03Z",
          "updatedAt": "2018-10-21T20:24:41Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "s/non/no",
              "createdAt": "2018-10-21T20:23:03Z",
              "updatedAt": "2018-10-21T22:15:48Z"
            },
            {
              "originalPosition": 33,
              "body": "By \"another value\" I assume you mean a ESNIKeys structure obtained through some other means?",
              "createdAt": "2018-10-21T20:23:50Z",
              "updatedAt": "2018-10-21T22:15:48Z"
            },
            {
              "originalPosition": 5,
              "body": "Should we make this a MUST? This is different from the group/ciphersuite mismatch issue. ",
              "createdAt": "2018-10-21T20:24:39Z",
              "updatedAt": "2018-10-21T22:15:48Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTY2Nzk5Mzg3",
          "commit": {
            "abbreviatedOid": "4b7f49a"
          },
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-10-21T20:26:15Z",
          "updatedAt": "2018-10-21T20:26:15Z",
          "comments": [
            {
              "originalPosition": 33,
              "body": "No I mean say you give me two ESNIKeys structures, one of which advertises only 25519 and one of which advertises only P-256, and for some reason I only like P-256, but I try the 25519 one first\r\n",
              "createdAt": "2018-10-21T20:26:15Z",
              "updatedAt": "2018-10-21T22:15:48Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTY2Nzk5NDI5",
          "commit": {
            "abbreviatedOid": "5a90f15"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-10-21T20:27:06Z",
          "updatedAt": "2018-10-21T20:27:06Z",
          "comments": [
            {
              "originalPosition": 33,
              "body": "Gotcha -- we should clarify that, I think. How about: \"If the client is unable to select an appropriate group or suite it SHOULD ignore that ESNIKeys value and MAY attempt to use another value provided by the server. (Recall that servers may provide multiple ESNIKeys in response to a ESNI TXT query.)\"?",
              "createdAt": "2018-10-21T20:27:06Z",
              "updatedAt": "2018-10-21T22:15:48Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTY2Nzk5NTI2",
          "commit": {
            "abbreviatedOid": "376b34f"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-10-21T20:29:56Z",
          "updatedAt": "2018-10-21T20:29:56Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTY2ODAzMDA0",
          "commit": {
            "abbreviatedOid": "376b34f"
          },
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-10-21T22:08:40Z",
          "updatedAt": "2018-10-21T22:09:42Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "\"should\" should be in upper case?",
              "createdAt": "2018-10-21T22:08:40Z",
              "updatedAt": "2018-10-21T22:15:48Z"
            },
            {
              "originalPosition": 31,
              "body": "\"servers may provide\": lower-case \"may\". Change it to \"might\"?",
              "createdAt": "2018-10-21T22:09:24Z",
              "updatedAt": "2018-10-21T22:15:48Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTY2ODAzMDk2",
          "commit": {
            "abbreviatedOid": "376b34f"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-10-21T22:11:36Z",
          "updatedAt": "2018-10-21T22:11:36Z",
          "comments": [
            {
              "originalPosition": 31,
              "body": "\ud83d\udc4d ",
              "createdAt": "2018-10-21T22:11:36Z",
              "updatedAt": "2018-10-21T22:15:48Z"
            }
          ]
        }
      ],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "3fcacbeb8f4feb5f80ea89460a4252c3bea12b72",
      "headRepository": "tlswg/draft-ietf-tls-esni",
      "headRefName": "clarify_soft_fail",
      "headRefOid": "c114216ff895005b361cce73c6b37d89b805216c",
      "mergeCommit": {
        "oid": "bf4f394215d04aafefaf8870285d27866abad217"
      }
    },
    {
      "number": 104,
      "id": "MDExOlB1bGxSZXF1ZXN0MjI1NTQ4OTI0",
      "title": "Restrict keys to address records in the same canonical name.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/104",
      "state": "CLOSED",
      "author": "mcmanus",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "fixes #35 \r\n\r\nthis would be a bit cleaner if we got rid of the prefix.. which I think we ought to do as well but is separable.",
      "createdAt": "2018-10-24T20:59:49Z",
      "updatedAt": "2019-06-27T20:23:36Z",
      "closedAt": "2019-06-27T20:23:36Z",
      "mergedAt": null,
      "mergedBy": null,
      "comments": [
        {
          "author": "mcmanus",
          "authorAssociation": "CONTRIBUTOR",
          "body": "mostly obe #136 and #137",
          "createdAt": "2019-06-27T20:23:36Z",
          "updatedAt": "2019-06-27T20:23:36Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTY4MTI0ODky",
          "commit": {
            "abbreviatedOid": "ca03799"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "This has the effect of creating a different resolution method for _esni, which I'm a little concerned about.",
          "createdAt": "2018-10-24T21:19:36Z",
          "updatedAt": "2018-10-24T21:28:03Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "```suggestion\r\ninformation to implement ESNI. The server is identified through DNS\r\n```",
              "createdAt": "2018-10-24T21:19:36Z",
              "updatedAt": "2018-10-25T19:47:41Z"
            },
            {
              "originalPosition": 19,
              "body": "does \"address records\" mean A or AAAA?",
              "createdAt": "2018-10-24T21:20:05Z",
              "updatedAt": "2018-10-25T19:47:41Z"
            },
            {
              "originalPosition": 60,
              "body": "How does it know that the TXT record is the one that needs updating?  It is presented with a mismatch, with TTLs.  Should we instead recommend requesting both, or does that invite problems?\r\n\r\nDoes it start over from _esni.example.com, or does this allow for an end-run on the CNAME resolution process from the prefixed domain.  That is, if www.example.com is CNAMEd through various intermediaries to providerA.example, does the client just construct _esni.providerA.example, or does it have to go back to _esni.example.com?  I get the problem - if this is load balanced, how do we ensure that this ends up routing the same way?  So why would you not just start with _esni.providerA.example then?",
              "createdAt": "2018-10-24T21:26:46Z",
              "updatedAt": "2018-10-25T19:47:41Z"
            },
            {
              "originalPosition": 35,
              "body": "```suggestion\r\nthe client MUST confirm that the unprefixed (i.e., lacking the\r\n```",
              "createdAt": "2018-10-24T21:26:53Z",
              "updatedAt": "2018-10-25T19:47:41Z"
            },
            {
              "originalPosition": 55,
              "body": "```suggestion\r\n     -> \"... KEY FOR B ...\"\r\n```",
              "createdAt": "2018-10-24T21:27:16Z",
              "updatedAt": "2018-10-25T19:47:41Z"
            },
            {
              "originalPosition": 64,
              "body": "```suggestion\r\n        -> \"... KEY FOR A ...\"\r\n```",
              "createdAt": "2018-10-24T21:27:24Z",
              "updatedAt": "2018-10-25T19:47:41Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTY4MTMzNzE5",
          "commit": {
            "abbreviatedOid": "5804df7"
          },
          "author": "mcmanus",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-10-24T21:44:39Z",
          "updatedAt": "2018-10-24T21:44:39Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "yes.. I don't mind saying a/aaaa I was trying to leave room for other ways of specifying the address. srv? new A* type?",
              "createdAt": "2018-10-24T21:44:39Z",
              "updatedAt": "2018-10-25T19:47:41Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTY4MTM1MDQ4",
          "commit": {
            "abbreviatedOid": "5804df7"
          },
          "author": "mcmanus",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-10-24T21:48:32Z",
          "updatedAt": "2018-10-24T21:48:32Z",
          "comments": [
            {
              "originalPosition": 60,
              "body": "My thought here is that the TXT record is the new kid on the block, so deference ought to be given to the A for backwards compatibility.\r\n\r\nif you're trying to loadbalance, you may well be doing so to add/delete traffic from certain regions (and people have been known to choose providers due to their strengths in particular regions) so capturing the traffic in service of using a valid key seems sub-optimal.. \r\n\r\nI wouldn't be surprised to see keys with bigger TTLs than the A's - creating an easy scenario for the mismatch to occur.. and we wouldn't want the routing of traffic impacted by that imo.",
              "createdAt": "2018-10-24T21:48:32Z",
              "updatedAt": "2018-10-25T19:47:41Z"
            }
          ]
        }
      ],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "bf4f394215d04aafefaf8870285d27866abad217",
      "headRepository": "mcmanus/draft-rescorla-tls-esni",
      "headRefName": "mcmanus-35",
      "headRefOid": "ec9f09c84750d1c03bb3ed4cbae44e3f63553f6d",
      "mergeCommit": null
    },
    {
      "number": 106,
      "id": "MDExOlB1bGxSZXF1ZXN0MjI2MDExNDcx",
      "title": "Fix two typos in text",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/106",
      "state": "MERGED",
      "author": "thomwiggers",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "There were two minor typos. This PR fixes them.\n\nWhile I was at it, I ran `aspell` over it, most seemed fine.",
      "createdAt": "2018-10-26T08:12:35Z",
      "updatedAt": "2018-10-27T04:53:30Z",
      "closedAt": "2018-10-27T04:53:30Z",
      "mergedAt": "2018-10-27T04:53:30Z",
      "mergedBy": "chris-wood",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTY5MDQzNzI0",
          "commit": {
            "abbreviatedOid": "c37cfa3"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-10-27T04:53:24Z",
          "updatedAt": "2018-10-27T04:53:24Z",
          "comments": []
        }
      ],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "bf4f394215d04aafefaf8870285d27866abad217",
      "headRepository": "thomwiggers/draft-ietf-tls-esni",
      "headRefName": "typos",
      "headRefOid": "c37cfa3ffbfe908d7b7b9f70ab601e77e66ebf6c",
      "mergeCommit": {
        "oid": "7bd60fcc09c1569b0f87cdebd6534fbaad922161"
      }
    },
    {
      "number": 108,
      "id": "MDExOlB1bGxSZXF1ZXN0MjI2MTQyMjE3",
      "title": "remove the _esni prefix ",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/108",
      "state": "CLOSED",
      "author": "mcmanus",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "allow synchronization of both Key-Info and A/AAAA via the traditional single CNAME.\r\n\r\nfixes #105 amd #79\r\nessentially requires #73 otherwise there is namespace conflict\r\n\r\ntext conflicts a bit with #104 so if both were landed the slower one would need an update",
      "createdAt": "2018-10-26T15:40:14Z",
      "updatedAt": "2019-03-06T00:55:12Z",
      "closedAt": "2019-03-06T00:55:12Z",
      "mergedAt": null,
      "mergedBy": null,
      "comments": [
        {
          "author": "mcmanus",
          "authorAssociation": "CONTRIBUTOR",
          "body": "this is premised on #109",
          "createdAt": "2018-10-27T19:39:38Z",
          "updatedAt": "2018-10-27T19:39:38Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed in #144.",
          "createdAt": "2019-03-06T00:55:12Z",
          "updatedAt": "2019-03-06T00:55:12Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTY5MDYzMDQ3",
          "commit": {
            "abbreviatedOid": "283701c"
          },
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-10-27T17:12:53Z",
          "updatedAt": "2018-10-27T17:12:53Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "It seems like you would need to have some prefix or something here to distinguish from other TXT records (this is of course what the _esni prefix was supposed to do). Do we need a published convention",
              "createdAt": "2018-10-27T17:12:53Z",
              "updatedAt": "2018-10-27T17:12:53Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTk1Nzg4NzMx",
          "commit": {
            "abbreviatedOid": "283701c"
          },
          "author": "paulehoffman",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-01-23T23:07:09Z",
          "updatedAt": "2019-01-23T23:07:09Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "1) It is a terrible idea to have non-prefixed TXT records\r\n2) This has been overtaken by events with the likely proposal of a new RRtype",
              "createdAt": "2019-01-23T23:07:09Z",
              "updatedAt": "2019-01-23T23:07:09Z"
            }
          ]
        }
      ],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "bf4f394215d04aafefaf8870285d27866abad217",
      "headRepository": "mcmanus/draft-rescorla-tls-esni",
      "headRefName": "mcmanus-105",
      "headRefOid": "283701cf86728c5c6550f9f459a2b1af9dd62ec4",
      "mergeCommit": null
    },
    {
      "number": 111,
      "id": "MDExOlB1bGxSZXF1ZXN0MjI2MTU1MDkw",
      "title": "break RRData into ESNIKeys and ESNIInclude",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/111",
      "state": "CLOSED",
      "author": "mcmanus",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "fixes #110",
      "createdAt": "2018-10-26T16:24:46Z",
      "updatedAt": "2020-02-23T13:49:21Z",
      "closedAt": "2020-02-23T13:49:21Z",
      "mergedAt": null,
      "mergedBy": null,
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing as this is OBE.",
          "createdAt": "2020-02-23T13:49:21Z",
          "updatedAt": "2020-02-23T13:49:21Z"
        }
      ],
      "reviews": [],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "bf4f394215d04aafefaf8870285d27866abad217",
      "headRepository": "mcmanus/draft-rescorla-tls-esni",
      "headRefName": "mcmanus-esniptr",
      "headRefOid": "22614a4eb459b6634081ee82f54dad7acf07d17e",
      "mergeCommit": null
    },
    {
      "number": 112,
      "id": "MDExOlB1bGxSZXF1ZXN0MjI2MzE4NDE4",
      "title": "Convenient integration branch for DNS issues",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/112",
      "state": "CLOSED",
      "author": "mcmanus",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "includes multicdn #35 \r\nesni rrtype #109 #74\r\nremove _esni prefix #105 #79 \r\nesniinclude #110 ",
      "createdAt": "2018-10-27T19:38:08Z",
      "updatedAt": "2019-06-27T20:21:29Z",
      "closedAt": "2019-06-27T20:21:28Z",
      "mergedAt": null,
      "mergedBy": null,
      "comments": [
        {
          "author": "mcmanus",
          "authorAssociation": "CONTRIBUTOR",
          "body": "obe. but #110 should live on.",
          "createdAt": "2019-06-27T20:21:28Z",
          "updatedAt": "2019-06-27T20:21:28Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTY5MDkwMzIy",
          "commit": {
            "abbreviatedOid": "a189ef2"
          },
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2018-10-28T12:31:41Z",
          "updatedAt": "2018-10-28T12:40:32Z",
          "comments": [
            {
              "originalPosition": 68,
              "body": "This is kind of unclear, but I think the point is that the server operator provides the domain operator with the A record which the domain operator then installs in the DNS, but this works badly for ESNI Keys because then the server operator cannot frequently rotate the ENSI Keys.",
              "createdAt": "2018-10-28T12:31:42Z",
              "updatedAt": "2018-10-28T12:40:32Z"
            },
            {
              "originalPosition": 114,
              "body": "I would say A/AAAA.",
              "createdAt": "2018-10-28T12:34:31Z",
              "updatedAt": "2018-10-28T12:40:32Z"
            },
            {
              "originalPosition": 149,
              "body": "You should indicate that this is a failure example.",
              "createdAt": "2018-10-28T12:35:37Z",
              "updatedAt": "2018-10-28T12:40:32Z"
            },
            {
              "originalPosition": 137,
              "body": "This text is unclear at least to me.",
              "createdAt": "2018-10-28T12:37:11Z",
              "updatedAt": "2018-10-28T12:40:32Z"
            },
            {
              "originalPosition": 159,
              "body": "This algorithm seems over-complicated. I.e., there's no reason to query for the ESNI at a different CNAME than A/AAAA. Also, it seems like there is an open case here.\r\n\r\n````\r\nQuery for ESNI and A/AAAA records.\r\nIf A/AAAA is CNAME=X {\r\n   Query for ESNI at X\r\n} else {\r\n   if ESNI is not CNAME {\r\n     success\r\n} else {\r\n     ???\r\n}\r\n```\r\n\r\n",
              "createdAt": "2018-10-28T12:40:25Z",
              "updatedAt": "2018-10-28T12:40:32Z"
            }
          ]
        }
      ],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "7bd60fcc09c1569b0f87cdebd6534fbaad922161",
      "headRepository": "mcmanus/draft-rescorla-tls-esni",
      "headRefName": "mcmanus-cnamefriendly",
      "headRefOid": "a189ef2cd5ee26595154a08b4db389e440385e3d",
      "mergeCommit": null
    },
    {
      "number": 114,
      "id": "MDExOlB1bGxSZXF1ZXN0MjI4MTAwMTk1",
      "title": "Uniform capitalization of \"Split Mode\" and \"Shared Mode\"",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/114",
      "state": "MERGED",
      "author": "Eudi4H",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-11-03T05:10:27Z",
      "updatedAt": "2018-11-03T06:47:39Z",
      "closedAt": "2018-11-03T06:47:39Z",
      "mergedAt": "2018-11-03T06:47:39Z",
      "mergedBy": "ekr",
      "comments": [],
      "reviews": [],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "7bd60fcc09c1569b0f87cdebd6534fbaad922161",
      "headRepository": "Eudi4H/draft-ietf-tls-esni",
      "headRefName": "caps",
      "headRefOid": "935470acc000c03b6fb8f66e534cf3b45db5fe15",
      "mergeCommit": {
        "oid": "752c4ff43cc1aaf163a5955539e74029c46b3522"
      }
    },
    {
      "number": 115,
      "id": "MDExOlB1bGxSZXF1ZXN0MjI4MTE3Nzc0",
      "title": "Update README.md",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/115",
      "state": "MERGED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-11-03T13:13:34Z",
      "updatedAt": "2018-11-03T21:57:32Z",
      "closedAt": "2018-11-03T21:57:31Z",
      "mergedAt": "2018-11-03T21:57:31Z",
      "mergedBy": "ekr",
      "comments": [],
      "reviews": [],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "752c4ff43cc1aaf163a5955539e74029c46b3522",
      "headRepository": "martinthomson/draft-ietf-tls-esni",
      "headRefName": "README",
      "headRefOid": "ce6c4c93e15eb632d274df06590c2a508b3a65db",
      "mergeCommit": {
        "oid": "65e0cc3b795cfd87aedbc347901fd97083177bca"
      }
    },
    {
      "number": 120,
      "id": "MDExOlB1bGxSZXF1ZXN0MjM2MDE5MzEz",
      "title": "Fix typo.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/120",
      "state": "MERGED",
      "author": "davidben",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-12-05T01:42:45Z",
      "updatedAt": "2018-12-05T15:30:23Z",
      "closedAt": "2018-12-05T15:30:16Z",
      "mergedAt": "2018-12-05T15:30:16Z",
      "mergedBy": "chris-wood",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks!",
          "createdAt": "2018-12-05T15:30:22Z",
          "updatedAt": "2018-12-05T15:30:22Z"
        }
      ],
      "reviews": [],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "1ed8d7d02c3b0884ac20c93f891d2745ab0f9d49",
      "headRepository": "davidben/draft-ietf-tls-esni",
      "headRefName": "fix-typo",
      "headRefOid": "39f17a269fef9807a01ee48aef3ce1748218453f",
      "mergeCommit": {
        "oid": "3013b3c0c7bd93202cd4ca847380de64352ec79f"
      }
    },
    {
      "number": 122,
      "id": "MDExOlB1bGxSZXF1ZXN0MjM4NDk2NzYw",
      "title": "Add CertificateVerify to padding recommendation",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/122",
      "state": "CLOSED",
      "author": "sftcd",
      "authorAssociation": "FIRST_TIME_CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Also takes out the \"longest length\" part of the SHOULD since (as Viktor pointed out) a server might not always know that and it can change due to CA or other PKI changes that might lead to errors in some scenarios. (E.g. CA adds new extension thereby causing a cert to be longer than what the TLS server thinks is longest.)",
      "createdAt": "2018-12-13T19:00:33Z",
      "updatedAt": "2020-04-27T21:59:32Z",
      "closedAt": "2020-04-27T21:59:31Z",
      "mergedAt": null,
      "mergedBy": null,
      "comments": [
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "I don't agree with the longest length removal.\r\n\r\nPlease two separate PRs, one of which contains the non-controversial piece (CertificateVerify) and one with the longest length change.",
          "createdAt": "2018-12-13T19:05:26Z",
          "updatedAt": "2018-12-13T19:05:26Z"
        },
        {
          "author": "sftcd",
          "authorAssociation": "NONE",
          "body": "Not sure I know how to split a PR into two:-) Can take a look at it tomorrow but given one of 'em adds two words it'll likely be as easy to just treat this like an issue and make that change before a new rev and treat this one as arguing that longest-length is perhaps better not being a SHOULD.",
          "createdAt": "2018-12-13T19:15:21Z",
          "updatedAt": "2018-12-13T19:16:12Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@sftcd what\u2019s the plan here?",
          "createdAt": "2019-06-19T16:52:59Z",
          "updatedAt": "2019-06-19T16:52:59Z"
        },
        {
          "author": "sftcd",
          "authorAssociation": "NONE",
          "body": "I guess the non-controversial change ought be made. That's just s/SHOULD pad the Certificate message/SHOULD pad the Certificate and CertificateVerify messages/. I can make a PR for that or you can just do it and kill this one. \r\nFor the non non-controversial change, I can send mail the WG list I guess:-)",
          "createdAt": "2019-06-19T20:47:22Z",
          "updatedAt": "2019-06-19T20:47:22Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@sftcd this is likely overcome by events in #207. Would you mind updating based on that text, or closing this PR?",
          "createdAt": "2020-03-08T00:34:44Z",
          "updatedAt": "2020-03-08T00:34:44Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing as overcome by #209!",
          "createdAt": "2020-04-27T21:59:31Z",
          "updatedAt": "2020-04-27T21:59:31Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTg4NTE3NDEy",
          "commit": {
            "abbreviatedOid": "db1ee1b"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2018-12-31T17:02:46Z",
          "updatedAt": "2018-12-31T17:05:43Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "typo \"ahnshake\"",
              "createdAt": "2018-12-31T17:02:46Z",
              "updatedAt": "2019-01-01T14:30:00Z"
            },
            {
              "originalPosition": 12,
              "body": "s/on the network/on the wire?",
              "createdAt": "2018-12-31T17:02:56Z",
              "updatedAt": "2019-01-01T14:30:00Z"
            },
            {
              "originalPosition": 12,
              "body": "Perhaps add a sentence that says the padded length equals the size of the largest possible Certificate and CertificateVerify messages covered by the same ESNI key?",
              "createdAt": "2018-12-31T17:05:37Z",
              "updatedAt": "2019-01-01T14:30:00Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTg4NTU4NzIz",
          "commit": {
            "abbreviatedOid": "db1ee1b"
          },
          "author": "sftcd",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-01-01T14:27:21Z",
          "updatedAt": "2019-01-01T14:27:22Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "I'm not sure that's a good plan TBH. It seems there are openssl deployments where there's a bunch of certs in a database somewhere so a) it could be slow to find that information afresh and b) that max size is liable to change as CAs renew certs, e.g. if the PKI renewal results in more/bigger extensions being put in certs. So while the max size could work in many places perhaps a simpler approach is better as the example to give.\r\n\r\nFWIW, my current code just pads the Certificate to a multiple of 2000 bytes and the CertificateVerify to a multiple of 500 bytes, those could maybe be smaller, but it seems to work ok.",
              "createdAt": "2019-01-01T14:27:22Z",
              "updatedAt": "2019-01-01T14:30:00Z"
            }
          ]
        }
      ],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "3013b3c0c7bd93202cd4ca847380de64352ec79f",
      "headRepository": null,
      "headRefName": "master",
      "headRefOid": "c57591570967befd4bcaebc05833694048618179",
      "mergeCommit": null
    },
    {
      "number": 124,
      "id": "MDExOlB1bGxSZXF1ZXN0MjM5MzE1MjU3",
      "title": "Improve ESNI robustness",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/124",
      "state": "MERGED",
      "author": "davidben",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "(WG email coming shortly.)\r\n\r\nCloses #82.\r\n\r\nESNI has different compatibility characteristics than most TLS\r\nextensions. It involves client state, and encrypting the SNI makes the\r\nClientHello unusable for servers that do not have the key or do not\r\nimplement ESNI. This breaks common rollout and rollback strategies and\r\nplaces strong requirements on DNS/server consistency. This makes\r\ndeploying ESNI risky for servers.\r\n\r\nThis change aims to reduce these deployment risks. ESNI is much more\r\nuseful if widely deployed. Moreover, if ESNI is unreliable due to\r\ncomplex requirements on the server, clients will be disincentivized to\r\nimplement it. The DNS/server consistency requirements also\r\ndisincentivize rotating keys (section 7.2.5).\r\n\r\nThis change introduces the notion of a \"public name\" which allows the\r\nclient to receive authenticated signals from the server that the\r\nESNIKeys are out of sync, so clients can safely repair key mismatches.\r\nIt also aligns with existing server behavior before ESNI, so partial\r\nrollouts and rollbacks can also be handled.\r\n\r\nThe fix for the latter also handles MITM scenarios, replacing the\r\nexisting client recommendation:\r\n\r\n>   A Web client client can securely detect case (2) because it will\r\n>   result in a connection which has an invalid identity (most likely)\r\n>   but which is signed by a certificate which does not chain to a\r\n>   publicly known trust anchor.  The client can detect this case and\r\n>   disable ESNI while in that network configuration.\r\n>\r\n>   https://tools.ietf.org/html/draft-ietf-tls-esni-02#section-6.2\r\n\r\nThe public name notion fixes a bug in that text: an attacker could\r\ndisable ESNI on all servers, given the existence of *any* such server.",
      "createdAt": "2018-12-17T23:16:08Z",
      "updatedAt": "2019-02-26T21:14:13Z",
      "closedAt": "2019-02-26T21:14:13Z",
      "mergedAt": "2019-02-26T21:14:12Z",
      "mergedBy": "chris-wood",
      "comments": [
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Hopefully I didn't miss anything.\r\n\r\nAnd, as I write this, I realize I forgot to deal with Stephen's comment on the thread about the middlebox stuff! It's quite late here, so I will reword that tomorrow morning.",
          "createdAt": "2019-02-15T01:25:39Z",
          "updatedAt": "2019-02-15T01:25:39Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTg2NzIzOTEy",
          "commit": {
            "abbreviatedOid": "641ded1"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-12-19T19:59:52Z",
          "updatedAt": "2018-12-19T19:59:53Z",
          "comments": [
            {
              "originalPosition": 240,
              "body": "I had real trouble with this text because it doesn't say which direction the resumption applies to.  In general, when talking about resumption, you need to be very clear about whether you are talking about accepting a PSK for *this* session, or whether you are talking about maybe later establishing a resumed connection.  In this case, it's possible that both apply, so I had trouble with this.",
              "createdAt": "2018-12-19T19:59:52Z",
              "updatedAt": "2019-02-26T21:13:39Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTg4NTE4MTA3",
          "commit": {
            "abbreviatedOid": "641ded1"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Overall, this looks good to me. Thanks for the PR! @ekr, @kazuho, can you please give it a review?",
          "createdAt": "2018-12-31T17:10:25Z",
          "updatedAt": "2018-12-31T17:33:21Z",
          "comments": [
            {
              "originalPosition": 26,
              "body": "s/public key/public key and metadata?",
              "createdAt": "2018-12-31T17:10:25Z",
              "updatedAt": "2019-02-26T21:13:39Z"
            },
            {
              "originalPosition": 165,
              "body": "s/encrypted SNI/ENSI",
              "createdAt": "2018-12-31T17:17:21Z",
              "updatedAt": "2019-02-26T21:13:39Z"
            },
            {
              "originalPosition": 240,
              "body": "My take is that the text refers to the former, not the latter, though it is a little unclear. ",
              "createdAt": "2018-12-31T17:27:45Z",
              "updatedAt": "2019-02-26T21:13:39Z"
            },
            {
              "originalPosition": 263,
              "body": "s/by servers/by (other) servers?",
              "createdAt": "2018-12-31T17:28:54Z",
              "updatedAt": "2019-02-26T21:13:39Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTk3MzE5ODMw",
          "commit": {
            "abbreviatedOid": "641ded1"
          },
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-01-28T23:56:28Z",
          "updatedAt": "2019-01-29T23:35:20Z",
          "comments": [
            {
              "originalPosition": 26,
              "body": "Done.",
              "createdAt": "2019-01-28T23:56:28Z",
              "updatedAt": "2019-02-26T21:13:39Z"
            },
            {
              "originalPosition": 165,
              "body": "Done.",
              "createdAt": "2019-01-28T23:56:56Z",
              "updatedAt": "2019-02-26T21:13:39Z"
            },
            {
              "originalPosition": 240,
              "body": "It's just the former, yeah.\r\n\r\nThe intent of the text is to prevent resumption/SNI mismatches. With ESNI and, in particular, this ESNI to SNI fallback, a client offering {(non-GREASE) ESNI, SNI, PSK} now needs to consider all four possible responses:\r\n\r\n1. Server ACK'd ESNI and did full handshake\r\n2. Server ACK'd ESNI and resumed PSK\r\n3. Server ignored ESNI (thus used SNI) and did full handshake\r\n4. Server ignored ESNI (thus used SNI) and resumed PSK\r\n\r\nIn particular, whether the server ACKs or ignores ESNI determines which name the server believes it is acting on behalf of. So we want that to be consistent with the identity the client has associated with the PSK, if any. (1) and (3) are vacuously self-consistent, so that's easy.\r\n\r\nAs for (2) and (4), presumably the client would not be offering a session good for the public name because it's actually trying to connect to the ESNI name. Thus we want to reject (4) and allow (2). (If we allow (4), then the verify-public-name section needs to decide whether this weird scenario counts as authenticating the replacement ESNI keys and that's weird.) That means the server needs to know not the produce (4).\r\n\r\nNow, we could that, if a server ignores the ESNI extension due to key mismatch, it should also ignore the PSK extension. That works, except:\r\n* We want to be robust to server rollbacks and partial deployments. Such a server won't know to ignore the PSK extension.\r\n* Being able to send GREASE extensions is nice and a GREASE client wants to accept (4) since all the names are actually identical all around.\r\n\r\nOur thinking was to instead take leaf out of EMS's (and new TLS versions in general) book and partitions the connection/resumption space by whether ESNI was used. We remember a bit in the session state for whether ESNI was used when establishing it. We then say that a client offering ESNI [for real, not GREASE] can only offer ESNI-ful sessions, and a server can only accept ESNI-ful sessions in ESNI-ful handshakes.\r\n\r\nThis gives all the properties we want:\r\n* Clients offering ESNI will only offer an ESNI-ful session, which is invalid for the server to accept if it declined ESNI. Thus it can reject (4) above.\r\n* This can work with ESNI-oblivious servers on rollback. The server makes the ESNI bit in the session state unparseable by older versions of itself. This is the same sort of thing the server would already have had to do for EMS, or TLS 1.3.\r\n* Clients offering GREASE ESNI will almost always offer ESNI-less sessions (last time I talked to the server, it presumably didn't have ESNI either). The server will decline ESNI (since it's random noise), which means it's allowed to resume ESNI-less sessions.\r\n\r\nThere isn't an immediate need to constrain ESNI-less sessions, so I didn't in this version of the text. Though maybe a full partition is cleaner? It also occurs to me I have no idea what to do about external PSKs. We could say that if you really want ESNI + external PSK (strange considering that ESNI is usually about picking a certificate anyway...), you have to associate an ESNI bit with the EPSK?? EPSKs are a really underspecified use case that I don't know how to evaluate it.\r\n\r\nAnyway, I've tweaked the text slightly and left the above questions as-is for now. Is the new text clearer? / Thoughts on the above?",
              "createdAt": "2019-01-29T23:14:36Z",
              "updatedAt": "2019-02-26T21:13:39Z"
            },
            {
              "originalPosition": 263,
              "body": "Rephrased. (See longer comment on resumption above.)",
              "createdAt": "2019-01-29T23:34:28Z",
              "updatedAt": "2019-02-26T21:13:39Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjAzNDU4NjUy",
          "commit": {
            "abbreviatedOid": "18ee79c"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-02-13T21:33:35Z",
          "updatedAt": "2019-02-13T21:33:35Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjAzNDU4NzIy",
          "commit": {
            "abbreviatedOid": "18ee79c"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-02-13T21:33:45Z",
          "updatedAt": "2019-02-13T21:33:46Z",
          "comments": [
            {
              "originalPosition": 263,
              "body": "\ud83d\udc4d ",
              "createdAt": "2019-02-13T21:33:45Z",
              "updatedAt": "2019-02-26T21:13:39Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjAzNDU4OTYy",
          "commit": {
            "abbreviatedOid": "18ee79c"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-02-13T21:34:17Z",
          "updatedAt": "2019-02-13T21:34:18Z",
          "comments": [
            {
              "originalPosition": 240,
              "body": "I think the proposed text clears things up. @martinthomson @ekr I'll take this PR to the list to see if there are any objections. ",
              "createdAt": "2019-02-13T21:34:18Z",
              "updatedAt": "2019-02-26T21:13:39Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjAzNDYyNjIz",
          "commit": {
            "abbreviatedOid": "18ee79c"
          },
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-02-13T21:42:49Z",
          "updatedAt": "2019-02-13T21:42:49Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjAzNDk1MjE5",
          "commit": {
            "abbreviatedOid": "18ee79c"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "I think that this still needs a little work.\r\n\r\nI've not been following closely, so consider this a review from fresh eyes.",
          "createdAt": "2019-02-13T23:03:42Z",
          "updatedAt": "2019-02-13T23:35:02Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "Maybe avoid making untestable claims:\r\n```suggestion\r\n```\r\n\r\nMore so this set of changes makes the design the very opposite of straightforward.",
              "createdAt": "2019-02-13T23:03:42Z",
              "updatedAt": "2019-02-26T21:13:39Z"
            },
            {
              "originalPosition": 78,
              "body": "We will evolve the format over time.  That means that this field is going to contain a specific version.  If that version is not supported, this design offers no means of recovery.  The client knows for certain that ESNI is supported, but there is no remedy.\r\n\r\nCan this include a list of key structures?  That would be consistent with the DNS, which can have multiple alternative records with different versions.",
              "createdAt": "2019-02-13T23:07:37Z",
              "updatedAt": "2019-02-26T21:13:39Z"
            },
            {
              "originalPosition": 104,
              "body": "I'm confused.  This is the first mention of a PSK.  This needs more context.\r\n\r\nThe point here is that if you get a PSK from a previous connection (presumably an external PSK can have its own rules), then you need to ensure that you mark that PSK as being ESNI or not.  If it is ESNI, then you never resume from an ESNI PSK without ESNI and you never resume from a non-ESNI PSK if you are adding ESNI.\r\n\r\nWithout context, this is impossible to decipher.  I'm not even sure if I agree with the latter part of the requirement, so explaining why is probably necessary.\r\n\r\nAlso, this sentence is a run-on, so I can't really parse it.",
              "createdAt": "2019-02-13T23:10:13Z",
              "updatedAt": "2019-02-26T21:13:39Z"
            },
            {
              "originalPosition": 146,
              "body": "Can public_name be empty?  If it is, can I omit SNI?",
              "createdAt": "2019-02-13T23:14:16Z",
              "updatedAt": "2019-02-26T21:13:39Z"
            },
            {
              "originalPosition": 186,
              "body": "The SHOULD here is either out of scope, or under-specified.\r\n\r\nI think that the intent here is to say that if ESNI is not negotiated for any reason, but the connection is completed successfully with \"public_name\", then you aren't being attacked, but ESNI has simply been disabled.  A necessary condition for the \"SHOULD retry\" here is that the connection is successfully established with \"public_name\", but that connection is not explicit here.\r\n\r\nYou also want to add a condition here that if the server provides retry keys that the client cannot use, then it can regard ESNI as securely disabled.\r\n\r\nIf that is not the intent, then this stipulates policy: it's OK to fall back when you have a clear signal that ESNI is enabled, but the server doesn't do ESNI.  That's not a policy I would support.",
              "createdAt": "2019-02-13T23:20:40Z",
              "updatedAt": "2019-02-26T21:13:39Z"
            },
            {
              "originalPosition": 209,
              "body": "This is right, but in the degenerate case it leads to three connections: one to fail resumption, one to get ESNI keys (because presumably you don't want the server that resumes to be able to supply retry keys - something that needs to be said more clearly in previous sections), and finally one to connect with the updated keys to the real host.  That isn't ideal, but I don't see how that could be shortened at all.",
              "createdAt": "2019-02-13T23:23:34Z",
              "updatedAt": "2019-02-26T21:13:39Z"
            },
            {
              "originalPosition": 258,
              "body": "Why not prohibit resumption and PSK entirely for the case where the keys need replacing?  This only works for certificate-based server authentication anyway.  Are you really trying to salvage this for servers that authenticate with a PSK?",
              "createdAt": "2019-02-13T23:27:28Z",
              "updatedAt": "2019-02-26T21:13:39Z"
            },
            {
              "originalPosition": 273,
              "body": "```suggestion\r\nfield set to the decrypted PaddedServerNameList.nonce value from the client\r\n\"encrypted_server_name\" extension.\r\n```",
              "createdAt": "2019-02-13T23:29:12Z",
              "updatedAt": "2019-02-26T21:13:39Z"
            },
            {
              "originalPosition": 304,
              "body": "Remove \"in DNS\"",
              "createdAt": "2019-02-13T23:30:21Z",
              "updatedAt": "2019-02-26T21:13:39Z"
            },
            {
              "originalPosition": 309,
              "body": "s/DNS/systems that advertise ESNI keys/",
              "createdAt": "2019-02-13T23:30:51Z",
              "updatedAt": "2019-02-26T21:13:39Z"
            },
            {
              "originalPosition": 315,
              "body": "s/DNS/advertisements/",
              "createdAt": "2019-02-13T23:31:07Z",
              "updatedAt": "2019-02-26T21:13:39Z"
            },
            {
              "originalPosition": 317,
              "body": "```suggestion\r\ndeployment. This may also occur if a server loses its ESNI keys, or if a deployment\r\n```",
              "createdAt": "2019-02-13T23:31:37Z",
              "updatedAt": "2019-02-26T21:13:39Z"
            },
            {
              "originalPosition": 330,
              "body": "s/DNS/advertised",
              "createdAt": "2019-02-13T23:31:59Z",
              "updatedAt": "2019-02-26T21:13:39Z"
            },
            {
              "originalPosition": 336,
              "body": "Again, you need to separate retries that provide usable keys and ones that don't.",
              "createdAt": "2019-02-13T23:32:36Z",
              "updatedAt": "2019-02-26T21:13:39Z"
            },
            {
              "originalPosition": 374,
              "body": "As much as I like and agree with this sentiment, the last sentence can go.",
              "createdAt": "2019-02-13T23:33:22Z",
              "updatedAt": "2019-02-26T21:13:39Z"
            },
            {
              "originalPosition": 383,
              "body": "Editorial: avoid possessive for inanimate objects or abstract concepts.",
              "createdAt": "2019-02-13T23:34:29Z",
              "updatedAt": "2019-02-26T21:13:39Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjA0MDAzMDUz",
          "commit": {
            "abbreviatedOid": "18ee79c"
          },
          "author": "kaduk",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-02-14T22:25:20Z",
          "updatedAt": "2019-02-14T22:25:20Z",
          "comments": [
            {
              "originalPosition": 173,
              "body": "Should probably be clear about who can do this tracking (a network observer), since the server has other ways to track specific clients.",
              "createdAt": "2019-02-14T22:25:20Z",
              "updatedAt": "2019-02-26T21:13:39Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjA0MDIyNTM2",
          "commit": {
            "abbreviatedOid": "18ee79c"
          },
          "author": "kaduk",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-02-14T23:25:35Z",
          "updatedAt": "2019-02-14T23:34:23Z",
          "comments": [
            {
              "originalPosition": 208,
              "body": "\"parameters not based on certificates\" should probably be worded differently.  I assume the intent is that you can't negotiate a PSK-only mode and need to pick something where the server authenticates with a certificate?",
              "createdAt": "2019-02-14T23:25:35Z",
              "updatedAt": "2019-02-26T21:13:39Z"
            },
            {
              "originalPosition": 220,
              "body": "I'm not sure that this usage of \"origin\" is consistent with the other usages in this document; do we want to be talking about the \"private domain\" instead?",
              "createdAt": "2019-02-14T23:26:15Z",
              "updatedAt": "2019-02-26T21:13:39Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjAzODg1MzEx",
          "commit": {
            "abbreviatedOid": "18ee79c"
          },
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "Thanks for the thorough review! I've uploaded a new revision. Hopefully I didn't miss anything.",
          "createdAt": "2019-02-14T17:55:27Z",
          "updatedAt": "2019-02-15T01:24:35Z",
          "comments": [
            {
              "originalPosition": 78,
              "body": "It is a list of key structures. See retry\\_key*s* and the `<1..2^16-1>`.  Also below where it says:\r\n\r\n> *If one of the values used a version known*\r\n>  *to the client*, the client SHOULD retry the handshake with a new transport\r\n>  connection, using that value to encrypt the SNI.",
              "createdAt": "2019-02-14T17:55:27Z",
              "updatedAt": "2019-02-26T21:13:39Z"
            },
            {
              "originalPosition": 209,
              "body": "Only two. It is not intended for the `illegal_parameter` to be a retry signal. The rules around resumption mean this scenario will never occur for a well-behaved client and server. (Client only offers ESNI sessions, which the server will not accept.)\r\n\r\nThis is precisely why there's the business about resumption that you commented on here:\r\nhttps://github.com/tlswg/draft-ietf-tls-esni/pull/124#discussion_r243055936",
              "createdAt": "2019-02-14T18:03:24Z",
              "updatedAt": "2019-02-26T21:13:39Z"
            },
            {
              "originalPosition": 258,
              "body": "See here:\r\nhttps://github.com/tlswg/draft-ietf-tls-esni/pull/124#discussion_r243055936\r\n\r\nIf we simply prohibit resumption, non-ESNI clients can't send GREASE. It also doesn't fully solve the problem because an ESNI-ignorant server won't know to do this, hence the text below about issuing tickets. Since we're doing that anyway, this is free and buys us GREASE.",
              "createdAt": "2019-02-14T18:05:10Z",
              "updatedAt": "2019-02-26T21:13:39Z"
            },
            {
              "originalPosition": 146,
              "body": "In the current text, no it cannot be empty. See `<1..2^16-1>` above.",
              "createdAt": "2019-02-14T21:50:43Z",
              "updatedAt": "2019-02-26T21:13:39Z"
            },
            {
              "originalPosition": 13,
              "body": "The untestable claim is existing text. I merely downgraded it a notch from \"quite straightforward\" to \"straightforward\". Happy to downgrade it further and remove that line altogether. Done.",
              "createdAt": "2019-02-14T22:00:12Z",
              "updatedAt": "2019-02-26T21:13:39Z"
            },
            {
              "originalPosition": 104,
              "body": "By \"the latter part of the requirement\", do you mean \"you never resume from a non-ESNI PSK if you are adding ESNI\"? The document does not prescribe that. See my response to your thread here:\r\nhttps://github.com/tlswg/draft-ietf-tls-esni/pull/124#discussion_r243055936\r\n\r\nI've reworded this a bit.",
              "createdAt": "2019-02-14T22:07:51Z",
              "updatedAt": "2019-02-26T21:13:39Z"
            },
            {
              "originalPosition": 186,
              "body": "> I think that the intent here is to say that if ESNI is not negotiated for any reason, but the connection is completed successfully with \"public_name\", then you aren't being attacked, but ESNI has simply been disabled. A necessary condition for the \"SHOULD retry\" here is that the connection is successfully established with \"public_name\", but that connection is not explicit here.\r\n\r\nIt says to follow the steps in {{verify-public-name}}, which includes abort rules, but I guess it's not obvious which aborts are caught and which aren't. Rephrased a bit.\r\n\r\n> You also want to add a condition here that if the server provides retry keys that the client cannot use, then it can regard ESNI as securely disabled.\r\n\r\nAlready there:\r\n\r\n>  The client then processes the \"retry_keys\" field from the server's\r\n>  \"encrypted_server_name\" extension. If one of the values used a version known\r\n>  to the client, the client SHOULD retry the handshake with a new transport\r\n>  connection, using that value to encrypt the SNI. If no value is applicable,\r\n>  the client SHOULD retry with ESNI disabled.\r\n\r\nBut I like the framing of \"securely disabled\". It's not normative but explains what's going on. What do you think of the new text.\r\n\r\n> If that is not the intent, then this stipulates policy: it's OK to fall back when you have a clear signal that ESNI is enabled, but the server doesn't do ESNI. That's not a policy I would support.\r\n\r\nTo clarify, when you say \"clear\", do you mean \"cleartext and not secured\" or do you mean \"unambiguous, including verifying the public name\"? I agree with you if the former, but the latter is kind of the point. :-)",
              "createdAt": "2019-02-15T00:24:40Z",
              "updatedAt": "2019-02-26T21:13:39Z"
            },
            {
              "originalPosition": 304,
              "body": "Done.",
              "createdAt": "2019-02-15T00:58:47Z",
              "updatedAt": "2019-02-26T21:13:39Z"
            },
            {
              "originalPosition": 309,
              "body": "Done.",
              "createdAt": "2019-02-15T00:59:16Z",
              "updatedAt": "2019-02-26T21:13:39Z"
            },
            {
              "originalPosition": 315,
              "body": "Done",
              "createdAt": "2019-02-15T01:01:08Z",
              "updatedAt": "2019-02-26T21:13:39Z"
            },
            {
              "originalPosition": 330,
              "body": "Done.",
              "createdAt": "2019-02-15T01:01:21Z",
              "updatedAt": "2019-02-26T21:13:39Z"
            },
            {
              "originalPosition": 336,
              "body": "I don't quite follow. What's the concern here? This one says \"If the public name does not verify\". Note this is also existing text, but slightly adapted. From before this PR:\r\n\r\n> If the servers does not\r\n> require SNI, it will complete the handshake with its default\r\n> certificate. Most likely, this will cause a certificate name\t\r\n> mismatch and thus handshake failure. Clients SHOULD NOT fall\t\r\n> back to cleartext SNI, because that allows a network attacker\t\r\n> to disclose the SNI. They MAY attempt to use another server\t\r\n> from the DNS results, if one is provided.",
              "createdAt": "2019-02-15T01:02:54Z",
              "updatedAt": "2019-02-26T21:13:39Z"
            },
            {
              "originalPosition": 374,
              "body": "This too is an existing sentence from before this PR. :-P Happy to remove it though. Removed.",
              "createdAt": "2019-02-15T01:03:43Z",
              "updatedAt": "2019-02-26T21:13:39Z"
            },
            {
              "originalPosition": 383,
              "body": "Done.",
              "createdAt": "2019-02-15T01:04:17Z",
              "updatedAt": "2019-02-26T21:13:39Z"
            },
            {
              "originalPosition": 173,
              "body": "Well, it's a little fussy. If we were worried about a malicious server colluding with a network observer, that malicious server could already just broadcast whatever tracking information it has to the clear somewhere else. :-P\r\n\r\nBut if the client is already not bothering with session resumption or scoping it for tracking reasons, a single-use retry means they don't *also* need to scope this. Honestly, saying that you must scope this at least as tightly as session resumption probably is sufficient? Though there's also thinking through accidental pinning if retry keys manage to change the public name.\r\n\r\nI added \"pinning concerns\" to the text but I dunno what other text is needed given the above. Thoughts?\r\n\r\n(Neither of these are obviously fatal. There is a corner of the design space around in-band provisioning of ESNI keys, if we're okay caching these and can stomach the complexity of an in-band retry. I know some folks on the list were interested in that. But I think it makes sense to focus on the simplest version of the idea first.)",
              "createdAt": "2019-02-15T01:11:40Z",
              "updatedAt": "2019-02-26T21:13:39Z"
            },
            {
              "originalPosition": 208,
              "body": "Yeah. Otherwise we don't have a public name to check. :-) How about \"did not negotiate certificate-based authentication\"?",
              "createdAt": "2019-02-15T01:12:37Z",
              "updatedAt": "2019-02-26T21:13:39Z"
            },
            {
              "originalPosition": 220,
              "body": "The word \"origin\" shows up elsewhere in the doc a bunch, but I only see \"private domain\" once. Though \"origin\" usually says \"origin server\" or \"private origin\" and not plain \"origin\". I think \"private origin\" fits better here than \"origin server\". What do you think?",
              "createdAt": "2019-02-15T01:15:12Z",
              "updatedAt": "2019-02-26T21:13:39Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjA0MDUyMzg4",
          "commit": {
            "abbreviatedOid": "7ce9b5c"
          },
          "author": "kaduk",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-02-15T01:45:42Z",
          "updatedAt": "2019-02-15T01:45:42Z",
          "comments": [
            {
              "originalPosition": 220,
              "body": "I agree that \"private origin\" is better than \"origin server\"",
              "createdAt": "2019-02-15T01:45:42Z",
              "updatedAt": "2019-02-26T21:13:39Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjA0MDUyNjYx",
          "commit": {
            "abbreviatedOid": "7ce9b5c"
          },
          "author": "kaduk",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-02-15T01:47:04Z",
          "updatedAt": "2019-02-15T01:47:05Z",
          "comments": [
            {
              "originalPosition": 208,
              "body": "I think we need to stay positive, \"negotiated a session that did not use a certificate for authentication\" -- otherwise we get confused if we have any sort of PSK+cert or other joint authentication scheme.",
              "createdAt": "2019-02-15T01:47:05Z",
              "updatedAt": "2019-02-26T21:13:39Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjA0MDU5MjQz",
          "commit": {
            "abbreviatedOid": "7ce9b5c"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "I see that I missed something about disabling.  I think that this could be a lot more explicit about the three primary cases that I talk about in the comments below.",
          "createdAt": "2019-02-15T02:24:06Z",
          "updatedAt": "2019-02-15T02:37:02Z",
          "comments": [
            {
              "originalPosition": 146,
              "body": "Prose in support of this would be useful.",
              "createdAt": "2019-02-15T02:24:07Z",
              "updatedAt": "2019-02-26T21:13:39Z"
            },
            {
              "originalPosition": 336,
              "body": "This is a matter of not leaning on other text properly.  There are three cases and this says two:\r\n\r\nThe public name can not verify, which is clearly a terminal error condition.  \r\nThe server can indicate that ESNI is disabled, which triggers a retry without ESNI.\r\nThe server can provide (usable) alternative keys, which triggers a retry with those keys.  If those keys are no good, that's a terminal condition.\r\n\r\nI think that you can simplify this to say that unless ESNI is disabled as a result of successfully establishing a connection to the public name, then a client MUST NOT attempt to connect without ESNI.  (not SHOULD NOT)\r\n\r\nYes, this is probably not your fault.  I'll let others sort that bit out.",
              "createdAt": "2019-02-15T02:25:13Z",
              "updatedAt": "2019-02-26T21:13:39Z"
            },
            {
              "originalPosition": 78,
              "body": "I see.  It's not very clear.  I'll make some suggestions.",
              "createdAt": "2019-02-15T02:27:22Z",
              "updatedAt": "2019-02-26T21:13:39Z"
            },
            {
              "originalPosition": 91,
              "body": "```suggestion\r\n: One or more ESNIKeys structures containing the keys that the client should use on\r\n```",
              "createdAt": "2019-02-15T02:27:38Z",
              "updatedAt": "2019-02-26T21:13:39Z"
            },
            {
              "originalPosition": 147,
              "body": "\"If none of the values provided in \"retry_keys\" contains a version supported by the client, the client MUST consider the server to have disabled ESNI.\"\r\n\r\nWhat the client does in response to an authenticated signal that disables ESNI is a matter for client policy, so the SHOULD is inappropriate.\r\n\r\nBTW, this would argue for having a third option: esni_disabled.\r\n\r\n",
              "createdAt": "2019-02-15T02:30:01Z",
              "updatedAt": "2019-02-26T21:13:39Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjA0MzE2Mzg4",
          "commit": {
            "abbreviatedOid": "7ce9b5c"
          },
          "author": "ghedo",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "Looks mostly good, but added some nits and clarification questions.",
          "createdAt": "2019-02-15T16:09:35Z",
          "updatedAt": "2019-02-15T16:44:30Z",
          "comments": [
            {
              "originalPosition": 57,
              "body": "This is used by the _client_?",
              "createdAt": "2019-02-15T16:09:35Z",
              "updatedAt": "2019-02-26T21:13:39Z"
            },
            {
              "originalPosition": 105,
              "body": "I think this sentence is missing something...",
              "createdAt": "2019-02-15T16:12:20Z",
              "updatedAt": "2019-02-26T21:13:39Z"
            },
            {
              "originalPosition": 167,
              "body": "Nit: ...to _the_ calling application.",
              "createdAt": "2019-02-15T16:14:28Z",
              "updatedAt": "2019-02-26T21:13:39Z"
            },
            {
              "originalPosition": 180,
              "body": "Does \"previously cached keys\" refer to the keys fetched from DNS?",
              "createdAt": "2019-02-15T16:28:18Z",
              "updatedAt": "2019-02-26T21:13:39Z"
            },
            {
              "originalPosition": 203,
              "body": "I'm not sure I understand this. Where would the toggle go, in DNS? And having the toggle turned on would signal to the client that it must not retry the connection with ESNI disabled?",
              "createdAt": "2019-02-15T16:39:40Z",
              "updatedAt": "2019-02-26T21:13:39Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjA0NDA1NjE3",
          "commit": {
            "abbreviatedOid": "21f8eab"
          },
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-02-15T19:35:27Z",
          "updatedAt": "2019-02-15T19:51:52Z",
          "comments": [
            {
              "originalPosition": 57,
              "body": "Er, I was thinking it's used by the server in that it's the identity the server assumes, but yeah conversely the client verifies it. I've reworded this to not reference either side.",
              "createdAt": "2019-02-15T19:35:27Z",
              "updatedAt": "2019-02-26T21:13:39Z"
            },
            {
              "originalPosition": 105,
              "body": "Oops! The mistake was s/which/negotiated/.",
              "createdAt": "2019-02-15T19:36:25Z",
              "updatedAt": "2019-02-26T21:13:39Z"
            },
            {
              "originalPosition": 146,
              "body": "Added the word non-empty to the public_name description.",
              "createdAt": "2019-02-15T19:36:51Z",
              "updatedAt": "2019-02-26T21:13:39Z"
            },
            {
              "originalPosition": 167,
              "body": "Done. Also removed \"as described below\". That could be read as \"as described below, here's how you avoid using the retry keys\", which is weird.",
              "createdAt": "2019-02-15T19:37:10Z",
              "updatedAt": "2019-02-26T21:13:39Z"
            },
            {
              "originalPosition": 180,
              "body": "@martinthomson left a bunch of comments that suggested he didn't want the specification text to talk about DNS keys. Thus, to answer your question, yes but not necessarily so we can't say that. :-P\r\n\r\nOn the list, someone thought a version of this text implied that you're supposed to keep track of all the retry keys and make sure they never repeat. (Honestly, I think that reading was tenuous to say the least.) So I've tried to avoid it saying MUST NOT use the old keys.\r\n\r\nI've now switched it to \"previously-advertised\" which matches the verb used elsewhere. If you all still don't like it, please give me an alternative! :-)",
              "createdAt": "2019-02-15T19:45:15Z",
              "updatedAt": "2019-02-26T21:13:39Z"
            },
            {
              "originalPosition": 203,
              "body": "Some extension on the ESNIKeys yeah. This is a TODO, not spec text.",
              "createdAt": "2019-02-15T19:46:15Z",
              "updatedAt": "2019-02-26T21:13:39Z"
            },
            {
              "originalPosition": 336,
              "body": "Adopted your text with the MUST NOT.",
              "createdAt": "2019-02-15T19:48:17Z",
              "updatedAt": "2019-02-26T21:13:39Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjA0NDkxNzQx",
          "commit": {
            "abbreviatedOid": "0ec053c"
          },
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-02-16T00:42:46Z",
          "updatedAt": "2019-02-16T00:42:46Z",
          "comments": [
            {
              "originalPosition": 147,
              "body": "Oops. Missed this one somehow. (GitHub's UI is... not the best).\r\n\r\n> \"If none of the values provided in \"retry_keys\" contains a version supported by the client, the client MUST consider the server to have disabled ESNI.\"\r\n\r\nI tweaked the wording a bit based on the first part. It seemed better to adjust the surrounding text too. Re the second part, I'm not sure what \"[MUST consider](https://tools.ietf.org/html/rfc6919#section-2)\" would mean as a normative requirement...\r\n\r\n> What the client does in response to an authenticated signal that disables ESNI is a matter for client policy, so the SHOULD is inappropriate.\r\n\r\nThe text around unechoed extensions also uses SHOULD. It's true that there isn't a single \"hook point\" for client policy around the disabling bit. It sounds like you might prefer a more \"abstracted\" text where something first outputs \"secure disable\", or \"secure replace\" and then there's policy on that.\r\n\r\nI haven't done that yet, in part because it's late on a Friday, but also I think we're well into wordsmithing weeds now. :-) I don't know what the right document organization would be for that. Also it's getting pretty long. Thoughts?\r\n\r\n> BTW, this would argue for having a third option: esni_disabled.\r\n\r\nIt's already there by way of not echoing the extension. I think a separate explicit version would only make sense if there are clients who:\r\n* are happy with `esni_retry_requested`\r\n* would be happy with `esni_disabled`\r\n* are *not* happy with the unechoed signal.\r\n\r\nThat preference is not entirely implausible because not echoing the extension is an implicit signal repurposing existing server behavior. However, that's also kind of the point, since it allows safe rollback. If server deployments cannot rely on that, the cost of deploying ESNI goes up dramatically.\r\n\r\nESNI, even more so than most TLS improvements, really wants a wide deployment, so I think it's good for the document to have a strong opinion here.\r\n\r\n(Specialized clients and specialized servers, of course, would probably ignore disable signals, but they would ignore `esni_disabled` too, so that's more about the SHOULD. But it seems to me that's covered by \"there may exist valid reasons in particular circumstances to ignore a particular item, but the full implications must be understood and carefully weighed before choosing a different course\".)",
              "createdAt": "2019-02-16T00:42:46Z",
              "updatedAt": "2019-02-26T21:13:39Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjA0NDkxNzg0",
          "commit": {
            "abbreviatedOid": "0ec053c"
          },
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-02-16T00:43:01Z",
          "updatedAt": "2019-02-16T00:43:01Z",
          "comments": [
            {
              "originalPosition": 147,
              "body": "Er, hit comment too soon. Will upload the corresponding git commit shortly.",
              "createdAt": "2019-02-16T00:43:01Z",
              "updatedAt": "2019-02-26T21:13:39Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjA0NDkyMDcw",
          "commit": {
            "abbreviatedOid": "aaccb84"
          },
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-02-16T00:45:12Z",
          "updatedAt": "2019-02-16T00:45:13Z",
          "comments": [
            {
              "originalPosition": 147,
              "body": "(Uploaded.)",
              "createdAt": "2019-02-16T00:45:13Z",
              "updatedAt": "2019-02-26T21:13:39Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjA0NDk1NjM2",
          "commit": {
            "abbreviatedOid": "aaccb84"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-02-16T01:16:27Z",
          "updatedAt": "2019-02-16T01:16:28Z",
          "comments": [
            {
              "originalPosition": 220,
              "body": "\ud83d\udc4d ",
              "createdAt": "2019-02-16T01:16:28Z",
              "updatedAt": "2019-02-26T21:13:39Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjA0NDk2MjQ3",
          "commit": {
            "abbreviatedOid": "aaccb84"
          },
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-02-16T01:22:51Z",
          "updatedAt": "2019-02-16T01:22:51Z",
          "comments": [
            {
              "originalPosition": 208,
              "body": "(Also missed this. I clearly don't know how to use GitHub...)\r\n\r\nDone.",
              "createdAt": "2019-02-16T01:22:51Z",
              "updatedAt": "2019-02-26T21:13:39Z"
            }
          ]
        }
      ],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "5e08e1439e3bbfd8ed022252679e76d0c90b4c88",
      "headRepository": "davidben/draft-ietf-tls-esni",
      "headRefName": "robustness",
      "headRefOid": "7e67cd82ec8b0c9f2ef2455222031e23c3f2060f",
      "mergeCommit": {
        "oid": "f07d3806d52add7920a0f4087f93c85bede08581"
      }
    },
    {
      "number": 125,
      "id": "MDExOlB1bGxSZXF1ZXN0MjM5MzE1NDA4",
      "title": "Allow clients to send GREASE ESNI extensions.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/125",
      "state": "MERGED",
      "author": "davidben",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "(WG email coming shortly.)\r\n\r\n~~NB: When reviewing, ignore the first commit. This PR and https://github.com/tlswg/draft-ietf-tls-esni/pull/124 were originally formulated together. I split them into two based on some feedback, but since they touch the same text, it was simplest to include https://github.com/tlswg/draft-ietf-tls-esni/pull/124 in this PR. If the WG wishes to go with one but not the other, the text and details can be adjusted accordingly.~~\r\n\r\n*Update: This has been rebased to master, now that #124 is merged.*\r\n\r\nThe new server behavior (\"Improve ESNI robustness\") means clients can send\r\nGREASE ESNI extensions without interop issues. Write some text recommending\r\nthis, better meeting the \"Do not stick out\" criteria.",
      "createdAt": "2018-12-17T23:16:54Z",
      "updatedAt": "2019-04-22T21:00:26Z",
      "closedAt": "2019-04-22T21:00:26Z",
      "mergedAt": "2019-04-22T21:00:26Z",
      "mergedBy": "chris-wood",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "The GREASE section seems fine to me. (@davidben is there other new material in this PR?) @ekr, @kazuho, please have a look when possible.",
          "createdAt": "2018-12-31T17:36:25Z",
          "updatedAt": "2018-12-31T17:36:25Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> @davidben is there other new material in this PR?\r\n\r\nIt's whatever's in the second commit, so mostly that section but also a bit elsewhere:\r\nhttps://github.com/tlswg/draft-ietf-tls-esni/pull/125/commits/7401f55013f68ec47dad36b99977ad6aa881d9f1",
          "createdAt": "2019-01-28T23:55:34Z",
          "updatedAt": "2019-01-28T23:55:34Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "I share the view that the GREASE section looks fine.",
          "createdAt": "2019-02-13T21:48:53Z",
          "updatedAt": "2019-02-13T21:48:53Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@ekr Did you mean to leave the comments on https://github.com/tlswg/draft-ietf-tls-esni/pull/124? (Notably the text already has seen a number of revisions here. I haven't gone back to update this PR yet. This PR was meant to just be the second commit.)",
          "createdAt": "2019-02-25T23:00:32Z",
          "updatedAt": "2019-02-25T23:00:32Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "Ugh. Having something which claims to be a merged PR is kind of an\nattractive nusiance, then, no? Perhaps you can apply the changes here?\n\nOn Mon, Feb 25, 2019 at 3:00 PM David Benjamin <notifications@github.com>\nwrote:\n\n> @ekr <https://github.com/ekr> Did you mean to leave the comments on #124\n> <https://github.com/tlswg/draft-ietf-tls-esni/pull/124>? (Notably the\n> text already has seen a number of revisions here. I haven't gone back to\n> update this PR yet. This PR was meant to just be the second commit.)\n>\n> \u2014\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/tlswg/draft-ietf-tls-esni/pull/125#issuecomment-467219457>,\n> or mute the thread\n> <https://github.com/notifications/unsubscribe-auth/ABD1oTg3ZYafmOt5ubYAqvmNV9qDX1GUks5vRGsRgaJpZM4ZXTha>\n> .\n>\n",
          "createdAt": "2019-02-25T23:04:10Z",
          "updatedAt": "2019-02-25T23:04:10Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "In my defense, I split them at your request and did include the following. ;-)\r\n\r\n> NB: When reviewing, ignore the first commit. This PR and #124 were originally formulated together. I split them into two based on some feedback, but since they touch the same text, it was simplest to include #124 in this PR. If the WG wishes to go with one but not the other, the text and details can be adjusted accordingly.\r\n\r\nBut, sure, I can rebase this one. I figured #124 was the bulk of the interesting bits (7401f55013f68ec47dad36b99977ad6aa881d9f1 is much smaller) so I figured we'd resolve #124 first and then I'd update this one at the end.",
          "createdAt": "2019-02-25T23:06:34Z",
          "updatedAt": "2019-02-25T23:06:34Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "On Mon, Feb 25, 2019 at 3:06 PM David Benjamin <notifications@github.com>\nwrote:\n\n> In my defense, I split them at your request and did include the following.\n> ;-)\n>\n> NB: When reviewing, ignore the first commit. This PR and #124\n> <https://github.com/tlswg/draft-ietf-tls-esni/pull/124> were originally\n> formulated together. I split them into two based on some feedback, but\n> since they touch the same text, it was simplest to include #124\n> <https://github.com/tlswg/draft-ietf-tls-esni/pull/124> in this PR. If\n> the WG wishes to go with one but not the other, the text and details can be\n> adjusted accordingly.\n>\n>\nSure, and I read that as \"this is an accurate reflection of my put for both\nof these\".\n\nBut, sure, I can rebase this one. I figured #124\n> <https://github.com/tlswg/draft-ietf-tls-esni/pull/124> was the bulk of\n> the interesting bits (7401f55\n> <https://github.com/tlswg/draft-ietf-tls-esni/commit/7401f55013f68ec47dad36b99977ad6aa881d9f1>\n> is much smaller) so I figured we'd resolve #124\n> <https://github.com/tlswg/draft-ietf-tls-esni/pull/124> first and then\n> I'd update this one at the end.\n>\n\nThanks.\n\n-Ekr\n\n\u2014\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/tlswg/draft-ietf-tls-esni/pull/125#issuecomment-467221253>,\n> or mute the thread\n> <https://github.com/notifications/unsubscribe-auth/ABD1oYi28jBhWjeNTZw4DxJZNo2VxMC_ks5vRGx6gaJpZM4ZXTha>\n> .\n>\n",
          "createdAt": "2019-02-25T23:10:08Z",
          "updatedAt": "2019-02-25T23:10:08Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Sure, and I read that as \"this is an accurate reflection of my put for both of these\".\r\n\r\nWell, it was when I wrote that sentence. :-) Anyway, it's now been rebased and I've incorporated your comments as well.",
          "createdAt": "2019-03-02T05:17:02Z",
          "updatedAt": "2019-03-02T05:17:02Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjAzNDc1NzQ0",
          "commit": {
            "abbreviatedOid": "7401f55"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-02-13T22:13:06Z",
          "updatedAt": "2019-02-13T22:13:06Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjAzNDc2OTY1",
          "commit": {
            "abbreviatedOid": "7401f55"
          },
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-02-13T22:16:05Z",
          "updatedAt": "2019-02-13T22:16:05Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjA3Njc1OTQ5",
          "commit": {
            "abbreviatedOid": "7401f55"
          },
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-02-25T22:46:52Z",
          "updatedAt": "2019-02-25T22:57:21Z",
          "comments": [
            {
              "originalPosition": 106,
              "body": "What's the function of this alert as opposed to just closing the connection?",
              "createdAt": "2019-02-25T22:46:52Z",
              "updatedAt": "2019-04-22T20:59:26Z"
            },
            {
              "originalPosition": 167,
              "body": "It's worth noting that this is only relevant for the earlier version case.",
              "createdAt": "2019-02-25T22:49:42Z",
              "updatedAt": "2019-04-22T20:59:26Z"
            },
            {
              "originalPosition": 195,
              "body": "This seems like it ought to be in the client section.",
              "createdAt": "2019-02-25T22:51:59Z",
              "updatedAt": "2019-04-22T20:59:26Z"
            },
            {
              "originalPosition": 201,
              "body": "IMPORTANT: It seems like with TLS 1.3 you could just abort the connection as soon as you get SFIN.",
              "createdAt": "2019-02-25T22:52:23Z",
              "updatedAt": "2019-04-22T20:59:26Z"
            },
            {
              "originalPosition": 225,
              "body": "Should we instead use consistent hashing so that you had the same record_digest for each server.",
              "createdAt": "2019-02-25T22:53:16Z",
              "updatedAt": "2019-04-22T20:59:26Z"
            },
            {
              "originalPosition": 240,
              "body": "\"offer to resume\"?",
              "createdAt": "2019-02-25T22:54:53Z",
              "updatedAt": "2019-04-22T20:59:26Z"
            },
            {
              "originalPosition": 306,
              "body": "I'm not sure how iluminating this hint about how to implement is. I would remove it.",
              "createdAt": "2019-02-25T22:56:10Z",
              "updatedAt": "2019-04-22T20:59:26Z"
            },
            {
              "originalPosition": 354,
              "body": "I'm not sure if it's \"most\". We expect CDN conflictst o be common.",
              "createdAt": "2019-02-25T22:56:50Z",
              "updatedAt": "2019-04-22T20:59:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjA3NjgzNjM4",
          "commit": {
            "abbreviatedOid": "7401f55"
          },
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-02-25T23:08:42Z",
          "updatedAt": "2019-03-02T05:15:05Z",
          "comments": [
            {
              "originalPosition": 106,
              "body": "Using a `close_notify` felt slightly off because the client is not cleanly closing the connection. It's rejecting it altogether. A more generic alert would work too, but this way a deployment can monitor that alert for whether it's getting out of sync a lot. (Merely being unable to decrypt ESNI isn't sufficient given GREASE.)\r\n\r\nI've adjusted the \"Note that an unrecognized ClientEncryptedSNI.record_digest [...]\" paragraph in the server behavior section to talk about this.",
              "createdAt": "2019-02-25T23:08:42Z",
              "updatedAt": "2019-04-22T20:59:26Z"
            },
            {
              "originalPosition": 225,
              "body": "That's a tracking vector, no?",
              "createdAt": "2019-02-26T00:08:27Z",
              "updatedAt": "2019-04-22T20:59:26Z"
            },
            {
              "originalPosition": 240,
              "body": "Done.",
              "createdAt": "2019-03-02T04:48:00Z",
              "updatedAt": "2019-04-22T20:59:26Z"
            },
            {
              "originalPosition": 306,
              "body": "Removed.",
              "createdAt": "2019-03-02T04:48:16Z",
              "updatedAt": "2019-04-22T20:59:26Z"
            },
            {
              "originalPosition": 354,
              "body": "Well, hopefully the CDN issue will be resolved by the current discussion. But fair enough. I've replaced the sentence with \"The retry mechanism repairs inconsistencies, provided the server is authoritative for the public name.\" which is more descriptive and avoids the subjective \"most\".",
              "createdAt": "2019-03-02T04:50:55Z",
              "updatedAt": "2019-04-22T20:59:26Z"
            },
            {
              "originalPosition": 167,
              "body": "Done.",
              "createdAt": "2019-03-02T04:52:04Z",
              "updatedAt": "2019-04-22T20:59:26Z"
            },
            {
              "originalPosition": 195,
              "body": "Well, this is a subsection of the client section. :-) Do you mean that it belongs in {{handle-server-response}}?\r\n\r\nThe nuisance is it's common to both the key mismatch and rollback cases. The purpose of this section was so the text didn't have to write it twice. (A subroutine if you will.) Though, now that you mention it, it is weird that the subroutine call is labelled \"verifying the certificate against ESNIKeys.public_name as described in {{verify-public-name}}\" which kinda presupposes a certificate story.\r\n\r\nWDYT about this: I've changed the description from \"verifying [the certificate] against the public name\" to \"authenticating for the public name\", which puts it at a bit larger scope than certificate verification.",
              "createdAt": "2019-03-02T05:07:50Z",
              "updatedAt": "2019-04-22T20:59:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjI5MTg3MTY4",
          "commit": {
            "abbreviatedOid": "a06d119"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-04-22T18:38:43Z",
          "updatedAt": "2019-04-22T18:38:43Z",
          "comments": []
        }
      ],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "8679dc49caa2131d9b660d9d30e4343aa7e994f9",
      "headRepository": "davidben/draft-ietf-tls-esni",
      "headRefName": "grease",
      "headRefOid": "361feec6e4ad6dff2b40c27ba3cd09b491d667a6",
      "mergeCommit": {
        "oid": "4f3ce56fdb4caea12c6480ca3a9a5ec6bfd074c1"
      }
    },
    {
      "number": 127,
      "id": "MDExOlB1bGxSZXF1ZXN0MjQ2MDExNDky",
      "title": "Clarify that ESNI clients MUST NOT send cached_info cert extensions",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/127",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2019-01-19T00:47:26Z",
      "updatedAt": "2019-02-13T21:32:03Z",
      "closedAt": "2019-02-13T21:32:03Z",
      "mergedAt": "2019-02-13T21:32:03Z",
      "mergedBy": "chris-wood",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Addresses #126.",
          "createdAt": "2019-01-19T00:47:48Z",
          "updatedAt": "2019-01-19T00:47:48Z"
        }
      ],
      "reviews": [],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "3013b3c0c7bd93202cd4ca847380de64352ec79f",
      "headRepository": "tlswg/draft-ietf-tls-esni",
      "headRefName": "caw/cached_info",
      "headRefOid": "105aa9a14d351afbcca44961facc9dd302cad73a",
      "mergeCommit": {
        "oid": "5e08e1439e3bbfd8ed022252679e76d0c90b4c88"
      }
    },
    {
      "number": 128,
      "id": "MDExOlB1bGxSZXF1ZXN0MjQ2MDEzMzYw",
      "title": "Specify HRR behavior.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/128",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2019-01-19T01:06:50Z",
      "updatedAt": "2019-03-08T01:07:59Z",
      "closedAt": "2019-03-08T00:53:16Z",
      "mergedAt": "2019-03-08T00:53:16Z",
      "mergedBy": "chris-wood",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@kazuho @ekr please have a look.",
          "createdAt": "2019-01-27T21:46:58Z",
          "updatedAt": "2019-01-27T21:46:58Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "We also need to specify server-side HRR behavior, right? Specifically, the server MUST recheck the second ClientHello's ESNI extension before sending the server certificate, otherwise putting the key share into the AD field doesn't really mean anything. The attacker would be able to do a cut-and-paste thing.\r\n\r\n(We could also incorporate the nonce into key schedule, but that upsets the document's split mode use case.)",
          "createdAt": "2019-03-08T01:03:23Z",
          "updatedAt": "2019-03-08T01:03:36Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Yep! Thanks for bringing that up. I'll prepare text.",
          "createdAt": "2019-03-08T01:07:58Z",
          "updatedAt": "2019-03-08T01:07:58Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjEwNDc1MTEx",
          "commit": {
            "abbreviatedOid": "a656687"
          },
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Thank you for the text. LGTM.",
          "createdAt": "2019-03-05T03:11:49Z",
          "updatedAt": "2019-03-05T03:11:49Z",
          "comments": []
        }
      ],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "d9437fd5a4ed04dff1b5e48f97c586f242e80fb4",
      "headRepository": "tlswg/draft-ietf-tls-esni",
      "headRefName": "caw/hrr",
      "headRefOid": "39295c9b7b3a50ab39416021154f520f0374ed90",
      "mergeCommit": {
        "oid": "1b339186ec98274e93132de121e76ca55cce849d"
      }
    },
    {
      "number": 129,
      "id": "MDExOlB1bGxSZXF1ZXN0MjQ2MDEzODA1",
      "title": "Swap version[4] and checksum, so the latter covers the entire struct.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/129",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Addresses #119, and we want the checksum to cover the entire struct by definition. ",
      "createdAt": "2019-01-19T01:12:21Z",
      "updatedAt": "2019-07-02T23:53:35Z",
      "closedAt": "2019-07-02T23:53:35Z",
      "mergedAt": null,
      "mergedBy": null,
      "comments": [
        {
          "author": "ghedo",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This looks fine, though the downside of this seems to be that the checksum becomes part of the \"invariants\" and can't be changed/removed in future versions.",
          "createdAt": "2019-01-19T13:18:48Z",
          "updatedAt": "2019-01-19T13:18:48Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Yeah, I assumed that was @kazuho\u2019s intent with the checksum. That is, if we see value in it for v1, it likely has value for all versions. ",
          "createdAt": "2019-01-19T15:01:29Z",
          "updatedAt": "2019-01-19T15:01:29Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@kazuho can you please comment?",
          "createdAt": "2019-01-27T21:46:41Z",
          "updatedAt": "2019-01-27T21:46:41Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "I am fine with making it an invariant, considering the fact that it exists for detecting transmission errors (or human errors during copy-and-paste).\r\n\r\nWe do not need to worry about this becoming \"insecure,\" unlike cryptographic hash functions.",
          "createdAt": "2019-02-15T02:03:12Z",
          "updatedAt": "2019-02-15T02:03:12Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjA0MDU1NzEx",
          "commit": {
            "abbreviatedOid": "8842702"
          },
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-02-15T02:03:40Z",
          "updatedAt": "2019-02-15T02:03:40Z",
          "comments": []
        }
      ],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "3013b3c0c7bd93202cd4ca847380de64352ec79f",
      "headRepository": "tlswg/draft-ietf-tls-esni",
      "headRefName": "caw/version-swap",
      "headRefOid": "8842702305794a3c100a47e598605fb66691796c",
      "mergeCommit": null
    },
    {
      "number": 136,
      "id": "MDExOlB1bGxSZXF1ZXN0MjU2NzQwNjQ0",
      "title": "Add support for \"combined records\" via an ESNIKeys extension",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/136",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This change does the following:\r\n\r\n1. Add support for mandatory extensions, which are those that clients must process else reject the ESNIKeys record.\r\n2. Add a mandatory extension carrying a set of v4/v6 addresses, which is effectively the combined record mode. \r\n3. Add text describing how clients ought to resolve ESNI and A/AAAA records, and use the results to initiate TLS connections.",
      "createdAt": "2019-02-27T16:05:14Z",
      "updatedAt": "2019-03-10T02:04:22Z",
      "closedAt": "2019-03-10T02:04:22Z",
      "mergedAt": "2019-03-10T02:04:22Z",
      "mergedBy": "chris-wood",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> This is a substantial step in the right direction, but the fact that A/AAAA records are basically ignored makes me uneasy. \r\n\r\nThat's fair. However, it seems to be the price to get this sort of simplicity. Moreover, as an extension, it's not pressed upon all clients for all providers.\r\n\r\n> The fact that A/AAAA results are essentially fully embedded would imply that all logic involved in selectively returning those responses has to be duplicated for ESNIKeys, which is also sub-optimal.\r\n\r\nAlso true! I'm hoping that folks who are in the position and capable of vending these records can comment on this design's cost. ",
          "createdAt": "2019-02-28T00:39:09Z",
          "updatedAt": "2019-02-28T00:39:09Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Given that there was no serious objection to this change and that it works for at least one operator, I'm merging this PR. We can continue to iterate on #137 as needed in parallel.",
          "createdAt": "2019-03-10T02:04:19Z",
          "updatedAt": "2019-03-10T02:04:19Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjA4ODMwODE1",
          "commit": {
            "abbreviatedOid": "293f61c"
          },
          "author": "MikeBishop",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "This is a substantial step in the right direction, but the fact that A/AAAA records are basically ignored makes me uneasy.  The fact that A/AAAA results are essentially fully embedded would imply that all logic involved in selectively returning those responses has to be duplicated for ESNIKeys, which is also sub-optimal.",
          "createdAt": "2019-02-27T23:57:27Z",
          "updatedAt": "2019-02-28T00:27:52Z",
          "comments": [
            {
              "originalPosition": 43,
              "body": "Other than being lower-case (\"must\" vs. \"MUST\"), this seems duplicative with the following paragraph.",
              "createdAt": "2019-02-27T23:57:27Z",
              "updatedAt": "2019-03-10T02:02:03Z"
            },
            {
              "originalPosition": 153,
              "body": "So in this design, ESNIKeys containing address(es) causes the A/AAAA results to be entirely ignored?",
              "createdAt": "2019-02-28T00:02:46Z",
              "updatedAt": "2019-03-10T02:02:03Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjA4ODQwNTk5",
          "commit": {
            "abbreviatedOid": "293f61c"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-02-28T00:36:37Z",
          "updatedAt": "2019-02-28T00:36:37Z",
          "comments": [
            {
              "originalPosition": 153,
              "body": "Yep!",
              "createdAt": "2019-02-28T00:36:37Z",
              "updatedAt": "2019-03-10T02:02:03Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjA4ODQwNzU5",
          "commit": {
            "abbreviatedOid": "293f61c"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-02-28T00:37:18Z",
          "updatedAt": "2019-02-28T00:37:19Z",
          "comments": [
            {
              "originalPosition": 43,
              "body": "I opted for redundancy here. Happy to remove the subsequent text if people feel that's best.",
              "createdAt": "2019-02-28T00:37:18Z",
              "updatedAt": "2019-03-10T02:02:03Z"
            }
          ]
        }
      ],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "a73367b8c58ba0a7f726743ad72ca4fd2b22574d",
      "headRepository": "chris-wood/draft-ietf-tls-esni",
      "headRefName": "caw/multi-cdn-simple",
      "headRefOid": "e9140ecba6c2fa17231c0d040e96e78f4cb44219",
      "mergeCommit": {
        "oid": "ba52fe66fb3a9a8d98dfd3d59b7322c454405f03"
      }
    },
    {
      "number": 137,
      "id": "MDExOlB1bGxSZXF1ZXN0MjU2NzQyNTUx",
      "title": "Add support for \"host pointers\" via an ESNIKeys extension",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/137",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This change does the following:\r\n\r\n1. Add support for mandatory extensions, which are those that clients must process else reject the ESNIKeys record.\r\n2. Add a mandatory extension carrying a \"host pointer,\" which is a (probably poorly named) struct containing a \"terminal CNAME\" for the domain, along with address masks, which may be partial or complete. Clients may use complete addresses if present, else they may use masks to resolve ESNI+A/AAAA mismatches. When these fail, the terminal CNAME may be used to get an address of some host that has the corresponding ESNI key.\r\n3. Add text describing how clients ought to resolve ESNI and A/AAAA records, and use the results to initiate TLS connections.\r\n\r\nThis is certainly more complex than #136.",
      "createdAt": "2019-02-27T16:10:00Z",
      "updatedAt": "2019-07-02T23:53:59Z",
      "closedAt": "2019-07-02T23:53:59Z",
      "mergedAt": null,
      "mergedBy": null,
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@MikeBishop Thanks for the feedback! I'll comment that, as an extension, this is compatible with #136, assuming of course that both extensions are not present. We could move forward with both.",
          "createdAt": "2019-02-28T00:44:01Z",
          "updatedAt": "2019-02-28T00:44:01Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing with #136.",
          "createdAt": "2019-07-02T23:53:59Z",
          "updatedAt": "2019-07-02T23:53:59Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjA4ODM1MDAw",
          "commit": {
            "abbreviatedOid": "7adfa01"
          },
          "author": "MikeBishop",
          "authorAssociation": "NONE",
          "state": "APPROVED",
          "body": "Despite the additional complexity, I think this takes us to a better place than #136.  In particular, it enables the generation of ESNIKeys to be simpler (outlining a block of addresses and a recovery path) and leaves the complexity in the A/AAAA where it already exists.\r\n\r\nThere's some wording issues, but technically I like this direction.",
          "createdAt": "2019-02-28T00:13:16Z",
          "updatedAt": "2019-02-28T00:30:02Z",
          "comments": [
            {
              "originalPosition": 176,
              "body": "So the idea here is that, even if there's no overlap between the A/AAAA results and the ESNI record addresses, if the host_pointer chain includes (terminal might be too strong a statement) the indicated name, then you try it?  This is a bit of a leap of faith on two fronts:  First, that they have the appropriate keys without being in the list of addresses, but second that the caller will get the CNAME chain back rather than just the addresses.\r\n\r\nPerhaps a reasonable optimization for those clients that can do it, though.",
              "createdAt": "2019-02-28T00:13:16Z",
              "updatedAt": "2019-02-28T00:30:02Z"
            },
            {
              "originalPosition": 168,
              "body": "\"the address netmask\" isn't defined, here or elsewhere.  I presume that this should read something like \"...and if the intersection of the A or AAAA responses and the set of address ranges in address_set is not empty, then clients SHOULD initiate TLS with ESNI to addresses in that intersection.\"",
              "createdAt": "2019-02-28T00:17:47Z",
              "updatedAt": "2019-02-28T00:30:02Z"
            },
            {
              "originalPosition": 175,
              "body": "Likewise, \"If the intersection (...) is empty but the A/AAAA resolution included a CNAME which matches....\"",
              "createdAt": "2019-02-28T00:19:02Z",
              "updatedAt": "2019-02-28T00:30:02Z"
            },
            {
              "originalPosition": 186,
              "body": "Isn't this just a subcase of the previous points?  If the address_set is empty, then by definition there's no overlap with the A/AAAA results.  So either the name occurs in the CNAME chain (4) or you resolve the name (5).",
              "createdAt": "2019-02-28T00:21:21Z",
              "updatedAt": "2019-02-28T00:30:02Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjA4ODQxNTc5",
          "commit": {
            "abbreviatedOid": "7adfa01"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-02-28T00:40:41Z",
          "updatedAt": "2019-02-28T00:40:41Z",
          "comments": [
            {
              "originalPosition": 168,
              "body": "Oh, hah, yes! Will fix.",
              "createdAt": "2019-02-28T00:40:41Z",
              "updatedAt": "2019-02-28T00:40:48Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjA4ODQxNjI1",
          "commit": {
            "abbreviatedOid": "7adfa01"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-02-28T00:40:52Z",
          "updatedAt": "2019-02-28T00:40:52Z",
          "comments": [
            {
              "originalPosition": 175,
              "body": "\ud83d\udc4d \r\n",
              "createdAt": "2019-02-28T00:40:52Z",
              "updatedAt": "2019-02-28T00:40:52Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjA4ODQxODc0",
          "commit": {
            "abbreviatedOid": "7adfa01"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-02-28T00:41:56Z",
          "updatedAt": "2019-02-28T00:41:56Z",
          "comments": [
            {
              "originalPosition": 186,
              "body": "Yes, technically. I left it as is to be explicit. I can remove it if we think it's excessive.",
              "createdAt": "2019-02-28T00:41:56Z",
              "updatedAt": "2019-02-28T00:41:56Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjA5ODA4MDM3",
          "commit": {
            "abbreviatedOid": "7adfa01"
          },
          "author": "MikeBishop",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-03-01T22:15:55Z",
          "updatedAt": "2019-03-01T22:15:56Z",
          "comments": [
            {
              "originalPosition": 186,
              "body": "Maybe instead of listing it as a separate step, just turn it into an unnumbered comment that an empty address set will always land in (4) or (5).",
              "createdAt": "2019-03-01T22:15:56Z",
              "updatedAt": "2019-03-01T22:15:56Z"
            }
          ]
        }
      ],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "f07d3806d52add7920a0f4087f93c85bede08581",
      "headRepository": "chris-wood/draft-ietf-tls-esni",
      "headRefName": "caw/multi-cdn",
      "headRefOid": "7adfa01707ef34bca44891084f386d2c587e1e04",
      "mergeCommit": null
    },
    {
      "number": 144,
      "id": "MDExOlB1bGxSZXF1ZXN0MjU4MTYwNDU5",
      "title": "Use new RRType instead of TXT with a custom prefix",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/144",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Subsumes #73 and #108.",
      "createdAt": "2019-03-05T02:31:59Z",
      "updatedAt": "2019-09-24T10:55:09Z",
      "closedAt": "2019-03-06T00:54:53Z",
      "mergedAt": "2019-03-06T00:54:52Z",
      "mergedBy": "chris-wood",
      "comments": [
        {
          "author": "mcmanus",
          "authorAssociation": "CONTRIBUTOR",
          "body": "lgtm",
          "createdAt": "2019-03-05T02:48:38Z",
          "updatedAt": "2019-03-05T02:48:38Z"
        },
        {
          "author": "ValZapod",
          "authorAssociation": "NONE",
          "body": "@chris-wood @kazuho @mcmanus \r\nWhat the... So all already working eSNI in Cloudflare is already outdated? Do you understand how difficult it will be to get new IN ESNI in Bind and Knot and even in dig utility? Do you understand that while IN txt is working in all OS, IN ESNI will not work in any of them (system resolver, I mean)? Do you understand that you use for ESNI RR 0xff9f (which is 65439), so it is reserved for private use in IANA?\r\nSolution for this. Can you please use both of them?",
          "createdAt": "2019-04-16T19:07:10Z",
          "updatedAt": "2019-04-16T19:07:10Z"
        },
        {
          "author": "mcmanus",
          "authorAssociation": "CONTRIBUTOR",
          "body": ">   Internet-Drafts are draft documents valid for a maximum of six months\r\n >  and may be updated, replaced, or obsoleted by other documents at any\r\n  > time.  It is inappropriate to use Internet-Drafts as reference\r\n  > material or to cite them other than as \"work in progress.\"\r\n",
          "createdAt": "2019-04-19T20:20:48Z",
          "updatedAt": "2019-04-19T20:20:48Z"
        },
        {
          "author": "Viktor45",
          "authorAssociation": "NONE",
          "body": "this is good for wiretapping for easy to drop all ESNI with DPI for SNI downgrade",
          "createdAt": "2019-09-24T10:55:09Z",
          "updatedAt": "2019-09-24T10:55:09Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjEwNDcyMjQ1",
          "commit": {
            "abbreviatedOid": "5f191fd"
          },
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": ":+1:",
          "createdAt": "2019-03-05T02:57:05Z",
          "updatedAt": "2019-03-05T02:57:05Z",
          "comments": []
        }
      ],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "f07d3806d52add7920a0f4087f93c85bede08581",
      "headRepository": "chris-wood/draft-ietf-tls-esni",
      "headRefName": "caw/remove-prefix-with-new-rrtype",
      "headRefOid": "5f191fdb2c5826a7be33de59a2128ac6d7ee6060",
      "mergeCommit": {
        "oid": "5fda4a09bcde55a2256053c79d5fc432d58b2f8d"
      }
    },
    {
      "number": 147,
      "id": "MDExOlB1bGxSZXF1ZXN0MjU5MzA1ODEy",
      "title": "Encrypt nonce for secure sharing of the true SNI with a third party",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/147",
      "state": "CLOSED",
      "author": "roelfdutoit",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Third party secret sharing solutions might be developed in future.  This PR enables sharing of the true SNI  while at the same time preventing the third party from impersonating the server.  The client encrypts the nonce with a key derived from Z, and only a server with access to Z will be able to acknowledge the decrypted nonce.",
      "createdAt": "2019-03-07T23:15:49Z",
      "updatedAt": "2019-07-04T15:52:58Z",
      "closedAt": "2019-07-04T15:52:58Z",
      "mergedAt": null,
      "mergedBy": null,
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@roelfdutoit what's the plan for this PR?",
          "createdAt": "2019-07-04T14:24:24Z",
          "updatedAt": "2019-07-04T14:24:24Z"
        }
      ],
      "reviews": [],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "d9437fd5a4ed04dff1b5e48f97c586f242e80fb4",
      "headRepository": "roelfdutoit/draft-ietf-tls-esni",
      "headRefName": "encrypted_nonce",
      "headRefOid": "9346ce43c15b9ccbb2d3369c362bed1acbc64e11",
      "mergeCommit": null
    },
    {
      "number": 148,
      "id": "MDExOlB1bGxSZXF1ZXN0MjU5NjEwNTQ2",
      "title": "specify 7838 reference applies to section 2.3",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/148",
      "state": "MERGED",
      "author": "mcmanus",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "closes #132",
      "createdAt": "2019-03-08T21:19:31Z",
      "updatedAt": "2019-03-08T21:24:29Z",
      "closedAt": "2019-03-08T21:24:29Z",
      "mergedAt": "2019-03-08T21:24:28Z",
      "mergedBy": "chris-wood",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjEyNDg1OTI0",
          "commit": {
            "abbreviatedOid": "89e83e5"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-03-08T21:24:25Z",
          "updatedAt": "2019-03-08T21:24:25Z",
          "comments": []
        }
      ],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "1b339186ec98274e93132de121e76ca55cce849d",
      "headRepository": "mcmanus/draft-rescorla-tls-esni",
      "headRefName": "mcmanus-altsvc-clarification",
      "headRefOid": "89e83e54809f169c36679cba6b92bccf89fa2978",
      "mergeCommit": {
        "oid": "a73367b8c58ba0a7f726743ad72ca4fd2b22574d"
      }
    },
    {
      "number": 151,
      "id": "MDExOlB1bGxSZXF1ZXN0MjY4OTQyMjEw",
      "title": "Exclude extensions from record digest",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/151",
      "state": "CLOSED",
      "author": "ghedo",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #150.",
      "createdAt": "2019-04-09T22:08:37Z",
      "updatedAt": "2019-04-14T23:22:12Z",
      "closedAt": "2019-04-14T23:22:11Z",
      "mergedAt": null,
      "mergedBy": null,
      "comments": [
        {
          "author": "ghedo",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Superseded by #153.",
          "createdAt": "2019-04-14T23:22:11Z",
          "updatedAt": "2019-04-14T23:22:11Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjI0NjgxNTAz",
          "commit": {
            "abbreviatedOid": "0d5c690"
          },
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-04-09T22:14:36Z",
          "updatedAt": "2019-04-09T22:14:37Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "It seems weird to exclude other extensions. Also I assume you mean the first byte of \"version\"?",
              "createdAt": "2019-04-09T22:14:36Z",
              "updatedAt": "2019-04-09T22:14:37Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjI0NzAyODgw",
          "commit": {
            "abbreviatedOid": "0d5c690"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-04-09T23:36:08Z",
          "updatedAt": "2019-04-09T23:36:08Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "I agree. I'm not sure this is the right approach. It seems we should either (a) have individual extensions included in the digest or not via some mandatory-like bit, or (b) have a separate extensions field that's omitted from the digest, in which the address information can go. Both are... not great.",
              "createdAt": "2019-04-09T23:36:08Z",
              "updatedAt": "2019-04-09T23:36:08Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjI0NzAzMTI3",
          "commit": {
            "abbreviatedOid": "0d5c690"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "Thanks for taking this issue! As the comment suggest, I'm not sure this is the best approach. I'm curious to hear counterarguments. ",
          "createdAt": "2019-04-09T23:37:11Z",
          "updatedAt": "2019-04-09T23:37:11Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjI0ODI2OTU2",
          "commit": {
            "abbreviatedOid": "0d5c690"
          },
          "author": "ghedo",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-04-10T08:30:30Z",
          "updatedAt": "2019-04-10T08:30:30Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "To me the point of `record_digest` is to identify a specific key so that the TLS server doesn't have to do trial decryption, that is, its point is not the digest itself, but the fact that it identifies a key, is this correct?\r\n\r\nIf so, it seems fine (but not great) that it would only really cover the specific key and the metadata directly associated with the key, while extensions can potentially be associated with multiple keys.\r\n\r\nBut a potentially better alternative is to just get rid of `record_digest` (if my assumption that it only provides an \"identity\" for the key), and replace with an explicit `key_identity` field that is generated by the server and would get added to `ESNIKeys` as well as replace `record_digest` in the ClientHello extension.\r\n\r\nThoughts?",
              "createdAt": "2019-04-10T08:30:30Z",
              "updatedAt": "2019-04-10T08:30:30Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjI1Mjk4MjY2",
          "commit": {
            "abbreviatedOid": "0d5c690"
          },
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-04-11T02:00:24Z",
          "updatedAt": "2019-04-11T02:00:25Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "@ghedo \r\n> But a potentially better alternative is to just get rid of `record_digest` (if my assumption that it only provides an \"identity\" for the key), and replace with an explicit `key_identity` field that is generated by the server and would get added to `ESNIKeys` as well as replace `record_digest` in the ClientHello extension.\r\n\r\nI am not sure if that is the correct thing to do. I'd be concerned that omission of a digest might lead to availability concerns.\r\n\r\nThe reason we have had `record_digest` is because the TLS handshake used to always hard-fail when client uses a corrupt ESNI record. With #124 being merged, we have a fallback mechanism that would work in _some_ failure modes without the need for the digest. However, I believe that there are still certain cases of hard failure (like the server sending an `illegal_parameter` alert) when the ESNI record is corrupt.\r\n\r\nPS. Therefore I think I might favor the approach proposed by @davidben in #150: place the IP address list outside of the ESNIKeys.",
              "createdAt": "2019-04-11T02:00:25Z",
              "updatedAt": "2019-04-11T02:02:50Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjI1NTEwMDQy",
          "commit": {
            "abbreviatedOid": "0d5c690"
          },
          "author": "ghedo",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-04-11T12:45:31Z",
          "updatedAt": "2019-04-11T12:45:32Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "I'm not sure I follow @kazuho, isn't the `checksum` value intended to detect record corruption? If so, why do we have two?",
              "createdAt": "2019-04-11T12:45:32Z",
              "updatedAt": "2019-04-11T12:45:32Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjI1NzE4ODI2",
          "commit": {
            "abbreviatedOid": "0d5c690"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-04-11T18:41:38Z",
          "updatedAt": "2019-04-11T18:41:38Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "@ghedo `record_digest` was originally added to prevent downgrades, so we want it to cover as much of the necessary bits in the record as possible. It just so happens to also serve as a key identifier for the server.",
              "createdAt": "2019-04-11T18:41:38Z",
              "updatedAt": "2019-04-11T18:41:38Z"
            }
          ]
        }
      ],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "ba52fe66fb3a9a8d98dfd3d59b7322c454405f03",
      "headRepository": null,
      "headRefName": "record-digest-no-extensions",
      "headRefOid": "0d5c6905c8fc5ec2d9d9574bc958c8179af643ba",
      "mergeCommit": null
    },
    {
      "number": 152,
      "id": "MDExOlB1bGxSZXF1ZXN0MjcwMTMzMjY5",
      "title": "There's no ESNI TXT record anymore",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/152",
      "state": "MERGED",
      "author": "ghedo",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2019-04-12T19:52:40Z",
      "updatedAt": "2019-04-12T23:18:38Z",
      "closedAt": "2019-04-12T23:18:38Z",
      "mergedAt": "2019-04-12T23:18:38Z",
      "mergedBy": "chris-wood",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjI2MzIwMTE0",
          "commit": {
            "abbreviatedOid": "70b9b6b"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-04-12T23:18:32Z",
          "updatedAt": "2019-04-12T23:18:32Z",
          "comments": []
        }
      ],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "ba52fe66fb3a9a8d98dfd3d59b7322c454405f03",
      "headRepository": null,
      "headRefName": "not-txt",
      "headRefOid": "70b9b6b66a02866626699d0ad11981cf55309e32",
      "mergeCommit": {
        "oid": "51bc4ed89ae61585bd800d55785b5abd7c457a30"
      }
    },
    {
      "number": 153,
      "id": "MDExOlB1bGxSZXF1ZXN0MjcwMzM1NjU5",
      "title": "Introduce ESNIRecord wrapper and move AddressSet into it",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/153",
      "state": "MERGED",
      "author": "ghedo",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #150.\r\n\r\n---\r\n\r\nTry 2. This turned out to be somewhat tricky due to existing text using \"ESNI record\" and \"ESNIKeys record\" (and similar) interchangeably, so I might have missed some instances.\r\n\r\nAn alternative design would have been to have a single ESNIRecord value per ESNI record, and then have multiple ESNIKeys values for each ESNIRecord (instead of multiple ESNIRecord values per ESNI and single ESNIKeys per ESNIRecord), though that will require more changes.",
      "createdAt": "2019-04-14T23:20:56Z",
      "updatedAt": "2019-04-18T16:40:57Z",
      "closedAt": "2019-04-18T16:40:57Z",
      "mergedAt": "2019-04-18T16:40:57Z",
      "mergedBy": "chris-wood",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks, @ghedo!",
          "createdAt": "2019-04-18T16:40:44Z",
          "updatedAt": "2019-04-18T16:40:44Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjI4MDAwMDM2",
          "commit": {
            "abbreviatedOid": "2432376"
          },
          "author": "dvorak42",
          "authorAssociation": "NONE",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-04-17T21:09:23Z",
          "updatedAt": "2019-04-17T21:11:29Z",
          "comments": [
            {
              "originalPosition": 49,
              "body": "Might be useful to call out that these extensions aren't verified as part of the record_digest?",
              "createdAt": "2019-04-17T21:09:23Z",
              "updatedAt": "2019-04-17T21:11:29Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjI4MzkwNTYy",
          "commit": {
            "abbreviatedOid": "2432376"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-04-18T16:40:33Z",
          "updatedAt": "2019-04-18T16:40:33Z",
          "comments": [
            {
              "originalPosition": 49,
              "body": "Agreed. I'll merge this and then make that change directly. ",
              "createdAt": "2019-04-18T16:40:33Z",
              "updatedAt": "2019-04-18T16:40:33Z"
            }
          ]
        }
      ],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "51bc4ed89ae61585bd800d55785b5abd7c457a30",
      "headRepository": null,
      "headRefName": "extensions-all-the-way-down",
      "headRefOid": "2432376197825756c171842e06fbcfc981f13a74",
      "mergeCommit": {
        "oid": "8679dc49caa2131d9b660d9d30e4343aa7e994f9"
      }
    },
    {
      "number": 154,
      "id": "MDExOlB1bGxSZXF1ZXN0MjcyODcxMDIy",
      "title": "Switch to record_digest_mac to prevent GREASE detection.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/154",
      "state": "CLOSED",
      "author": "dvorak42",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Currently an attacker can distinguish a real ESNI extension and\r\nGREASE extension based on the error returned by replaying the\r\nclient's ClientHello with swapped out keyshares.",
      "createdAt": "2019-04-23T19:57:59Z",
      "updatedAt": "2020-05-20T15:59:48Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "4f3ce56fdb4caea12c6480ca3a9a5ec6bfd074c1",
      "headRepository": "dvorak42/draft-ietf-tls-esni",
      "headRefName": "grease_mac",
      "headRefOid": "bf4dee02a17f8afbb2828b50c320527be1e2d455",
      "closedAt": "2020-05-20T15:59:48Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing in favor of #235!",
          "createdAt": "2020-05-20T15:59:47Z",
          "updatedAt": "2020-05-20T15:59:47Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjMwMjYwNzc3",
          "commit": {
            "abbreviatedOid": "eadc232"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-04-24T17:43:32Z",
          "updatedAt": "2019-04-24T17:43:33Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "s/, however/. However,",
              "createdAt": "2019-04-24T17:43:32Z",
              "updatedAt": "2019-04-24T19:21:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjMwMjYxMTQx",
          "commit": {
            "abbreviatedOid": "eadc232"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-04-24T17:44:19Z",
          "updatedAt": "2019-04-24T17:44:20Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "nit: s/the IP it is connecting to./the destination IP address./",
              "createdAt": "2019-04-24T17:44:19Z",
              "updatedAt": "2019-04-24T19:21:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjMwMjYzMDQz",
          "commit": {
            "abbreviatedOid": "eadc232"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-04-24T17:47:56Z",
          "updatedAt": "2019-04-24T17:47:56Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "nit: I'd replace \"the attacker Adv\" with \"an attacker\", and \"they'd\" with \"Adv\"",
              "createdAt": "2019-04-24T17:47:56Z",
              "updatedAt": "2019-04-24T19:21:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjMwMjYzMzI3",
          "commit": {
            "abbreviatedOid": "eadc232"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-04-24T17:48:27Z",
          "updatedAt": "2019-04-24T17:48:27Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "nit: Perhaps say that this *may* disincentive deployment?",
              "createdAt": "2019-04-24T17:48:27Z",
              "updatedAt": "2019-04-24T19:21:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjMwMjYzODE1",
          "commit": {
            "abbreviatedOid": "1bcb80f"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "I'm OK with this change given the perceived risk. @ekr, @kazuho @grittygrease: please have a look and comment. ",
          "createdAt": "2019-04-24T17:49:24Z",
          "updatedAt": "2019-04-24T17:52:45Z",
          "comments": [
            {
              "originalPosition": 52,
              "body": "Perhaps drop a forward pointer to the security considerations blurb here?",
              "createdAt": "2019-04-24T17:49:24Z",
              "updatedAt": "2019-04-24T19:21:19Z"
            },
            {
              "originalPosition": 20,
              "body": "Perhaps point to the section where it's defined?",
              "createdAt": "2019-04-24T17:52:02Z",
              "updatedAt": "2019-04-24T19:21:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjMwMzI4Mzk4",
          "commit": {
            "abbreviatedOid": "bf4dee0"
          },
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-04-24T20:06:40Z",
          "updatedAt": "2019-04-24T20:06:40Z",
          "comments": [
            {
              "originalPosition": 140,
              "body": "I'm not sure how persuasive I find this. It seems like it's quite likely that the attacker can determine which IP addresses support ESNI, simply by doing reverse resolution and then forward resolution. Why does this help?",
              "createdAt": "2019-04-24T20:06:40Z",
              "updatedAt": "2019-04-24T20:06:41Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjMxODczNTM1",
          "commit": {
            "abbreviatedOid": "bf4dee0"
          },
          "author": "dvorak42",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-04-29T20:02:21Z",
          "updatedAt": "2019-04-29T20:02:22Z",
          "comments": [
            {
              "originalPosition": 140,
              "body": "A way of avoiding that, though which might be problematic to deploy, is that the reverse resolution name and the public name don't have ESNI records, since you don't necessarily need ESNI when hitting those names, since they're already visible to an attacker.",
              "createdAt": "2019-04-29T20:02:22Z",
              "updatedAt": "2019-04-29T20:02:22Z"
            }
          ]
        }
      ]
    },
    {
      "number": 157,
      "id": "MDExOlB1bGxSZXF1ZXN0Mjg0MzI5MzI4",
      "title": "Allow different records while keeping the same anonymity set",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/157",
      "state": "MERGED",
      "author": "DavidSchinazi",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The current text about anonymity sets for records is too restrictive. If I have 100000 names and 100 IPs and for all queries I randomly return four out of my 100 IPs chosen randomly, I still provide the same anonymity set but I violate the SHOULD. The proposed text fixes #133 ",
      "createdAt": "2019-06-02T09:35:45Z",
      "updatedAt": "2019-06-03T08:26:37Z",
      "closedAt": "2019-06-02T15:13:39Z",
      "mergedAt": "2019-06-02T15:13:38Z",
      "mergedBy": "chris-wood",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQ0NjMwNzcz",
          "commit": {
            "abbreviatedOid": "0248ca7"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "LGTM -- thanks!",
          "createdAt": "2019-06-02T15:12:46Z",
          "updatedAt": "2019-06-02T15:12:58Z",
          "comments": []
        }
      ],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "4f3ce56fdb4caea12c6480ca3a9a5ec6bfd074c1",
      "headRepository": "DavidSchinazi/draft-ietf-tls-esni",
      "headRefName": "allow_different_records",
      "headRefOid": "0248ca74b80bcf2c9174753c2599232d555964c4",
      "mergeCommit": {
        "oid": "8c9626ea59a087ab006da8b37bb251b28df68403"
      }
    },
    {
      "number": 158,
      "id": "MDExOlB1bGxSZXF1ZXN0Mjg0MzYwNDk3",
      "title": "Clarify AAD for encrypted_sni and HKDF-Extract salt",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/158",
      "state": "MERGED",
      "author": "Lekensteyn",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "While at it, remove the redundant \"ClientHello.\" prefix, the name\r\nKeyShareClientHello implies this. Fixes #155\r\n___\r\n@sftcd I did not explicitly mention that \"extension_data\" is a list of key shares, but hope that the suggested phrase is strong enough to imply that. Do you think that is sufficient or should it become something like:\r\n\r\n> Where ClientHello.KeyShareClientHello is the \"extension_data\" field of the\r\n> \"key_share\" extension in a Client Hello (Section 4.2.8 of {{!RFC8446}})),\r\n> namely a list of key shares.\r\n\r\n(By the way, the list of client key shares could contain one or more entries, but it could also be empty if the client would like to trigger a HRR. That should still be OK since the key/nonce is derived from the client hello random.)",
      "createdAt": "2019-06-02T18:16:04Z",
      "updatedAt": "2019-06-02T23:03:59Z",
      "closedAt": "2019-06-02T19:57:43Z",
      "mergedAt": "2019-06-02T19:57:43Z",
      "mergedBy": "chris-wood",
      "comments": [
        {
          "author": "sftcd",
          "authorAssociation": "NONE",
          "body": "Those changes seem okish though could maybe be better. My issue was that OpenSSL (afaics) previously ignored all the key shares except the one used, so handling two of 'em as the AAD meant adding some new state. No idea if other implementations are like that though. I guess it might help someone else if it explicitly said that there can be >1 key share to include in the AAD.\r\n\r\n(BTW, on your BTW, I need to think more about ESNI and HRR handling, haven't tested that yet so not sure if there's a case where the encoding of 0 key shares would be used as ESNI AAD.)\r\n",
          "createdAt": "2019-06-02T18:30:34Z",
          "updatedAt": "2019-06-02T18:30:34Z"
        },
        {
          "author": "Lekensteyn",
          "authorAssociation": "CONTRIBUTOR",
          "body": "If this adds so much complication, why not drop the KeyShareClientHello completely? If the purpose is to bind this to the original Client Hello, then the Client Random should be sufficient.\r\n\r\nAn implementation that creates the encrypted_sni field is also responsible for generating a random client hello and a new ESNI key share. Assuming that these are always unique between Client Hellos, then removing the KeyShareClientHello extension should still preserve the binding property.\r\n\r\nAnd even if for some reason the ESNI key share is reused (e.g. shared between different client hello, or reusing one from KeyShareClientHello), the derived key/nonce would still be different if Client Hello Random is unique.\r\n\r\n@chris-wood what was the reason for mixing the client key shares list in addition to the existing client random (commit 134b15c87b5c4cde7f52500138662f64757e2e9c)?",
          "createdAt": "2019-06-02T19:14:13Z",
          "updatedAt": "2019-06-02T19:14:13Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "If you don't bind in the client key share, there is a trivial attack in which the attacker replaces the key share with their own, causing the server's certificate to be encrypted to them.",
          "createdAt": "2019-06-02T19:22:17Z",
          "updatedAt": "2019-06-02T19:22:17Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> @chris-wood what was the reason for mixing the client key shares list in addition to the existing client random (commit 134b15c)?\r\n\r\nWhat @ekr said above. :-)",
          "createdAt": "2019-06-02T19:56:05Z",
          "updatedAt": "2019-06-02T19:56:05Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks for the clarifying text!",
          "createdAt": "2019-06-02T19:57:39Z",
          "updatedAt": "2019-06-02T19:57:39Z"
        },
        {
          "author": "Lekensteyn",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> If you don't bind in the client key share, there is a trivial attack in which the attacker replaces the key share with their own, causing the server's certificate to be encrypted to them.\r\n\r\nOh I see, the sender of the ESNI extension does not have to prove its knowledge about the ESNI private key, so an attacker could trivially copy the victim's ESNI extension and client random into the attacker's handshake, and recover the certificate if the client key shares were not included. Even if the attacker cannot decrypt SNI, they can still observe the side-effects. Thanks!\r\n\r\nI think the text could be clarified to highlight this, I'll prepare a proposal for this.",
          "createdAt": "2019-06-02T23:03:59Z",
          "updatedAt": "2019-06-02T23:03:59Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQ0NjQwMTU1",
          "commit": {
            "abbreviatedOid": "6c43eb7"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-06-02T19:57:31Z",
          "updatedAt": "2019-06-02T19:57:31Z",
          "comments": []
        }
      ],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "8c9626ea59a087ab006da8b37bb251b28df68403",
      "headRepository": "Lekensteyn/draft-ietf-tls-esni",
      "headRefName": "clarify-aad",
      "headRefOid": "6c43eb7a76fb16cc18746bae665dd54a767f9b6f",
      "mergeCommit": {
        "oid": "6c78c495e19f4977d3b030a36433dd982f544b18"
      }
    },
    {
      "number": 159,
      "id": "MDExOlB1bGxSZXF1ZXN0Mjg0Mzg2MjY0",
      "title": "Clarify how anti-replay protection is achieved",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/159",
      "state": "CLOSED",
      "author": "Lekensteyn",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The SNI encryption key is not bound to the Client Hello, one could for\r\nexample \"cut and paste\" the ESNI value in a different Client Hello with\r\nthe same Random field, key_share extension and ESNI extension, but with\r\na different, say, supported_groups extension.\r\n\r\nRemove the (EC)DH argument since it only ensures that an attacker cannot\r\ncompute the SNI encryption key, but actual anti-replay protection is\r\nprovided by binding to the key_share extension.",
      "createdAt": "2019-06-03T01:00:58Z",
      "updatedAt": "2020-03-09T21:58:20Z",
      "closedAt": "2020-03-09T21:58:20Z",
      "mergedAt": null,
      "mergedBy": null,
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "This is likely overcome by events in #207. @Lekensteyn, can you please update this PR based on that text, or close it?",
          "createdAt": "2020-03-08T00:36:50Z",
          "updatedAt": "2020-03-08T00:36:50Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Overcome by #207.",
          "createdAt": "2020-03-09T21:58:20Z",
          "updatedAt": "2020-03-09T21:58:20Z"
        }
      ],
      "reviews": [],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "6c78c495e19f4977d3b030a36433dd982f544b18",
      "headRepository": "Lekensteyn/draft-ietf-tls-esni",
      "headRefName": "clarify-anti-replay",
      "headRefOid": "429e5a8da0bd3e09effbc7075eb62a94597aedd5",
      "mergeCommit": null
    },
    {
      "number": 161,
      "id": "MDExOlB1bGxSZXF1ZXN0Mjg4NzQyMDY1",
      "title": "Remove not_before and not_after",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/161",
      "state": "MERGED",
      "author": "ghedo",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "We now have a proper retry mechanism, so we don't need to prevent\r\nclients to connect using expired keys anymore.",
      "createdAt": "2019-06-17T08:24:11Z",
      "updatedAt": "2019-06-17T18:17:17Z",
      "closedAt": "2019-06-17T18:17:17Z",
      "mergedAt": "2019-06-17T18:17:17Z",
      "mergedBy": "chris-wood",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjUwMzc1OTEw",
          "commit": {
            "abbreviatedOid": "9b267c2"
          },
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Thank you for the PR. LGTM",
          "createdAt": "2019-06-17T09:10:38Z",
          "updatedAt": "2019-06-17T09:10:38Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjUwNjY2NDM3",
          "commit": {
            "abbreviatedOid": "9b267c2"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-06-17T18:17:10Z",
          "updatedAt": "2019-06-17T18:17:10Z",
          "comments": []
        }
      ],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "6c78c495e19f4977d3b030a36433dd982f544b18",
      "headRepository": null,
      "headRefName": "remove-not-before-after",
      "headRefOid": "9b267c20662db55ba54afa715a06be5990fe6930",
      "mergeCommit": {
        "oid": "46490d1ad41cf67b2ae4ad4aac9785a351acd8fd"
      }
    },
    {
      "number": 162,
      "id": "MDExOlB1bGxSZXF1ZXN0Mjg5ODM2NTQ1",
      "title": "Restrict padded_length values",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/162",
      "state": "MERGED",
      "author": "bemasc",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "See discussion at https://github.com/tlswg/draft-ietf-tls-esni/issues/134",
      "createdAt": "2019-06-19T18:53:21Z",
      "updatedAt": "2019-06-27T18:09:36Z",
      "closedAt": "2019-06-27T18:09:36Z",
      "mergedAt": "2019-06-27T18:09:36Z",
      "mergedBy": "chris-wood",
      "comments": [
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "I am not a fan of this change. I don't like encoding this kind of restrictive choice in the protocol.",
          "createdAt": "2019-06-19T19:01:16Z",
          "updatedAt": "2019-06-19T19:01:16Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "CONTRIBUTOR",
          "body": "OK, I've removed the protocol change and made the restriction purely advisory.",
          "createdAt": "2019-06-19T19:15:01Z",
          "updatedAt": "2019-06-19T19:15:01Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU0MjUxNTcx",
          "commit": {
            "abbreviatedOid": "7d453b2"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "The recommended text LGTM. @kazuho @ekr @grittygrease please have a look.",
          "createdAt": "2019-06-25T20:29:55Z",
          "updatedAt": "2019-06-25T20:29:55Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU0MzIwNjgw",
          "commit": {
            "abbreviatedOid": "7d453b2"
          },
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "LGTM. Thank you for the text!",
          "createdAt": "2019-06-25T23:33:29Z",
          "updatedAt": "2019-06-25T23:33:29Z",
          "comments": []
        }
      ],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "46490d1ad41cf67b2ae4ad4aac9785a351acd8fd",
      "headRepository": "bemasc/draft-ietf-tls-esni",
      "headRefName": "bemasc-padded-length",
      "headRefOid": "7d453b23db56f59e9a72895f953ca789a8b00060",
      "mergeCommit": {
        "oid": "dfad9d1f770133375535808f12ccc6376faabeb7"
      }
    },
    {
      "number": 163,
      "id": "MDExOlB1bGxSZXF1ZXN0MjkzOTY0NzAy",
      "title": "Remove checksum in favor of record_digest and retry mechanism.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/163",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The checksum seems to add little value with the retry mechanism and record_digest. I think we should remove it. See #64 for some context.",
      "createdAt": "2019-07-03T00:56:28Z",
      "updatedAt": "2019-07-03T01:20:19Z",
      "closedAt": "2019-07-03T01:20:19Z",
      "mergedAt": "2019-07-03T01:20:19Z",
      "mergedBy": "chris-wood",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU3MjIwNjYz",
          "commit": {
            "abbreviatedOid": "f087cd1"
          },
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "I agree that we can now and should make this simplification. The PR looks good to me.",
          "createdAt": "2019-07-03T01:19:48Z",
          "updatedAt": "2019-07-03T01:19:48Z",
          "comments": []
        }
      ],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "dfad9d1f770133375535808f12ccc6376faabeb7",
      "headRepository": "tlswg/draft-ietf-tls-esni",
      "headRefName": "caw/remove-checksum",
      "headRefOid": "f087cd10d2586ebf61341f32aa80c474ad1ea89b",
      "mergeCommit": {
        "oid": "a25f407349622080025d737536b09ba421cd6bbb"
      }
    },
    {
      "number": 164,
      "id": "MDExOlB1bGxSZXF1ZXN0MjkzOTY1NjE2",
      "title": "Add reference to RFC8446 for TLS notation.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/164",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #160.",
      "createdAt": "2019-07-03T01:02:37Z",
      "updatedAt": "2019-07-03T01:09:00Z",
      "closedAt": "2019-07-03T01:09:00Z",
      "mergedAt": "2019-07-03T01:08:59Z",
      "mergedBy": "ekr",
      "comments": [],
      "reviews": [],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "dfad9d1f770133375535808f12ccc6376faabeb7",
      "headRepository": "tlswg/draft-ietf-tls-esni",
      "headRefName": "caw/presentation-language",
      "headRefOid": "fad362f9809d24b96ed029e36a60f616792135da",
      "mergeCommit": {
        "oid": "5f41edfaa689fe899148bb640a3886ce7c7e3fef"
      }
    },
    {
      "number": 165,
      "id": "MDExOlB1bGxSZXF1ZXN0MjkzOTY3NDA5",
      "title": "SNI extensibility failed. See [1].",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/165",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "[1] https://mailarchive.ietf.org/arch/msg/tls/1t79gzNItZd71DwwoaqcQQ_4Yxc\r\n\r\nFixes #68.",
      "createdAt": "2019-07-03T01:15:09Z",
      "updatedAt": "2019-07-03T20:30:29Z",
      "closedAt": "2019-07-03T20:30:29Z",
      "mergedAt": "2019-07-03T20:30:29Z",
      "mergedBy": "chris-wood",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU3MjIxNjYy",
          "commit": {
            "abbreviatedOid": "6a37e61"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-07-03T01:25:16Z",
          "updatedAt": "2019-07-03T01:25:20Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "I don't know if this is the best place to signal this, but I approve anyway.",
              "createdAt": "2019-07-03T01:25:17Z",
              "updatedAt": "2019-07-03T01:25:20Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU3MjIyMjcy",
          "commit": {
            "abbreviatedOid": "6a37e61"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-03T01:28:17Z",
          "updatedAt": "2019-07-03T01:28:17Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "I figured it's best to be honest and up front. :-)",
              "createdAt": "2019-07-03T01:28:17Z",
              "updatedAt": "2019-07-03T01:28:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU3MjI5MDUx",
          "commit": {
            "abbreviatedOid": "6a37e61"
          },
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-07-03T02:02:50Z",
          "updatedAt": "2019-07-03T02:02:50Z",
          "comments": []
        }
      ],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "5f41edfaa689fe899148bb640a3886ce7c7e3fef",
      "headRepository": "tlswg/draft-ietf-tls-esni",
      "headRefName": "caw/hostnames-only",
      "headRefOid": "6a37e61f86521654a9afe015347e9a8d9bd4a8b9",
      "mergeCommit": {
        "oid": "4ec4cb4ee196a4cec35fdce9640bf86cc559bc2a"
      }
    },
    {
      "number": 166,
      "id": "MDExOlB1bGxSZXF1ZXN0MjkzOTkxMjE1",
      "title": "Add note about optional record_digest and trial decryption alternative.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/166",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Addresses #138.",
      "createdAt": "2019-07-03T03:50:04Z",
      "updatedAt": "2019-07-08T17:25:21Z",
      "closedAt": "2019-07-08T17:25:21Z",
      "mergedAt": "2019-07-08T17:25:21Z",
      "mergedBy": "chris-wood",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@huitema can you please take a look?",
          "createdAt": "2019-07-03T03:50:17Z",
          "updatedAt": "2019-07-03T03:50:17Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yes, adding a trial decryption is a good thing. Two suggestions:\r\n\r\n1) in security section describe privacy attack by tracking the crypto ID.\r\n\r\n2) also describe the attack by forcing trial decryption.\r\n\r\nMaybe add an option to publish ESNI record with NULL checksum as a way to signal acceptance of trial decryption ?\r\n\r\n",
          "createdAt": "2019-07-03T06:18:53Z",
          "updatedAt": "2019-07-03T06:18:53Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> 1. in security section describe privacy attack by tracking the crypto ID.\r\n\r\nI plan to address this in a PR for #146.\r\n\r\n> 2. also describe the attack by forcing trial decryption.\r\n\r\nGood suggestion! I'll add that here.\r\n",
          "createdAt": "2019-07-03T13:51:10Z",
          "updatedAt": "2019-07-03T13:51:10Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@huitema please let me know if the latest text works for you!",
          "createdAt": "2019-07-03T13:57:00Z",
          "updatedAt": "2019-07-03T13:57:00Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@kazuho @ekr can you please take a look?",
          "createdAt": "2019-07-04T14:18:42Z",
          "updatedAt": "2019-07-04T14:18:42Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "I think you should say that it has to be somehow externally configured.\n\nOn Mon, Jul 8, 2019 at 9:27 AM Christopher Wood <notifications@github.com>\nwrote:\n\n> *@chris-wood* commented on this pull request.\n> ------------------------------\n>\n> In draft-ietf-tls-esni.md\n> <https://github.com/tlswg/draft-ietf-tls-esni/pull/166#discussion_r301187179>\n> :\n>\n> > @@ -743,10 +750,14 @@ for servers to proceed with the connection and rely on the client to abort if\n>  ESNI was required. In particular, the unrecognized value alone does not\n>  indicate a misconfigured ESNI advertisement ({{misconfiguration}}). Instead,\n>  servers can measure occurrences of the \"esni_required\" alert to detect this\n> -case.\n> +case. An empty ClientEncryptedSNI.record_digest value MAY be used in environments\n> +wherein trial decryption is a viable approach for matching ClientEncryptedSNI\n> +contents to a known ESNIKeys. (Some uses of ESNI, such as local discovery mode,\n>\n> It'd be application or deployment-specific. In DNS-SD, for example, they'd\n> likely configure the stack to omit the record digest.\n>\n> \u2014\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/tlswg/draft-ietf-tls-esni/pull/166?email_source=notifications&email_token=AAIPLINEK7B5LDKCKVQFIXLP6NTHJA5CNFSM4H5BUB4KYY3PNVWWK3TUL52HS4DFWFIHK3DMKJSXC5LFON2FEZLWNFSXPKTDN5WW2ZLOORPWSZGOB5YFAVQ#discussion_r301187179>,\n> or mute the thread\n> <https://github.com/notifications/unsubscribe-auth/AAIPLIMP7MKI63IRGSLCW3LP6NTHJANCNFSM4H5BUB4A>\n> .\n>\n",
          "createdAt": "2019-07-08T16:28:43Z",
          "updatedAt": "2019-07-08T16:28:43Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> I think you should say that it has to be somehow externally configured.\r\n\r\nGood suggestion! Will fix.",
          "createdAt": "2019-07-08T16:37:29Z",
          "updatedAt": "2019-07-08T16:37:29Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU3NTQ5NjEw",
          "commit": {
            "abbreviatedOid": "87a98f0"
          },
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-03T14:59:36Z",
          "updatedAt": "2019-07-03T14:59:37Z",
          "comments": [
            {
              "originalPosition": 93,
              "body": "To clarify, is the intent here is that servers outside those environments are not required to implement trial decryption?\r\n\r\nThe text reads a little unclear to me. The paragraph above just says an empty one \"MAY be used in [some environments]\", but that could mean by either the client or the server. This paragraph also could read as if the server needs to check the trial decryption, otherwise it doesn't know whether to follow these steps.\r\n\r\n(Trial decryption would more fully solve the issue #154 is trying to address, but I worry about the performance cost of asymmetric trial decryption if you rotate keys decently often. Then again, the robustness fixes do mean it's okay to drop older keys sooner if only used by a tiny fraction of clients...)",
              "createdAt": "2019-07-03T14:59:36Z",
              "updatedAt": "2019-07-08T17:24:59Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU3NTU4NDEw",
          "commit": {
            "abbreviatedOid": "87a98f0"
          },
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-03T15:12:29Z",
          "updatedAt": "2019-07-03T15:12:29Z",
          "comments": [
            {
              "originalPosition": 93,
              "body": "The trial decryption should be opt-in. The typical use case is in local discovery, with DTLS or QUIC. Broadcast or multicast the first packet, and then all servers who are ready to be discovered do trial detection. Yes, this is trading off CPU for server privacy, which is only OK in some scenario. In a typical implementation, the server would have a \"discovery\" flag, which will enable trial decryption when \"waiting to be discovered\". ",
              "createdAt": "2019-07-03T15:12:29Z",
              "updatedAt": "2019-07-08T17:24:59Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU3NTgwMzQ4",
          "commit": {
            "abbreviatedOid": "87a98f0"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-03T15:45:47Z",
          "updatedAt": "2019-07-03T15:45:47Z",
          "comments": [
            {
              "originalPosition": 93,
              "body": "> To clarify, is the intent here is that servers outside those environments are not required to implement trial decryption?\r\n\r\nPrecisely. I see what you mean about it implying trial decryption is necessary. Perhaps: \r\n\r\n```\r\nIf the ClientEncryptedSNI.record_digest value does match a known ESNIKeys, the server...\r\n```\r\n\r\nAnd then later on...\r\n\r\n```\r\nIf ClientEncryptedSNI.record_digest is non-empty, servers SHOULD compare it against cryptographic hashes of known ESNIKeys to find a match. If ClientEncryptedSNI.record_digest is empty, servers MAY use trial decryption to match to a known ESNIKeys.\r\n```\r\n",
              "createdAt": "2019-07-03T15:45:47Z",
              "updatedAt": "2019-07-08T17:24:59Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU3NTg0NDAz",
          "commit": {
            "abbreviatedOid": "249505b"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-03T15:52:12Z",
          "updatedAt": "2019-07-03T15:52:13Z",
          "comments": [
            {
              "originalPosition": 93,
              "body": "@davidben @huitema: I made an attempt at clarifying the text. Suggestions for improvements are welcome!",
              "createdAt": "2019-07-03T15:52:13Z",
              "updatedAt": "2019-07-08T17:24:59Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU3NjAwODcz",
          "commit": {
            "abbreviatedOid": "249505b"
          },
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-03T16:19:34Z",
          "updatedAt": "2019-07-03T16:20:22Z",
          "comments": [
            {
              "originalPosition": 129,
              "body": "Looking at this, I wonder whether there are other mitigations than \"rate limiting\". Take for example the case of a server that has published only one key: trial decryption then is no more expensive that decryption directed by a specific checksum, which the adversary can learn from the DNS record. So an obvious mitigation in case of stress is to only trial one of the published keys, possibly the latest, or a randomly chosen one.\r\n\r\nMaybe we should point out the directed DOS attack -- for example, an adversary could bomb a forwarding server with repeated connection request. But then, that's not much more potent than repeated non-ESNI connection requests.",
              "createdAt": "2019-07-03T16:19:34Z",
              "updatedAt": "2019-07-08T17:24:59Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU3NjExNDU0",
          "commit": {
            "abbreviatedOid": "249505b"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-03T16:39:13Z",
          "updatedAt": "2019-07-03T16:39:13Z",
          "comments": [
            {
              "originalPosition": 129,
              "body": "> I wonder whether there are other mitigations than \"rate limiting\".\r\n\r\nThere probably are, which is why I list this as only one example :-) Would you prefer we just drop this sentence entirely?",
              "createdAt": "2019-07-03T16:39:13Z",
              "updatedAt": "2019-07-08T17:24:59Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU5MDExNzE2",
          "commit": {
            "abbreviatedOid": "cc89246"
          },
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-08T16:14:07Z",
          "updatedAt": "2019-07-08T16:16:51Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "This \"otherwise\" seems to forbid random record_digests (as opposed to empty) or to fall back to trial decryption.. Is that intended?",
              "createdAt": "2019-07-08T16:14:07Z",
              "updatedAt": "2019-07-08T17:24:59Z"
            },
            {
              "originalPosition": 29,
              "body": "How would you know that this is possible.",
              "createdAt": "2019-07-08T16:14:57Z",
              "updatedAt": "2019-07-08T17:24:59Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU5MDE4NTAz",
          "commit": {
            "abbreviatedOid": "cc89246"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-08T16:26:51Z",
          "updatedAt": "2019-07-08T16:26:51Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "Hmm, good point. It's not intended. I'll remove \"Otherwise.\"",
              "createdAt": "2019-07-08T16:26:51Z",
              "updatedAt": "2019-07-08T17:24:59Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU5MDE4ODM4",
          "commit": {
            "abbreviatedOid": "cc89246"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-08T16:27:30Z",
          "updatedAt": "2019-07-08T16:27:31Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "It'd be application or deployment-specific. In DNS-SD, for example, they'd likely configure the stack to omit the record digest. ",
              "createdAt": "2019-07-08T16:27:31Z",
              "updatedAt": "2019-07-08T17:24:59Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU5MDQ2MzQw",
          "commit": {
            "abbreviatedOid": "bca2bb3"
          },
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-07-08T17:20:35Z",
          "updatedAt": "2019-07-08T17:20:43Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "I would write this as:\r\n\"Unless specified by the application using DTLS or externally configured on both sides, implementations MUST use the first method.\"",
              "createdAt": "2019-07-08T17:20:35Z",
              "updatedAt": "2019-07-08T17:24:59Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU5MDQ4Nzky",
          "commit": {
            "abbreviatedOid": "4163aff"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-08T17:25:14Z",
          "updatedAt": "2019-07-08T17:25:14Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "That's much better -- thanks!",
              "createdAt": "2019-07-08T17:25:14Z",
              "updatedAt": "2019-07-08T17:25:14Z"
            }
          ]
        }
      ],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "342840b5430948ffe709f5d665d63859edee2f67",
      "headRepository": "tlswg/draft-ietf-tls-esni",
      "headRefName": "caw/optional-digest",
      "headRefOid": "4163aff4ffdcf9f5cc7b61588128be0102d25714",
      "mergeCommit": {
        "oid": "b33c43a8b751643962e3d12c441f4baa0d7c1776"
      }
    },
    {
      "number": 167,
      "id": "MDExOlB1bGxSZXF1ZXN0MjkzOTkzNDAx",
      "title": "Add note about cleartext OCSP.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/167",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #156.",
      "createdAt": "2019-07-03T04:05:10Z",
      "updatedAt": "2019-07-04T01:12:54Z",
      "closedAt": "2019-07-04T01:12:54Z",
      "mergedAt": "2019-07-04T01:12:54Z",
      "mergedBy": "chris-wood",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU3MjUyNzkz",
          "commit": {
            "abbreviatedOid": "33af345"
          },
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-07-03T04:15:27Z",
          "updatedAt": "2019-07-03T04:18:52Z",
          "comments": [
            {
              "originalPosition": 85,
              "body": "The PR looks good to me.\r\n\r\nThat said, it might be to a good idea to say something like \"prohibit generating OCSP traffic, especially in cleartext\", as using an encrypted channel to the OCSP responder could still be an issue in sense that it leaks the IP address of the responder (or because use of OCSP is an act of leaking information to the OCSP responder).",
              "createdAt": "2019-07-03T04:15:28Z",
              "updatedAt": "2019-07-03T20:46:13Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU3MjU0Mzcy",
          "commit": {
            "abbreviatedOid": "33af345"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-03T04:24:37Z",
          "updatedAt": "2019-07-03T04:24:40Z",
          "comments": [
            {
              "originalPosition": 85,
              "body": "OCSP or CRL.\r\n\r\nI think that this needs to be framed differently.  The point here is that OCSP (or CRL checks) can leak the name.  But the reaction I would encourage is OCSP stapling, not \"don't do OCSP\" as this would appear to advocate for.",
              "createdAt": "2019-07-03T04:24:37Z",
              "updatedAt": "2019-07-03T20:46:13Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU3MjU1NjYw",
          "commit": {
            "abbreviatedOid": "33af345"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-03T04:32:07Z",
          "updatedAt": "2019-07-03T04:32:07Z",
          "comments": [
            {
              "originalPosition": 85,
              "body": "Perhaps requiring stapling with a SHOULD is fine? (It seems fine to me, at least.)",
              "createdAt": "2019-07-03T04:32:07Z",
              "updatedAt": "2019-07-03T20:46:13Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU3MjczNDg5",
          "commit": {
            "abbreviatedOid": "544ba89"
          },
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Thank you for the changes. LGTM.",
          "createdAt": "2019-07-03T06:00:10Z",
          "updatedAt": "2019-07-03T06:00:10Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU3NTkzMTIw",
          "commit": {
            "abbreviatedOid": "544ba89"
          },
          "author": "sleevi",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-03T16:05:43Z",
          "updatedAt": "2019-07-03T16:05:44Z",
          "comments": [
            {
              "originalPosition": 88,
              "body": "For a security considerations, it's probably better to spell this out more generically, because there are other ways in the verification stack to leak information. The most obvious omission here is AIA fetching, but it also relates to other proposals, such as Gossip or SCT verification proposals related to Certificate Transparency, or bespoke vendor solutions such as custom revocation information sources or on-the-fly downloading of CA information.\r\n\r\n```\r\nESNI requires encrypted DNS to be an effective privacy protection mechanism.\r\nHowever, verifying the server's identity from the Certificate message, particularly\r\nwhen using the X509 CertificateType, may result in additional network traffic\r\nthat may reveal the server identity. Examples of this traffic may include requests\r\nfor revocation information, such as OCSP or CRL traffic, or requests for repository\r\ninformation, such as authorityInformationAccess. It may also include\r\nimplementation-specific traffic for additional information sources as part of\r\nverification.\r\n\r\nImplementations SHOULD avoid leaking information that may identify the\r\nserver. Even when sent over an encrypted transport, such requests may result\r\nin indirect exposure of the server's identity, such as indicating a specific CA\r\nor service being used. To mitigate this risk, servers SHOULD deliver such\r\ninformation in-band when possible, such as through the use of OCSP stapling,\r\nand clients SHOULD take steps to minimize or protect such requests during\r\ncertificate validation.\r\n```",
              "createdAt": "2019-07-03T16:05:44Z",
              "updatedAt": "2019-07-03T20:46:13Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU3NzIxMjIw",
          "commit": {
            "abbreviatedOid": "544ba89"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-03T20:32:29Z",
          "updatedAt": "2019-07-03T20:32:30Z",
          "comments": [
            {
              "originalPosition": 88,
              "body": "Generalizing this is a great idea, and your suggested text looks good. I'll use it. ",
              "createdAt": "2019-07-03T20:32:30Z",
              "updatedAt": "2019-07-03T20:46:13Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU3NzI3MDI3",
          "commit": {
            "abbreviatedOid": "f09381d"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-03T20:46:18Z",
          "updatedAt": "2019-07-03T20:46:19Z",
          "comments": [
            {
              "originalPosition": 88,
              "body": "@sleevi -- updated. Thanks!",
              "createdAt": "2019-07-03T20:46:19Z",
              "updatedAt": "2019-07-03T20:46:19Z"
            }
          ]
        }
      ],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "22e62139a983958708e4fb6f3cf0d5043b54375c",
      "headRepository": "tlswg/draft-ietf-tls-esni",
      "headRefName": "caw/ocsp",
      "headRefOid": "f09381dd10831296a8f7a155eb0dc11d912664b0",
      "mergeCommit": {
        "oid": "cb1c91658944a23938b51d4cd420ddb5a33f186b"
      }
    },
    {
      "number": 168,
      "id": "MDExOlB1bGxSZXF1ZXN0Mjk0MzI0MzMy",
      "title": "Clarify server HRR behavior, and add label-based workaround for nonce-reuse",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/168",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Since the client's ESNI key share doesn't change across CHs in response to a HRR, the same AEAD IV would be used to encrypt/decrypt two different messages. This is an attempt to fix that, while also specifying the server-side HRR behavior. (Basically, check that the ESNI contents have not changed.)",
      "createdAt": "2019-07-03T20:47:58Z",
      "updatedAt": "2019-07-08T21:55:51Z",
      "closedAt": "2019-07-08T21:55:51Z",
      "mergedAt": "2019-07-08T21:55:51Z",
      "mergedBy": "chris-wood",
      "comments": [
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "Nice catch, Would it make more sense to instead use the KeyShare as a salt in the HKDF?",
          "createdAt": "2019-07-04T16:12:39Z",
          "updatedAt": "2019-07-04T16:12:39Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Or you could include the handshake transcript up to, but not including, the ClientHello.  That is the empty string before HRR< but something else after.",
          "createdAt": "2019-07-08T00:24:10Z",
          "updatedAt": "2019-07-08T00:24:10Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Nice catch, Would it make more sense to instead use the KeyShare as a salt in the HKDF?\r\n\r\nThat is a little iffy with cookie-only HelloRetryRequests. Those don't change the ClientHello key shares list, so the client would derive the same key + nonce pair. The client would also use the same plaintext so it's fine, but it seems an unnecessarily fragility.",
          "createdAt": "2019-07-08T16:08:01Z",
          "updatedAt": "2019-07-08T16:08:01Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "Agreed. I think I prefer the \"new DH\" version.",
          "createdAt": "2019-07-08T16:09:58Z",
          "updatedAt": "2019-07-08T16:09:58Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU3ODI4NzEx",
          "commit": {
            "abbreviatedOid": "21c2dbe"
          },
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-04T05:03:18Z",
          "updatedAt": "2019-07-04T05:03:18Z",
          "comments": [
            {
              "originalPosition": 124,
              "body": "I agree that servers MUST verify the value of the ESNI extension, but the fields being required to be validated seems to differ from the the fields that are required to be consistent. Is there a reason for the two to be different?\r\n\r\nFWIW, \"Handling the server response\" section states as follows:\r\n> If the server sends a HelloRetryRequest in response to the ClientHello and the client can send a second updated ClientHello per the rules in {{RFC8446}}, the \"encrypted_server_name\" extension values which do not depend on the (possibly updated) KeyShareClientHello, i.e,, ClientEncryptedSNI.suite, ClientEncryptedSNI.key_share, and ClientEncryptedSNI.record_digest, MUST NOT change across ClientHello messages. Moreover, ClientESNIInner.nonce and ClientESNIInner.realSNI MUST not change across ClientHello messages. Informally, the values of all unencrypted extension information, as well as the inner extension plaintext, must be consistent between the first and second ClientHello messages.",
              "createdAt": "2019-07-04T05:03:18Z",
              "updatedAt": "2019-07-08T20:58:59Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU4MDY5MTcy",
          "commit": {
            "abbreviatedOid": "7ae2f15"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-04T14:17:36Z",
          "updatedAt": "2019-07-04T14:17:36Z",
          "comments": [
            {
              "originalPosition": 124,
              "body": "No reason -- just an oversight on my part. It should be fixed now!",
              "createdAt": "2019-07-04T14:17:36Z",
              "updatedAt": "2019-07-08T20:58:59Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU4MDcxMzQx",
          "commit": {
            "abbreviatedOid": "7ae2f15"
          },
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Thank you for the changes! LGTM.",
          "createdAt": "2019-07-04T14:22:07Z",
          "updatedAt": "2019-07-04T14:22:07Z",
          "comments": []
        }
      ],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "4ec4cb4ee196a4cec35fdce9640bf86cc559bc2a",
      "headRepository": "tlswg/draft-ietf-tls-esni",
      "headRefName": "caw/hrr",
      "headRefOid": "ccb5b563caea6f84aa4c27c71bacb13836d7a8b0",
      "mergeCommit": {
        "oid": "393aa3301cda28b0d27e486ad595434d4b39a946"
      }
    },
    {
      "number": 169,
      "id": "MDExOlB1bGxSZXF1ZXN0Mjk0NzI5NTA3",
      "title": "Add note about SNI-only encryption key design.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/169",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Addresses #41.",
      "createdAt": "2019-07-05T04:24:05Z",
      "updatedAt": "2019-07-08T13:45:26Z",
      "closedAt": "2019-07-08T13:45:25Z",
      "mergedAt": "2019-07-08T13:45:25Z",
      "mergedBy": "ekr",
      "comments": [],
      "reviews": [],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "cb1c91658944a23938b51d4cd420ddb5a33f186b",
      "headRepository": "tlswg/draft-ietf-tls-esni",
      "headRefName": "caw/alpn-note",
      "headRefOid": "0e51ecd9e9634fafd6d16127f0a889addc8e6af5",
      "mergeCommit": {
        "oid": "342840b5430948ffe709f5d665d63859edee2f67"
      }
    },
    {
      "number": 170,
      "id": "MDExOlB1bGxSZXF1ZXN0Mjk0NzMxMDE2",
      "title": "Drop fixed key_share requirement to avoid nonce reuse and better align with HPKE",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/170",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This is an alternative to #168, wherein we use fresh DH keys each time and avoid changing the key/iv derivation labels across CH messages.",
      "createdAt": "2019-07-05T04:33:31Z",
      "updatedAt": "2019-10-11T17:43:30Z",
      "closedAt": "2019-10-11T17:43:30Z",
      "mergedAt": null,
      "mergedBy": null,
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Ping @ekr @kazuho ",
          "createdAt": "2019-07-06T22:02:48Z",
          "updatedAt": "2019-07-06T22:02:48Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "IIUC, this is a trade-off issue. Therefore I do not have a strong preference, though my weak prerefence goes to keeping the design as-is. The reasons are as follows.\r\n\r\nThe benefit of the proposed change is that it frees client from buffering the content of the ESNI extension (after encryption), when using a building block that does not support reusing the same public key pair. Though, we might argue that even with this change, clients might still want to buffer the extension for possible retransmission rather than doing another public key operation in case of receiving a HRR.\r\n\r\nThe downside of the proposed change is that it might require the server to do another public key operation when verifying the ESNI extension found in ClientHello being sent in response to HelloRetryRequest. Current design, by requiring the keys to be identical, allows a server to validate the indifference of the ESNI extension without actually deciphering the payload.\r\n\r\nOne of the role of HRR is to mitigate attacks. When under attack, I believe that servers would be reluctant to do an additional public key operation. Therefore, to me it seems that the proposed change would incentivize the server to skip the verification of the ESNI extension sent in response to HRR.\r\n\r\nComparing the benefit and the downside, my weak preference goes to retaining the design as-is, because as I stated, I think that clients would be (mostly) fine with the design, and under the assumption that it is beneficial to encourage servers to validate the ESNI extension sent in response to HRR.",
          "createdAt": "2019-07-07T06:04:36Z",
          "updatedAt": "2019-07-07T06:18:50Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I share @kazuho's concerns.  The use of a different label after HRR is annoying, but not that difficult to manage.  You could also include the session transcript up to (but not including) the ClientHello, but you need something.\r\n\r\nFlipping the shares is a costly exercise.  You might have to do it anyway, but if you don't, then you can save some computation.  I can definitely see the value in stuffing the decrypted SNI into the cookie so that you don't have to redo the ESNI piece.",
          "createdAt": "2019-07-07T23:35:23Z",
          "updatedAt": "2019-07-07T23:35:23Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "The benefit of this approach is primarily simplicity for clients and HPKE alignment. (HPKE generates a fresh key each time, so we couldn\u2019t adopt it as is unless that draft changed.) I agree that the cost of yet another DH operation is not great, though I\u2019m not yet convinced it\u2019s enough to disqualify this change.",
          "createdAt": "2019-07-07T23:46:03Z",
          "updatedAt": "2019-07-07T23:46:03Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "Hmm... I'm not sure I follow all of this.\r\n\r\nYou can't store the decrypted SNI in the cookie because you need to re-verify the AEAD which is tied to the new key share. You can of course stuff Z in the cookie, though, so I'm not sure how much difference this makes. With that said, in the common case (one server) you are going to have a uniform config so you don't need to decrypt ESNI at all in order to send HRR, no?\r\n\r\nAs @chris-wood says  this is tied to using HPKE -- if we decide to do that, we are going to either have to adopt a \"fresh DH\" version or extend the HPKE API to have some sort of key reuse + salt.\r\n\r\n\r\n\r\n\r\n",
          "createdAt": "2019-07-07T23:46:48Z",
          "updatedAt": "2019-07-07T23:47:10Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "@chris-wood \r\n> The benefit of this approach is primarily simplicity for clients and HPKE alignment. (HPKE generates a fresh key each time, so we couldn\u2019t adopt it as is unless that draft changed.)\r\n\r\nI think our disagreement is if current provision deters the adoption of HPKE.\r\n\r\nI'm not familiar with HPKE and I could be wrong, but it is my understanding that the current design can use a public key crypto engine that uses a fresh key for every operation.\r\n\r\nThat is because the ESNI extension sent in the 2nd ClientHello is a \"retransmission.\" Server's public key pair does not change, and ClientHello.random does not change. Therefore, when sending the first ClientHello, a client can just keep the encrypted payload of ESNI extension. Then, when it receives a HelloRetryRequest, it would retransmit the buffered payload of the ESNI extension.",
          "createdAt": "2019-07-07T23:57:56Z",
          "updatedAt": "2019-07-07T23:57:56Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "@kazuho: I don't believe that this will work because the client's KeyShare will likely change in HRR, and it is AAD to the ESNI Extension, thus the ciphertext will change. Or am I confused?",
          "createdAt": "2019-07-08T00:02:59Z",
          "updatedAt": "2019-07-08T00:02:59Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "@ekr Ah I missed that (and picotls has a bug!). Thank you for pointing that out.\r\n\r\nThat said, I think that the @martinthomson's argument (which was also the rest of my argument) still holds. If we want servers to verify the ESNI extension sent in the 2nd ClientHello, it is benefical to require the clients to use the same public key.\r\n\r\nBecause, then, a server can retain the key and iv (either in it's state or in Cookie), and just do the AEAD operation to validate the ESNI extension found in the 2nd ClientHello. If we think that such check can be avoided (even though we would not encourage that), I think I'd be fine with allowing the client to change the public key.",
          "createdAt": "2019-07-08T00:09:26Z",
          "updatedAt": "2019-07-08T00:09:26Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "@kazuho nitpicking: you will need to retain Z, I think.\r\n\r\nWith that said, how do you think we would handle the transition to HPKE?",
          "createdAt": "2019-07-08T00:17:10Z",
          "updatedAt": "2019-07-08T00:17:10Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@kazuho @grittygrease how do you want to proceed here?",
          "createdAt": "2019-07-08T17:29:57Z",
          "updatedAt": "2019-07-08T17:29:57Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "(This comment ended up long, so I'm splitting it into sections.)\r\n\r\n**Why check the second ClientHello**\r\n\r\n> If we think that such check can be avoided (even though we would not encourage that), I think I'd be fine with allowing the client to change the public key.\r\n\r\nIf the server does not check the second ClientHello, then cut-and-paste attacks are possible against client/server pairs which hit HelloRetryRequest because we lose the binding between ESNI and the key shares that were actually used. (It really would be cleaner if we just stuffed something into the key schedule, but then the client needs to trial-decrypt or we need a cleartext \"yes, I used ESNI\" signal.)\r\n\r\nFor completeness, deployments which allow different services to have different version, cipher, or group preferences need to process ESNI on the first ClientHello because resolving HRR requires those preferences. Of course, services with different preferences will partition the anonymity sets a little bit, but enough deployments expect to be able to vary TLS parameters this way that I think we need to allow for this. (BoringSSL, for instance, resolves SNI on the first ClientHello.)\r\n\r\n**Split mode**\r\n\r\nOn that note, split mode and HRR are a little messy. Possibilities I can see:\r\n\r\n1. Dispatch happens at second ClientHello. Frontend and backend must agree on HRR-sensitive parameters, and backend gets a handshake transcript from the frontend.\r\n2. Dispatch happens at first ClientHello, but frontend and backend agree on enough of TLS parameters that frontend can sniff HelloRetryRequest + second ClientHello (technically a [protocol invariant](https://tools.ietf.org/html/rfc8446#section-9.3) violation) to check the ESNI.\r\n3. Backend and frontend both have ESNI keys. This contradicts #169.\r\n\r\n**Near-attack**\r\n\r\nFinally, I think there's one more issue here with changing the key share which, while not fatal, is rather a headache. Suppose we went with this PR. Here is a near-attack:\r\n\r\n1. Attacker observes an ESNI-ful HRR-ful connection. Let CH1 and CH2 be the first and second ClientHellos.\r\n2. Attacker wants to determine if CH1/CH2's ESNI contained hostname H. (It can repeat this process with different guesses.)\r\n3. Attacker makes a connection to the server. It replays CH1 and gets an HRR.\r\n4. Attacker sends its own second ClientHello with its own key shares and an ESNI record containing H.\r\n5. If H matched CH1's ESNI, the server will accept the connection and continue. If it mismatched, the server will fail with an alert.\r\n\r\nThis is only a near-attack because ClientESNIInner contains a nonce the attacker cannot guess, so even if it matched the hostname, it cannot match the nonce. But this means the server must perform the comparison in constant-time (attacker can repeat steps 3-5 all it wants) and the nonce is even more load-bearing in a subtle way.\r\n\r\nExample of subtlety: In both \"server must check CH2\" PRs, it is easy for the server to ignore it and no one notices. One could imagine saying the ESNI nonce must change in CH2, so the server *at least* doesn't ignore it. But that would turn this near-attack into an actual attack. Whereas I believe the same-key version avoids all of this.\r\n\r\n**Changing the key schedule**\r\n\r\nIt seems we're in this mess because we've bound ESNI to the handshake in a roundabout way rather than injecting the key into the key schedule. I believe this originally was to aid split mode, but we've since added this nonce anyway, so having frontend pass the key schedule addition into the backend is plausible. Perhaps this is worth reconsidering? Some thoughts:\r\n\r\nFirst, there isn't a slot in the key schedule for this. I think that's fine though, as long as we change the label. Here's one possibility:\r\n\r\n```\r\n             0\r\n             |\r\n             v\r\n   PSK ->  HKDF-Extract = Early Secret\r\n             |\r\n             +-----> Derive-Secret(...)\r\n             |                     = binder_key\r\n             |                     = client_early_traffic_secret\r\n             |                     = early_exporter_master_secret\r\n             v\r\n       Derive-Secret(., \"derived\", \"\")\r\n             |\r\n             v\r\n   (EC)DHE -> HKDF-Extract\r\n             |\r\n             v\r\n       Derive-Secret(., \"esni nonce\", \"\")\r\n             |\r\n             v\r\nESNI nonce -> HKDF-Extract = Handshake Secret\r\n             |\r\n             +-----> Derive-Secret(...)\r\n             |                     = client_handshake_traffic_secret\r\n             |                     = server_handshake_traffic_secret\r\n             v\r\n            ...\r\n ```\r\n(Arguably all the \"derived\" labels should have had names.)\r\n\r\nThe second issue is how to signal it on the client. I see two options:\r\n\r\n1. Cleartext signal in ServerHello. This violates \"do not stick out\" and makes the GREASE extensions totally useless.\r\n2. The client computes both server_handshake_traffic_secret values and trial-decrypts to figure out which one to use. This is trial decryption and non-destructive trial-decryption at that, so it's rather a headache. (On the plus side, it only needs to be done on the first handshake record.)\r\n\r\nNeither of these is very satisfactory but, then again, nor are our other two options. :-/\r\n\r\n**Conclusion**\r\n\r\nEverything is a mess.",
          "createdAt": "2019-07-08T20:38:58Z",
          "updatedAt": "2019-07-08T20:38:58Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "@chris-wood \r\n> how do you want to proceed here?\r\n\r\nAs we do not have time, I think we should merge #168 (it does not change the client behavior, and I think we agree that requiring the server to validate the ESNI extension found in 2nd CH is a good idea), while keeping this PR open for further discussion.",
          "createdAt": "2019-07-08T21:53:20Z",
          "updatedAt": "2019-07-08T21:53:20Z"
        }
      ],
      "reviews": [],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "cb1c91658944a23938b51d4cd420ddb5a33f186b",
      "headRepository": "tlswg/draft-ietf-tls-esni",
      "headRefName": "caw/hrr-fresh-esni-key",
      "headRefOid": "8cf067d5ab8bd7d5621e50aa6991c6c6e4a94552",
      "mergeCommit": null
    },
    {
      "number": 172,
      "id": "MDExOlB1bGxSZXF1ZXN0Mjk5NTc4MDQ0",
      "title": "Fix typo in text for ClientEncryptedSNI.key_share",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/172",
      "state": "MERGED",
      "author": "dmcardle",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2019-07-20T17:11:49Z",
      "updatedAt": "2019-07-23T19:43:24Z",
      "closedAt": "2019-07-23T19:43:24Z",
      "mergedAt": "2019-07-23T19:43:24Z",
      "mergedBy": "chris-wood",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Thank you!",
          "createdAt": "2019-07-23T19:43:18Z",
          "updatedAt": "2019-07-23T19:43:18Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjY1NjM0Mzcw",
          "commit": {
            "abbreviatedOid": "112f9db"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-07-23T19:43:11Z",
          "updatedAt": "2019-07-23T19:43:11Z",
          "comments": []
        }
      ],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "393aa3301cda28b0d27e486ad595434d4b39a946",
      "headRepository": "dmcardle/draft-ietf-tls-esni",
      "headRefName": "master",
      "headRefOid": "112f9db180f50c7f95ef6af40f1f95aecdf692cb",
      "mergeCommit": {
        "oid": "ddf3111a618bcda8791ced99aa7c87a90f165165"
      }
    },
    {
      "number": 174,
      "id": "MDExOlB1bGxSZXF1ZXN0MzAwMDg0NTI2",
      "title": "Remove `sni` reference from padded server name list",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/174",
      "state": "MERGED",
      "author": "mrsylerpowers",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "#173 ",
      "createdAt": "2019-07-23T00:18:57Z",
      "updatedAt": "2019-07-23T19:42:54Z",
      "closedAt": "2019-07-23T19:42:54Z",
      "mergedAt": "2019-07-23T19:42:54Z",
      "mergedBy": "chris-wood",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjY1NjMzNjAy",
          "commit": {
            "abbreviatedOid": "971f231"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-07-23T19:41:46Z",
          "updatedAt": "2019-07-23T19:41:46Z",
          "comments": []
        }
      ],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "393aa3301cda28b0d27e486ad595434d4b39a946",
      "headRepository": "mrsylerpowers/draft-ietf-tls-esni",
      "headRefName": "sni-reference-remove",
      "headRefOid": "971f2318b74f06164fb3bd11ec84815d474896c2",
      "mergeCommit": {
        "oid": "aed9ec47295529ab9188a1deb6230175fcba912d"
      }
    },
    {
      "number": 175,
      "id": "MDExOlB1bGxSZXF1ZXN0MzAwMTA3MTU3",
      "title": "refer GREASE extension in resolution algorithm & formatting fix",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/175",
      "state": "CLOSED",
      "author": "gsamat",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "I referred GREASE extensions in 4.2.2 Resolution algorithm to make it in line with 5.1.4. GREASE extensions\r\n\r\nalso fixed 4.2.2. Resolution algorithm formatting issue: line width > 72 resulted in ugly PDF",
      "createdAt": "2019-07-23T02:45:29Z",
      "updatedAt": "2019-11-04T20:36:07Z",
      "closedAt": "2019-11-04T20:36:06Z",
      "mergedAt": null,
      "mergedBy": null,
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "This PR no longer applies since this section of the document was removed.",
          "createdAt": "2019-11-04T20:36:06Z",
          "updatedAt": "2019-11-04T20:36:06Z"
        }
      ],
      "reviews": [],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "393aa3301cda28b0d27e486ad595434d4b39a946",
      "headRepository": "gsamat/draft-ietf-tls-esni",
      "headRefName": "patch-4",
      "headRefOid": "6c2c02346626ea88ee36f84018ac4e603b9f6202",
      "mergeCommit": null
    },
    {
      "number": 176,
      "id": "MDExOlB1bGxSZXF1ZXN0MzAwNzQzNTc0",
      "title": "Clarify that ESNIContents is not transmitted",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/176",
      "state": "MERGED",
      "author": "dmcardle",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "I got a little tripped up on this point! Maybe you have a better way to explain it.",
      "createdAt": "2019-07-24T14:11:10Z",
      "updatedAt": "2019-10-25T17:57:20Z",
      "closedAt": "2019-10-25T17:57:20Z",
      "mergedAt": "2019-10-25T17:57:20Z",
      "mergedBy": "chris-wood",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks, @dmcardle!",
          "createdAt": "2019-10-25T17:57:15Z",
          "updatedAt": "2019-10-25T17:57:15Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA3MzYyNzQ5",
          "commit": {
            "abbreviatedOid": "483ca96"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-10-25T17:57:07Z",
          "updatedAt": "2019-10-25T17:57:07Z",
          "comments": []
        }
      ],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "ddf3111a618bcda8791ced99aa7c87a90f165165",
      "headRepository": "dmcardle/draft-ietf-tls-esni",
      "headRefName": "dmcardlebranch",
      "headRefOid": "483ca96533d05ce9c05f1a7ada5c91adde8946ed",
      "mergeCommit": {
        "oid": "6ade68ed92984b283ddf1b0834e452431688c903"
      }
    },
    {
      "number": 181,
      "id": "MDExOlB1bGxSZXF1ZXN0MzA1ODA0MTEy",
      "title": "editorial nits",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/181",
      "state": "MERGED",
      "author": "kazuho",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Credits to @huitema.",
      "createdAt": "2019-08-09T01:34:27Z",
      "updatedAt": "2019-08-09T17:40:40Z",
      "closedAt": "2019-08-09T17:40:40Z",
      "mergedAt": "2019-08-09T17:40:39Z",
      "mergedBy": "chris-wood",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjcyOTE1Njk5",
          "commit": {
            "abbreviatedOid": "a1da8a7"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-08-09T02:02:13Z",
          "updatedAt": "2019-08-09T02:02:17Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "```suggestion\r\nindication would divulge the true server name.\r\n```",
              "createdAt": "2019-08-09T02:02:14Z",
              "updatedAt": "2019-08-09T03:33:53Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjczMjczNjUz",
          "commit": {
            "abbreviatedOid": "e2eb0d8"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-08-09T17:40:32Z",
          "updatedAt": "2019-08-09T17:40:32Z",
          "comments": []
        }
      ],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "ddf3111a618bcda8791ced99aa7c87a90f165165",
      "headRepository": "kazuho/draft-rescorla-tls-esni",
      "headRefName": "kazuho/editorial",
      "headRefOid": "e2eb0d8b0e1d8febafe4b84d9f7f9ffd4cca5406",
      "mergeCommit": {
        "oid": "9e54d3572c171a65e522a3a045907282a046843e"
      }
    },
    {
      "number": 184,
      "id": "MDExOlB1bGxSZXF1ZXN0MzI2NzI5MDAx",
      "title": "Add description about \"cipher suites\" via an ESNIKeys extension",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/184",
      "state": "MERGED",
      "author": "pengin7384",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Add missing description for cipher_suites and add colon symbol to padded_length",
      "createdAt": "2019-10-10T13:12:22Z",
      "updatedAt": "2020-02-23T13:51:59Z",
      "closedAt": "2020-02-23T13:51:59Z",
      "mergedAt": "2020-02-23T13:51:59Z",
      "mergedBy": "chris-wood",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYzMDk2Mzcx",
          "commit": {
            "abbreviatedOid": "8a9cace"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-02-23T13:51:54Z",
          "updatedAt": "2020-02-23T13:51:54Z",
          "comments": []
        }
      ],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "9e54d3572c171a65e522a3a045907282a046843e",
      "headRepository": "pengin7384/draft-ietf-tls-esni",
      "headRefName": "encrypted-sni-record-patch",
      "headRefOid": "8a9cacebaf6910688743d794ef8469e3679c08b6",
      "mergeCommit": {
        "oid": "80df23129af22ea6846b7f2dfe1efe2e371892d0"
      }
    },
    {
      "number": 185,
      "id": "MDExOlB1bGxSZXF1ZXN0MzI4ODk3MzAw",
      "title": "Remove partial split mode",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/185",
      "state": "MERGED",
      "author": "bemasc",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Based on comments in Montreal, I believe that the authors\r\nno longer intend to document the partial-split configuration.",
      "createdAt": "2019-10-16T18:30:25Z",
      "updatedAt": "2019-10-25T19:01:36Z",
      "closedAt": "2019-10-25T19:01:36Z",
      "mergedAt": "2019-10-25T19:01:36Z",
      "mergedBy": "chris-wood",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA3MzY0MjAz",
          "commit": {
            "abbreviatedOid": "8e7113d"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2019-10-25T17:59:47Z",
          "updatedAt": "2019-10-25T17:59:57Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "Is this always true? Might the provider have access in shared mode?",
              "createdAt": "2019-10-25T17:59:47Z",
              "updatedAt": "2019-10-25T17:59:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA3Mzk0ODkz",
          "commit": {
            "abbreviatedOid": "8e7113d"
          },
          "author": "bemasc",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-25T19:00:03Z",
          "updatedAt": "2019-10-25T19:00:04Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "This paragraph is only about split mode (and this sentence is unchanged).",
              "createdAt": "2019-10-25T19:00:03Z",
              "updatedAt": "2019-10-25T19:00:04Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA3Mzk1NTc4",
          "commit": {
            "abbreviatedOid": "8e7113d"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-25T19:01:25Z",
          "updatedAt": "2019-10-25T19:01:26Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "Oh, hah, yes. That\u2019s what I get for skimming. ",
              "createdAt": "2019-10-25T19:01:25Z",
              "updatedAt": "2019-10-25T19:01:26Z"
            }
          ]
        }
      ],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "9e54d3572c171a65e522a3a045907282a046843e",
      "headRepository": "bemasc/draft-ietf-tls-esni",
      "headRefName": "bemasc-partial-split",
      "headRefOid": "8e7113d0204805c3e29cc1ef84e9fa041457ecd5",
      "mergeCommit": {
        "oid": "5abba83633afe4dc15e57a976dcd93be5119447b"
      }
    },
    {
      "number": 186,
      "id": "MDExOlB1bGxSZXF1ZXN0MzMxNjI3MjA3",
      "title": "Proposal: Use a hash instead of padding",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/186",
      "state": "CLOSED",
      "author": "bemasc",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This is (almost) entirely compatible with wildcard names\r\nand avoids the need for padding.",
      "createdAt": "2019-10-23T16:05:42Z",
      "updatedAt": "2019-10-23T20:22:36Z",
      "closedAt": "2019-10-23T20:22:35Z",
      "mergedAt": null,
      "mergedBy": null,
      "comments": [
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I do not think this change is worth the complexity. First, it does not avoid the need for padding. The server certificate needs to be padded regardless, so the server already needs to make decisions based on the length distributions of known hostnames.\r\n\r\nSecond, it dramatically increases the complexity of deploying ESNI. In the existing design, the actual certificate lookup on the server is relatively unchanged. The TLS library could even abstract much of the name lookup, public name fallback, etc., from the application by simply passing the name along the same interface as before and leave that portion unchanged. This design forces the server to have a new digest-based path, which extends throughout the entire configuration pipeline.\r\n\r\nThe `label_limit` notion for dealing with wildcards is also another source of stateful deployment problems with configuration mismatches. Perhaps I used to use a wildcard cert, but now I'd like to switch to individual subdomains. This transition is difficult under this PR. For more fun, the folks managing the names may be different from the folks who implemented ESNI, so the deployment concern will go unnoticed.\r\n\r\nThe wildcard cert scheme is also messy with protocols that do not have their own in-band vhosting mechanism and just use TLS. HTTP doesn't care about HTTP has a Host header, so it doesn't actually care about the SNI. (I will observe, however, that the Host header should probably trigger padding too, so we're still back to square one. :-) )",
          "createdAt": "2019-10-23T16:42:59Z",
          "updatedAt": "2019-10-23T16:42:59Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yep, deployment is more complex in this mode.  I'm going to close this to avoid creating ongoing confusion; I just wanted to remind people that there are other options beyond debates about padding length, and we shouldn't be too quick to adopt a leaky padding scheme for the sake of handshake size.",
          "createdAt": "2019-10-23T20:22:35Z",
          "updatedAt": "2019-10-23T20:22:35Z"
        }
      ],
      "reviews": [],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "9e54d3572c171a65e522a3a045907282a046843e",
      "headRepository": "bemasc/draft-ietf-tls-esni",
      "headRefName": "bemasc-hash",
      "headRefOid": "33f2537c2c47ed2c2110ff840fc6f82fa2d3c048",
      "mergeCommit": null
    },
    {
      "number": 187,
      "id": "MDExOlB1bGxSZXF1ZXN0MzMyMjkyNDY4",
      "title": "Replace ESNIKeys with ESNIConfig, and delegate the publishing container to HTTPSVC.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/187",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "DNSOP adopted HTTPSSVC recently [1]. This is a generalized Resource Record that supports the same functionality as the custom ESNI RRType, including direct IP address specification and ENSI key delivery. This change drops the custom DNS bits from the ESNI document and delegates this to HTTPSSVC, where it probably belongs. This change also renames ESNIKeys to ESNIConfig to more accurately capture its intended purpose, i.e., as a struct for conveying ESNI keys and metadata.\r\n\r\nThis should address #180, #179, #139, and #110.\r\n\r\n[1] https://mailarchive.ietf.org/arch/msg/dnsop/9zCxhCfIhDzA3Cv3D2k4NF_nj4s",
      "createdAt": "2019-10-25T00:24:16Z",
      "updatedAt": "2019-11-02T01:01:45Z",
      "closedAt": "2019-11-02T01:01:45Z",
      "mergedAt": "2019-11-02T01:01:45Z",
      "mergedBy": "chris-wood",
      "comments": [
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm not sure that this is going to work with HTTPSSVC as currently defined. The current ESNIKeys record specifies the IP address explicitly and you are supposed to favor that. However, assuming I am reading HTTPSSVC S 6.4 correctly, ipv[46]hint are not in fact favored but are actually disfavored.\r\n\r\n  \"The \"ipv4hint\" and \"ipv6hint\" keys represent IP address hints for the\r\n   service.  If A and AAAA records for SvcDomainName are locally\r\n   available, the client SHOULD ignore these hints.  Otherwise, clients\r\n   MUST perform A and/or AAAA queries for SvcDomainName as in Section 3,\r\n   and clients SHOULD switch to an IP address in those records as soon\r\n   as possible.\"\r\n\r\nThis is counter to what we agreed upon for ESNI and resurrects the A/AAAA vs. ESNIKeys mismatch problem. \r\n\r\nUnless I am misunderstanding this, we should first fix HTTPSSVC before making this change.\r\n\r\n\r\n",
          "createdAt": "2019-10-25T16:34:42Z",
          "updatedAt": "2019-10-25T16:34:42Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think the intent with HTTPSSVC is that, if you're using the HTTPSSVC record, you'd look up A/AAAA from the SvcDomainName not the origin name you queried. That way there's still a binding between A/AAAA and ESNIKeys.\r\n\r\nThis does, however, cost an extra DNS round-trip, so this plan does require the recursive resolvers follow HTTPSSVC for you like they do CNAME, otherwise it would not meet the performance requirements. DoT/DoH are an ecosystem reset, so maybe that's plausible? I think this goes back to how sacred you believe A and AAAA are and whether you believe it's rude to get IP addresses elsewhere. The HTTPSSVC record evidently has different views on this point than the ESNI record.",
          "createdAt": "2019-10-25T17:16:52Z",
          "updatedAt": "2019-10-25T17:16:52Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> This is counter to what we agreed upon for ESNI and resurrects the A/AAAA vs. ESNIKeys mismatch problem.\r\n\r\nI would choose to interpret their \"SHOULD ignore\" advice as optional to ensure the ESNIRecord functionality is maintained. @bemasc, perhaps we can clarify this in the HTTPSVC draft?",
          "createdAt": "2019-10-25T17:20:52Z",
          "updatedAt": "2019-10-25T17:20:52Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> I think the intent with HTTPSSVC is that, if you're using the HTTPSSVC record, you'd look up A/AAAA from the SvcDomainName not the origin name you queried. That way there's still a binding between A/AAAA and ESNIKeys.\r\n\r\nYep, that's exactly right.\r\n\r\n> I would choose to interpret their \"SHOULD ignore\" advice as optional to ensure the ESNIRecord functionality is maintained.\r\n\r\nI'm not sure I understand you.  The purpose of \"SHOULD ignore\" is to ensure that DNS-based load balancing of A/AAAA on SvcDomainName continues to work correctly.  Whether the client uses an ipv6hint or a AAAA record for SvcDomainName, it will be contacting a server that has the corresponding ESNI private key; there's no possibility of mismatch either way.\r\n\r\n> perhaps we can clarify this in the HTTPSVC draft?\r\n\r\nI think the confusion here is that in HTTPSSVC, clients use the IP of SvcDomainName, not the IP of the origin hostname.  There's no way for a client to accidentally combine the ESNIConfig for the SvcDomainName with the IP of the origin hostname (or of a different SvcDomainName).\r\n\r\nI think the draft is pretty clear on this point (e.g. the [intro example](https://tools.ietf.org/html/draft-nygren-dnsop-svcb-httpssvc-00#section-1.1)), but the authors always think that :).  Suggestions are welcome.",
          "createdAt": "2019-10-25T17:49:56Z",
          "updatedAt": "2019-10-25T17:49:56Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "Well, so as @davidben points out, this requires a second resolution, which is a performance problem.",
          "createdAt": "2019-10-25T17:53:04Z",
          "updatedAt": "2019-10-25T17:53:04Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yes, waiting for a second resolution is the performance problem that ipv6hint solves, by giving the client an IP address along with the ESNIConfig in the same response.",
          "createdAt": "2019-10-25T18:13:19Z",
          "updatedAt": "2019-10-25T18:13:19Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "@bemasc: then I just don't see the point of doing the second resolution. It seems disruptive and doesn't add anything. Once I have connected to the server, it can Alt-Svc me itself.",
          "createdAt": "2019-10-25T18:25:43Z",
          "updatedAt": "2019-10-25T18:25:43Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "I should add, I'm not quite sure how I would implement this in Firefox. Say I resolve example.com and get 1.2.3.4 for ipv4 hints. Now I am supposed to in parallel connect to the server *and* try to resolve SvcDomainName? But what then? I've already started the connection so I'm not going to abort it if I get a 5.6.7.8....",
          "createdAt": "2019-10-25T18:35:51Z",
          "updatedAt": "2019-10-25T18:35:51Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> I just don't see the point of doing the second resolution. It seems disruptive and doesn't add anything.\r\n\r\nConsider a CDN customer with their own (old-fashioned, static) DNS.  The customer publishes an HTTPSSVC record whose SvcDomainName, ESNIConfig, and IP hint are the CDN's domain, ESNIConfig, and IP.  Clients connect to the IP from the hint, use this ESNIConfig, and everything works ... but the customer has broken the CDN's load balancing.  All of their traffic is going to a single  CDN IP.\r\n\r\nThe point of the second resolution is to move customer traffic onto the CDN's preferred IP.\r\n\r\n> Once I have connected to the server, it can Alt-Svc me itself.\r\n\r\nTrue, but HTTPSSVC doesn't require clients to support Alt-Svc.  (Chrome, for example, does not support this feature of Alt-Svc.)\r\n\r\n> Say I resolve example.com and get 1.2.3.4 for ipv4 hints. Now I am supposed to in parallel connect to the server and try to resolve SvcDomainName? But what then? I've already started the connection so I'm not going to abort it if I get a 5.6.7.8....\r\n\r\nThe draft says clients \"SHOULD switch to an IP address in those records as soon as possible\".  An aggressive implementation might start connecting to 5.6.7.8, and close the connection to 1.2.3.4 once it is connected.  (This is roughly what Chrome does for QUIC upgrade.)  A less aggressive implementation might just let the A record sit in the local DNS cache, so that any subsequent connections to this origin can go to the CDN's preferred IP.",
          "createdAt": "2019-10-25T18:49:33Z",
          "updatedAt": "2019-10-25T18:49:33Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "OK, so I think that this text needs a bunch of work before I would be comfortable with it, as I do not think your \"less aggressive implementation\" would be conformant with this SHOULD",
          "createdAt": "2019-10-25T18:51:03Z",
          "updatedAt": "2019-10-25T18:51:03Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@ekr if that\u2019s the case, can you please suggest concrete changes to the text?",
          "createdAt": "2019-10-25T18:56:15Z",
          "updatedAt": "2019-10-25T18:56:15Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "@bemasc is there some place I can send a PR?\n\nOn Fri, Oct 25, 2019 at 11:56 AM Christopher Wood <notifications@github.com>\nwrote:\n\n> @ekr <https://github.com/ekr> if that\u2019s the case, can you please suggest\n> concrete changes to the text?\n>\n> \u2014\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/tlswg/draft-ietf-tls-esni/pull/187?email_source=notifications&email_token=AAIPLIPSWDOAN7SHH24S3V3QQM6NBA5CNFSM4JE5AOYKYY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGOECJIAHA#issuecomment-546471964>,\n> or unsubscribe\n> <https://github.com/notifications/unsubscribe-auth/AAIPLINOF65ZGCXUMO47AOTQQM6NBANCNFSM4JE5AOYA>\n> .\n>\n",
          "createdAt": "2019-10-25T19:57:35Z",
          "updatedAt": "2019-10-25T19:57:35Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@ekr yes, https://github.com/MikeBishop/dns-alt-svc/pulls",
          "createdAt": "2019-10-25T20:17:25Z",
          "updatedAt": "2019-10-25T20:17:25Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "https://github.com/MikeBishop/dns-alt-svc/pull/69\n\nOn Fri, Oct 25, 2019 at 1:17 PM Benjamin M. Schwartz <\nnotifications@github.com> wrote:\n\n> @ekr <https://github.com/ekr> yes,\n> https://github.com/MikeBishop/dns-alt-svc/pulls\n>\n> \u2014\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/tlswg/draft-ietf-tls-esni/pull/187?email_source=notifications&email_token=AAIPLIIH2PM4BPFJCBSGKBTQQNH5PA5CNFSM4JE5AOYKYY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGOECJOJFY#issuecomment-546497687>,\n> or unsubscribe\n> <https://github.com/notifications/unsubscribe-auth/AAIPLIO5B7V7QND6ZZZB5MDQQNH5PANCNFSM4JE5AOYA>\n> .\n>\n",
          "createdAt": "2019-10-25T20:44:09Z",
          "updatedAt": "2019-10-25T20:44:09Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "OK, the new text has been merged, so I am now OK with this PR.\n\nOn Fri, Oct 25, 2019 at 1:43 PM Eric Rescorla <ekr@rtfm.com> wrote:\n\n> https://github.com/MikeBishop/dns-alt-svc/pull/69\n>\n> On Fri, Oct 25, 2019 at 1:17 PM Benjamin M. Schwartz <\n> notifications@github.com> wrote:\n>\n>> @ekr <https://github.com/ekr> yes,\n>> https://github.com/MikeBishop/dns-alt-svc/pulls\n>>\n>> \u2014\n>> You are receiving this because you were mentioned.\n>> Reply to this email directly, view it on GitHub\n>> <https://github.com/tlswg/draft-ietf-tls-esni/pull/187?email_source=notifications&email_token=AAIPLIIH2PM4BPFJCBSGKBTQQNH5PA5CNFSM4JE5AOYKYY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGOECJOJFY#issuecomment-546497687>,\n>> or unsubscribe\n>> <https://github.com/notifications/unsubscribe-auth/AAIPLIO5B7V7QND6ZZZB5MDQQNH5PANCNFSM4JE5AOYA>\n>> .\n>>\n>\n",
          "createdAt": "2019-10-25T21:07:46Z",
          "updatedAt": "2019-10-25T21:07:46Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA2OTYzODUy",
          "commit": {
            "abbreviatedOid": "2daa3df"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-25T03:14:11Z",
          "updatedAt": "2019-10-25T03:14:40Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "```suggestion\r\npublication details to {{!HTTPSSVC=I-D.nygren-dnsop-svcb-httpssvc}}, though other delivery\r\n```",
              "createdAt": "2019-10-25T03:14:11Z",
              "updatedAt": "2019-10-25T21:08:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA3MzQyMjA0",
          "commit": {
            "abbreviatedOid": "d0eaef9"
          },
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-25T17:18:04Z",
          "updatedAt": "2019-10-25T17:18:19Z",
          "comments": [
            {
              "originalPosition": 239,
              "body": "Nit: s/retry_keys/retry_configs/",
              "createdAt": "2019-10-25T17:18:05Z",
              "updatedAt": "2019-10-25T21:08:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA3MzQyNjg0",
          "commit": {
            "abbreviatedOid": "d0eaef9"
          },
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-25T17:19:02Z",
          "updatedAt": "2019-10-25T17:19:02Z",
          "comments": [
            {
              "originalPosition": 239,
              "body": "Benefit of the ESNIConfig rename: really `retry_keys` should have been `retry_keyses`, but now we don't have to pretend to be Gollum. :-)",
              "createdAt": "2019-10-25T17:19:02Z",
              "updatedAt": "2019-10-25T21:08:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA3NDI3MTk5",
          "commit": {
            "abbreviatedOid": "d0eaef9"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-10-25T20:09:00Z",
          "updatedAt": "2019-10-25T20:09:00Z",
          "comments": []
        }
      ],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "5abba83633afe4dc15e57a976dcd93be5119447b",
      "headRepository": "chris-wood/draft-ietf-tls-esni",
      "headRefName": "caw/httpsvc",
      "headRefOid": "160dd9085c9ec730c7845fa6d74836b1739a645f",
      "mergeCommit": {
        "oid": "6457893d8614fe47f3e8365957985ec848d754b0"
      }
    },
    {
      "number": 194,
      "id": "MDExOlB1bGxSZXF1ZXN0MzM2NDY4NzMz",
      "title": "Add note about inconsistent cryptographic configurations.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/194",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Addresses #178.",
      "createdAt": "2019-11-04T20:45:17Z",
      "updatedAt": "2019-11-04T21:40:59Z",
      "closedAt": "2019-11-04T21:40:59Z",
      "mergedAt": "2019-11-04T21:40:59Z",
      "mergedBy": "chris-wood",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzExMzU3OTg0",
          "commit": {
            "abbreviatedOid": "371cf44"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-11-04T21:06:12Z",
          "updatedAt": "2019-11-04T21:06:22Z",
          "comments": [
            {
              "originalPosition": 33,
              "body": "```suggestion\r\nthe contents of the ServerHello as this message is not encrypted.\r\n```  ",
              "createdAt": "2019-11-04T21:06:13Z",
              "updatedAt": "2019-11-04T21:07:29Z"
            }
          ]
        }
      ],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "6457893d8614fe47f3e8365957985ec848d754b0",
      "headRepository": "tlswg/draft-ietf-tls-esni",
      "headRefName": "caw/crypto-consistency",
      "headRefOid": "fdf6d5a3e259e555922dad7064d116965fee626f",
      "mergeCommit": {
        "oid": "8395959ed6e17e3b6b91aa132fbce93652ad2ef1"
      }
    },
    {
      "number": 195,
      "id": "MDExOlB1bGxSZXF1ZXN0MzM2NTEzNjg3",
      "title": "Clarify rules on order and repetition for ESNIConfig extensions",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/195",
      "state": "MERGED",
      "author": "dmcardle",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Followup on #183.\r\n\r\nLooks like ESNIConfig is the only ESNI structure that has extensions, now that we've delegated the key delivery to HTTPSSVC.\r\n\r\nShould I avoid reflowing the text?",
      "createdAt": "2019-11-04T22:38:32Z",
      "updatedAt": "2020-02-23T13:51:20Z",
      "closedAt": "2020-02-23T13:51:19Z",
      "mergedAt": "2020-02-23T13:51:19Z",
      "mergedBy": "chris-wood",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYzMDk2MzAy",
          "commit": {
            "abbreviatedOid": "fdc917f"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-02-23T13:51:01Z",
          "updatedAt": "2020-02-23T13:51:01Z",
          "comments": []
        }
      ],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "8395959ed6e17e3b6b91aa132fbce93652ad2ef1",
      "headRepository": "dmcardle/draft-ietf-tls-esni",
      "headRefName": "esniconfig-httpssvc-changes",
      "headRefOid": "fdc917ff8d9fb4d6a6c25062339adc444948bb48",
      "mergeCommit": {
        "oid": "9024e205e2b7f151c49882e49803f4486fa6d042"
      }
    },
    {
      "number": 196,
      "id": "MDExOlB1bGxSZXF1ZXN0MzM2OTIzOTM2",
      "title": "Tunnel version",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/196",
      "state": "CLOSED",
      "author": "ekr",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2019-11-05T18:29:17Z",
      "updatedAt": "2020-03-08T00:32:23Z",
      "closedAt": "2020-03-08T00:32:22Z",
      "mergedAt": null,
      "mergedBy": null,
      "comments": [
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I haven't looked at this in full detail yet, but one initial comment is that encrypting an entire ClientHello means doubling the size, and [post-quantum key shares](https://www.imperialviolet.org/2019/10/30/pqsivssl.html) are looking to be quite large. I believe [one of our experiments](https://www.imperialviolet.org/2018/04/11/pqconftls.html) suggested the additional cost is roughly linear to the number of bytes.\r\n\r\nWe could encrypt some sort of \"delta ClientHello\", either saying \"copy these extensions from the outside\" or something hilarious scheme where you specify a sequence of new bytes and references into your outer ClientHello... (I think the former is easier to send while the latter is easier to receive.)\r\n\r\nAnother thought, though it requires a side channel from frontend to backend, is the `ClientHelloInner` omits `key_shares` in favor of a new `key_shares_hashed` extension where you insert `SHA256(ClientHelloOuter.key_shares)` for transcript purposes. The receiver then asserts the hash matches and pretends you included `ClientHelloOuter.key_shares` in `ClientHelloInner` for handshake purposes.",
          "createdAt": "2019-11-05T23:43:29Z",
          "updatedAt": "2019-11-05T23:43:29Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "Yeah, one big drawback here is clearly the size, and yeah, PQ makes that worse.\r\n\r\nWith that said, it seems like you could potentially ameliorate this by only including classical KeyShares in ClientHelloOuter. The rationale here would be that the only purpose of ClientHelloOuter is to enable the fallback handshake, and so those keys are just protecting the SNI (and ESNIConfig, but that's just there to protect SNI), and we could potentially live with that being non-quantum-safe, especially if we're not going to use PQ algorithms for ESNI encryption. And of course if we *do* use PQ algorithms for ESNI encryption, then the overhead of the second CH is only about 1/2 as opposed to double.\r\n\r\n\r\n\r\n",
          "createdAt": "2019-11-05T23:48:47Z",
          "updatedAt": "2019-11-05T23:48:47Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Wouldn't that would negate the point of GREASE? ClientHellos advertising ESNI would have large ciphertext and classical-only outer key shares, while ClientHellos not advertising ESNI would include the PQ outer key shares (and probably send a small GREASE extension ton compensate).",
          "createdAt": "2019-11-06T00:00:05Z",
          "updatedAt": "2019-11-06T00:00:05Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "Yes, that's true. I think I'd be willing to live with that tradeoff but\nperhaps others would not.\n\nOn Tue, Nov 5, 2019 at 4:00 PM David Benjamin <notifications@github.com>\nwrote:\n\n> Wouldn't that would negate the point of GREASE? ClientHellos advertising\n> ESNI would have large ciphertext and classical-only outer key shares, while\n> ClientHellos not advertising ESNI would include the PQ outer key shares\n> (and probably send a small GREASE extension ton compensate).\n>\n> \u2014\n> You are receiving this because you authored the thread.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/tlswg/draft-ietf-tls-esni/pull/196?email_source=notifications&email_token=AAIPLIIXQ7PURA5TEIE2ETLQSICINA5CNFSM4JJGLDW2YY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGOEDEYQ7Y#issuecomment-550078591>,\n> or unsubscribe\n> <https://github.com/notifications/unsubscribe-auth/AAIPLIOIH23TNN2NC7ODZLLQSICINANCNFSM4JJGLDWQ>\n> .\n>\n",
          "createdAt": "2019-11-06T00:01:47Z",
          "updatedAt": "2019-11-06T00:01:47Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The size-doubling issue could be addressed through the use of compression.  If the inner and outer values are the same, then the inner could just reference the outer (and the removal of encryption could also include expansion).",
          "createdAt": "2019-11-06T00:52:48Z",
          "updatedAt": "2019-11-06T00:52:48Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "By compression (or reusing stuff), doesn't the proposal become closer to the ESNI transformation design that we have been talking in https://github.com/kazuho/draft-rescorla-tls-esni/pull/1?",
          "createdAt": "2019-11-06T01:50:01Z",
          "updatedAt": "2019-11-06T01:50:01Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@martinthomson Yeah, compression was what I was referring with \"delta ClientHello\". You could imagine a ClientHello-specific compression that knows how to toss extensions around (in which case, yeah, it starts getting closer to ESNI transformation), or some more generic delta encoding. Here's an ad hoc goofy thing:\r\n\r\n```\r\nenum { bytes(0), reference(1) } FragmentType;\r\n \r\nstruct {\r\n  uint24 offset;\r\n  uint24 length;\r\n} ReferenceFragment;\r\n \r\nopaque BytesFragment<1..2^24-1>;\r\n \r\nstruct {\r\n  FragmentType type;\r\n  select (Fragment.type) {\r\n    // Append these bytes.\r\n    case bytes: BytesFragment;\r\n    // Append the referenced fragment of the outer ClientHello.\r\n    case reference: ReferenceFragment;\r\n  }\r\n} Fragment;\r\n \r\nstruct {\r\n  // Included so preallocating the buffer and enforcing size limits is easy.\r\n  uint24 clienthello_length;\r\n  // Walk over all the fragments to reconstruct the ClientHello.\r\n  Fragment clienthello_fragments<0..2^24-1>;\r\n} ESNIPlaintext;\r\n```\r\n\r\nA ClientHello-specific encoding is easier to produce since senders know how their ClientHellos look like and we can tailor things what fields should and shouldn't be copied. But it's harder to decode since you need to add checks for silly questions like \"what order do I insert extensions?\" or \"what happens if the placeholder is missing\" or \"what happens if there are two placeholders?\" or \"what happens if the outer ClientHello is missing the extension to copy?\".\r\n\r\nConversely, though it may take more spec text to describe, a bytes-based encoding is easier to decode since you just blindly evaluate the two opcodes and only need to include a couple of checks. But it's harder to encode since you need to account for length prefixes when chopping things up.",
          "createdAt": "2019-11-06T15:55:10Z",
          "updatedAt": "2019-11-06T15:55:10Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@ekr pointed out that delta-encoding tricks should include the hash of the reconstructed ClientHello, otherwise the ciphertext tag does not cover the key shares, etc., so the above needs one more field.",
          "createdAt": "2019-11-06T20:43:34Z",
          "updatedAt": "2019-11-06T20:43:34Z"
        },
        {
          "author": "sftcd",
          "authorAssociation": "NONE",
          "body": "While waiting for this or some similar PR to be merged, I played about a bit with implementing guesses as to how it might be done in a [branch](https://github.com/sftcd/openssl/tree/encch) of my ESNI-enabled OpenSSL fork. If interested here's the [diff](https://github.com/sftcd/openssl/compare/master...sftcd:encch) and [some notes](https://github.com/sftcd/openssl/blob/encch/esnistuff/echo.md) on what I did.\r\n\r\nDoing that was fairly messy but not that hard, the main thoughts/questions I was left with were:\r\n- <strike>it'd maybe be easier to have the ESNI-specific padding in the esni-nonce extension directly as that'd mean less change to OpenSSL API behaviour (applications can set callbacks to do padding themselves too)</strike> In the end, I added a CH padding extension to the inner CH, (sort of) as envisaged in the PR, but could as easily do the padding within the esni_nonce. Still not sure if there're any API issues. The ``padded_length`` field in the ESNIConfig is now (IMO) even more of a bad plan than before as the relevant thing to pad is the entire plaintext inner CH and not just the server_name - so whomever is writing values to the DNS has even less likelihood of knowing a good exact max/value. (And it can be >260 now too.)\r\n - I took a stab at using my OpenSSL code for [HPKE](https://github.com/sftcd/happykey) instead of the ESNI-specific stuff that's been in earlier drafts and that wasn't a problem (though I didn't spend time thinking about how exactly to use HPKE - I just set the TLS session key share as the AAD)\r\n- I'm still very unclear as to what rules should/must apply to the relationship between values in the inner and outer CH's - but the simpler we can make that the better (I don't mean compression here, just what rules are to apply when we have two versions of a thing, like the TLS session key share or ALPN for example)\r\n- For ALPN, I implemented support for different values in inner and outer CH, which was easy enough and could even be possibly useful:-) One upshot of that is that it more or less means that the server really ought also do record layer padding of the EncryptedExtensions as otherwise the length of that might give the game away where values like ALPN differ between inner and outer CH.\r\n\r\nAnd just in case: I didn't try any compression and this code is likely flakey as hell in error cases, so don't anyone go using it for anything:-) I plan to ditch it anyway once draft-06 is out.",
          "createdAt": "2020-01-29T14:33:01Z",
          "updatedAt": "2020-02-07T16:20:51Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing in favor of #207.",
          "createdAt": "2020-03-08T00:32:22Z",
          "updatedAt": "2020-03-08T00:32:22Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzE4MDg5MTU0",
          "commit": {
            "abbreviatedOid": "44a7d7d"
          },
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "The design looks promising, I have just some minor comments.",
          "createdAt": "2019-11-18T03:56:13Z",
          "updatedAt": "2019-11-18T05:38:35Z",
          "comments": [
            {
              "originalPosition": 125,
              "body": "Maybe: then \"it\" does not send",
              "createdAt": "2019-11-18T03:56:13Z",
              "updatedAt": "2019-11-18T05:38:35Z"
            },
            {
              "originalPosition": 193,
              "body": "s/wil/will/",
              "createdAt": "2019-11-18T03:59:21Z",
              "updatedAt": "2019-11-18T05:38:35Z"
            },
            {
              "originalPosition": 202,
              "body": "Is this a typo \"outer_extension\"?",
              "createdAt": "2019-11-18T04:40:36Z",
              "updatedAt": "2019-11-18T05:38:35Z"
            },
            {
              "originalPosition": 126,
              "body": "This paragraph talks about sending a ESNIKeys that the client should use for retrying.\r\n\r\nTherefore, maybe s/If it rejects ESNI/If the client sent an ESNI \"encrypted_client_hello\" extension using a key not available to the server/.",
              "createdAt": "2019-11-18T05:32:16Z",
              "updatedAt": "2019-11-18T05:38:35Z"
            },
            {
              "originalPosition": 667,
              "body": "Have you dropped the period by an accident?",
              "createdAt": "2019-11-18T05:37:53Z",
              "updatedAt": "2019-11-18T05:38:35Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzIyMDQ4MTE1",
          "commit": {
            "abbreviatedOid": "44a7d7d"
          },
          "author": "sayrer",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-25T05:35:00Z",
          "updatedAt": "2019-11-25T05:35:01Z",
          "comments": [
            {
              "originalPosition": 354,
              "body": "The draft -02 protocol seems to work without an unencrypted SNI. Is this adding a required unencrypted SNI?",
              "createdAt": "2019-11-25T05:35:01Z",
              "updatedAt": "2019-11-25T05:35:01Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzIyMDQ4ODQ5",
          "commit": {
            "abbreviatedOid": "44a7d7d"
          },
          "author": "sayrer",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-25T05:38:15Z",
          "updatedAt": "2019-11-25T05:38:15Z",
          "comments": [
            {
              "originalPosition": 336,
              "body": "Double capital I in \"ClientHelloIInner\"",
              "createdAt": "2019-11-25T05:38:15Z",
              "updatedAt": "2019-11-25T05:38:15Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzIyMDQ5NjY0",
          "commit": {
            "abbreviatedOid": "44a7d7d"
          },
          "author": "sayrer",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-25T05:41:45Z",
          "updatedAt": "2019-11-25T05:41:46Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "nit: Both the AP style guide and https://tools.ietf.org/html/rfc7322 no longer capitalize \"web\"",
              "createdAt": "2019-11-25T05:41:45Z",
              "updatedAt": "2019-11-25T05:41:46Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzIyMDUwNDA2",
          "commit": {
            "abbreviatedOid": "44a7d7d"
          },
          "author": "sayrer",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-25T05:45:05Z",
          "updatedAt": "2019-11-25T05:45:05Z",
          "comments": [
            {
              "originalPosition": 69,
              "body": "\"reject an ESNIConfig\"?\r\n\r\nI'm still not clear on the reason for server-controlled padding here. I can see using this figure as a hint, though.",
              "createdAt": "2019-11-25T05:45:05Z",
              "updatedAt": "2019-11-25T05:54:58Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzIyMDUwODg1",
          "commit": {
            "abbreviatedOid": "44a7d7d"
          },
          "author": "sayrer",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-25T05:47:08Z",
          "updatedAt": "2019-11-25T05:47:09Z",
          "comments": [
            {
              "originalPosition": 195,
              "body": "May want to cite draft-hoffman-c2pq or a successor draft here.",
              "createdAt": "2019-11-25T05:47:09Z",
              "updatedAt": "2019-11-25T05:47:09Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzIyMDUxMzM5",
          "commit": {
            "abbreviatedOid": "44a7d7d"
          },
          "author": "sayrer",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-25T05:49:10Z",
          "updatedAt": "2019-11-25T05:49:10Z",
          "comments": [
            {
              "originalPosition": 245,
              "body": "I've noticed that this draft uses \"encrypted SNI\" and \"ESNI\" interchangeably, but unpredictably. Would recommend taking a pass over all of these acronyms once the naming is settled (\"ECHO\" etc...)",
              "createdAt": "2019-11-25T05:49:10Z",
              "updatedAt": "2019-11-25T05:49:10Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzIyMDUxNjQ0",
          "commit": {
            "abbreviatedOid": "44a7d7d"
          },
          "author": "sayrer",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-25T05:50:34Z",
          "updatedAt": "2019-11-25T05:50:34Z",
          "comments": [
            {
              "originalPosition": 316,
              "body": "I think the commas are off here. I think the best fix might be to leave out \"large\" and write \"duplicated extensions\".",
              "createdAt": "2019-11-25T05:50:34Z",
              "updatedAt": "2019-11-25T05:50:34Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzIyMDUyMDU0",
          "commit": {
            "abbreviatedOid": "44a7d7d"
          },
          "author": "sayrer",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-25T05:52:24Z",
          "updatedAt": "2019-11-25T05:52:24Z",
          "comments": [
            {
              "originalPosition": 510,
              "body": "Incomplete sentence.",
              "createdAt": "2019-11-25T05:52:24Z",
              "updatedAt": "2019-11-25T05:52:24Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzM1NTQ1NjAz",
          "commit": {
            "abbreviatedOid": "44a7d7d"
          },
          "author": "sayrer",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-12-20T22:08:44Z",
          "updatedAt": "2019-12-20T22:08:44Z",
          "comments": [
            {
              "originalPosition": 69,
              "body": "Just to add to the seemingly endless traffic identification via packet size: https://isc.sans.edu/diary/25616",
              "createdAt": "2019-12-20T22:08:44Z",
              "updatedAt": "2019-12-20T22:08:44Z"
            }
          ]
        }
      ],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "8395959ed6e17e3b6b91aa132fbce93652ad2ef1",
      "headRepository": "ekr/draft-ietf-tls-esni",
      "headRefName": "tunnel_version",
      "headRefOid": "44a7d7dc0706c30932f645abd19fecfba3ef5883",
      "mergeCommit": null
    },
    {
      "number": 197,
      "id": "MDExOlB1bGxSZXF1ZXN0MzM2OTYyNzY5",
      "title": "Key schedule injection proposal.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/197",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2019-11-05T20:06:28Z",
      "updatedAt": "2019-11-22T00:52:13Z",
      "closedAt": "2019-11-22T00:52:13Z",
      "mergedAt": null,
      "mergedBy": null,
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing in favor of #196.",
          "createdAt": "2019-11-22T00:52:12Z",
          "updatedAt": "2019-11-22T00:52:12Z"
        }
      ],
      "reviews": [],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "8395959ed6e17e3b6b91aa132fbce93652ad2ef1",
      "headRepository": "chris-wood/draft-ietf-tls-esni",
      "headRefName": "caw/key-schedule-injection",
      "headRefOid": "a22ffbe5e5aa1f00f9f6d6b541f00379bde8e937",
      "mergeCommit": null
    },
    {
      "number": 198,
      "id": "MDExOlB1bGxSZXF1ZXN0MzM3MDI5Nzgw",
      "title": "Add a length prefix to ESNIConfig contents.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/198",
      "state": "MERGED",
      "author": "davidben",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "ESNIConfig has a version number in front for extensibility, but it is\r\nunclear what the version invariants are. Presumably we would like\r\nversions to change the contents of an ESNIConfig (indeed different\r\ndrafts have done so), but it is not obvious this is possible and it is\r\nimpossible to skip over an ESNIConfig with a version you do not\r\nunderstand.\r\n\r\nFix this by moving the body of an ESNIConfig into an ESNIConfigContents\r\nand adding a length prefix in front.\r\n\r\nFixes #192.",
      "createdAt": "2019-11-05T22:03:51Z",
      "updatedAt": "2019-11-21T10:17:48Z",
      "closedAt": "2019-11-21T10:17:47Z",
      "mergedAt": "2019-11-21T10:17:47Z",
      "mergedBy": "chris-wood",
      "comments": [],
      "reviews": [],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "8395959ed6e17e3b6b91aa132fbce93652ad2ef1",
      "headRepository": "davidben/draft-ietf-tls-esni",
      "headRefName": "esni-config-contents",
      "headRefOid": "4a589f9559fd8d65d923d595dc0be4a7e9851432",
      "mergeCommit": {
        "oid": "4a589f9559fd8d65d923d595dc0be4a7e9851432"
      }
    },
    {
      "number": 199,
      "id": "MDExOlB1bGxSZXF1ZXN0MzM3MDY0ODcw",
      "title": "Unify version/extension and key share negotiation mechanisms",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/199",
      "state": "CLOSED",
      "author": "davidben",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "[This PR sits on top of #198. Ignore the first commit to look at it in isolation.]\r\n\r\nWe currently have two levels of mechanisms for servers to advertise multiple sets of parameters. First, each ESNIConfig has multiple keys in it, so a server can suport multiple groups at once. These keys are stapled together so a single HTTPSSVC record, etc., delivers the entire configuration.\r\n\r\nAt a layer above that, we have a version/extension-based mechanism. The server may advertise multiple ESNIConfigs to cover multiple versions of ESNI (hopefully we won't need this mechanism after standardization, but it's quite useful for draft versions) or multiple sets of mandatory extensions. Unlike the group advertisement, these are each in separate configuration units, so, e.g., they may be in multiple HTTPSSVC records.\r\n\r\nThis PR flattens the two mechanisms into one. Each ESNIConfig now has a single KeyShareEntry. Multiple groups and multiple versions are expressed in the same way: multiple ESNIConfig structures. It then introduces a wrapper ESNIConfigs structure which is the new unit of ESNI configuration delivered in HTTPSSVC, etc.\r\n\r\nThis should be paired with a change to draft-nygren-dnsop-svcb-httpssvc to carry an ESNIConfigs, not an ESNIConfig (formerly ESNIKeys). (@bemasc FYI)\r\n\r\nThis fixes a number of oddities:\r\n\r\n- Client and server need to maintain two levels of configuration. On the server, the structure has two layers of lists, something like list(tuple(ESNIConfig, list(PrivateKey))). Now the server maintains list(tuple(ESNIConfig, PrivateKey)). Conversely, the client needed two negotiation loops whereas now it only requires one.\r\n\r\n- Logic across different layers of the client stack now more reliably have the full ESNI configuration available in one unit.\r\n\r\n  In the old design, a single ESNIConfig, rather than a set of them, would be correlated with an IP address or CNAME, by way of the HTTPSSVC record. A server which supportsed multiple ESNI versions or mandatory extension sets would advertise several HTTPSSVC records, potentially with different IPs. That means the DNS and transport connection logic must know about TLS capabitilies to pick the right HTTPSSVC record.\r\n\r\n  In the new design, the server includes all its variations at once, so the DNS and transport logic can reasonably pick an HTTPSSVC purely based on whether the TLS stack supports ESNI, rather than the full set of capabilities. That is, the text in [0] does not work right now, and this PR fixes it.\r\n\r\nThe downside is that, in the likely case that the server only supports one version and one set of extensions, the non-key ESNI config bits (notably the public name; the rest is small) are repeated for every named group. However, the public name should not be that large and servers should only need one or two groups[1].\r\n\r\nThis also does make ESNIConfigs and ESNIConfig separate structures, which is slightly goofy. Alternate names if folks prefer:\r\n\r\n- ESNIConfig/ESNIConfigs => ESNIConfig/ESNIBundle\r\n- ESNIConfig/ESNIConfigs => ESNIKey/ESNIConfig\r\n\r\n[0] https://tools.ietf.org/html/draft-nygren-dnsop-svcb-httpssvc-00#section-8.1.1\r\n[1] https://www.imperialviolet.org/2016/05/16/agility.html",
      "createdAt": "2019-11-05T23:14:18Z",
      "updatedAt": "2019-11-06T15:44:28Z",
      "closedAt": "2019-11-06T15:44:28Z",
      "mergedAt": null,
      "mergedBy": null,
      "comments": [
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "It seems to me that there are two changes here:\r\n\r\n1. Bundling all the ESNIConfigs into a single HTTPSVC record. This seems like a good idea for the reasons you lay out.\r\n\r\n2. Flattening the structure. I'm less enthusiastic about this: it requires duplicating data and is a new opportunity to have inconsistencies as well as bloat.",
          "createdAt": "2019-11-05T23:19:39Z",
          "updatedAt": "2019-11-05T23:19:39Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "That's a good point. It's late here, so I will see about splitting this into two PRs tomorrow.",
          "createdAt": "2019-11-05T23:24:26Z",
          "updatedAt": "2019-11-05T23:24:26Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Split this into #200 and #201.",
          "createdAt": "2019-11-06T15:44:27Z",
          "updatedAt": "2019-11-06T15:44:27Z"
        }
      ],
      "reviews": [],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "8395959ed6e17e3b6b91aa132fbce93652ad2ef1",
      "headRepository": "davidben/draft-ietf-tls-esni",
      "headRefName": "esni-configs",
      "headRefOid": "d4f38d88ab9e11718a638f669e7b254813d68ba8",
      "mergeCommit": null
    },
    {
      "number": 200,
      "id": "MDExOlB1bGxSZXF1ZXN0MzM3NDI4OTE5",
      "title": "Advertise multiple ESNIConfigs as a unit",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/200",
      "state": "MERGED",
      "author": "davidben",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "[This was split out of #199 as the hopefully less controversial idea. Also it sits on top of #198. Ignore the first commit to look at it in isolation.]\r\n\r\nWe have two levels of mechanisms for servers to advertise parameters. Each ESNIConfig has multiple keys, so a server can suport multiple groups at once. These keys are stapled together so a single HTTPSSVC record delivers the entire configuration.\r\n\r\nThen we have a versions/extensions mechanism. A server supporting multiple versions of ESNI or multiple sets of mandatory extensions must advertise multiple ESNIConfigs. Unlike the group advertisement, these require separate HTTPSSVC records. This means the full ESNI config is not reliably available to logic across different layers of the client stack. In particular, the HTTPSSVC spec text in [0] does not work. (@bemasc FYI)\r\n\r\nCurrently, a single ESNIConfig, rather than a set of them, is correlated with an IP address or CNAME, by way of the HTTPSSVC record. A server which supports multiple ESNI versions or mandatory extension sets must advertise several HTTPSSVC records, potentially with different IPs. DNS and transport logic must know TLS capabilities to pick the right HTTPSSVC record.\r\n\r\nThis PR introduces an ESNIConfigs structure which advertises a list of ESNIConfig structures. The ESNIConfigs is the new unit of ESNI configuration. This should be paired with a change to draft-nygren-dnsop-svcb-httpssvc to carry an ESNIConfigs, not an ESNIConfig (formerly ESNIKeys).\r\n\r\nNow the server can include the full config at once, so the DNS and transport logic can reasonably pick an HTTPSSVC purely based on whether the TLS stack supports ESNI, rather than the full set of capabilities. This fixes the text in [0].\r\n\r\nThat ESNIConfigs and ESNIConfig are separate structures is slightly goofy naming. Alternate names if folks prefer:\r\n\r\n- ESNIConfig/ESNIConfigs => ESNIConfig/ESNIBundle\r\n\r\n- ESNIConfig/ESNIConfigs => ESNIKeys/ESNIConfig\r\n  (Nuisance: an ESNIConfig is a list of ESNIKeyses, which brings back the double plural.)\r\n\r\n(While I'm here, fix the remnants of ESNIKeyShares. I'll split that out if this PR is controversial, but GitHub is really bad at dependent PRs, so I've left it together for now.)\r\n\r\n[0] https://tools.ietf.org/html/draft-nygren-dnsop-svcb-httpssvc-00#section-8.1.1",
      "createdAt": "2019-11-06T15:43:10Z",
      "updatedAt": "2019-11-21T10:17:46Z",
      "closedAt": "2019-11-21T10:17:46Z",
      "mergedAt": "2019-11-21T10:17:46Z",
      "mergedBy": "chris-wood",
      "comments": [
        {
          "author": "bemasc",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> This means the full ESNI config is not reliably available to logic across different layers of the client stack. In particular, the HTTPSSVC spec text in [0] does not work. (@bemasc FYI)\r\n\r\nWhy doesn't it work?  The transport side tries the highest-priority option, and the TLS library is free to reject it, in which case the transport side will try the next option, etc.  All the transport side needs to know is whether the TLS library supports ESNI.\r\n\r\nAre you thinking about a case where the client only supports ESNI version 1, and the server only offers ESNI version 2?",
          "createdAt": "2019-11-06T15:49:26Z",
          "updatedAt": "2019-11-06T15:49:26Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "That presumes your retry loop is integrated up and down the layers. It also means that, unless you shortcircuit things and check ESNI ahead of time, you pay for a TCP roundtrip to the unsupported ESNIConfig addresses. It also doesn't account for cases when the client doesn't support any of the ESNI versions. In that case, it should connect without ESNI (presuming it would be okay doing so without ESNI configs).",
          "createdAt": "2019-11-06T16:02:37Z",
          "updatedAt": "2019-11-06T16:02:55Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> That presumes your retry loop is integrated up and down the layers. It also means that, unless you shortcircuit things and check ESNI ahead of time, you pay for a TCP roundtrip to the unsupported ESNIConfig addresses.\r\n\r\nOK, I agree with all of this.  I'm happy to reduce the required level of integration, if we can find a way.\r\n\r\n> It also doesn't account for cases when the client doesn't support any of the ESNI versions. In that case, it should connect without ESNI (presuming it would be okay doing so without ESNI configs).\r\n\r\nAre you proposing that the TLS library should silently ignore an ESNIConfigs with all unsupported versions/ciphers, and send the SNI in cleartext?  That seems like a recommendation that should go in this draft.  Or are you proposing a fallback check that goes back to the transport layer?",
          "createdAt": "2019-11-06T16:37:00Z",
          "updatedAt": "2019-11-06T16:37:00Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Are you proposing that the TLS library should silently ignore an ESNIConfigs with all unsupported versions/ciphers, and send the SNI in cleartext? That seems like a recommendation that should go in this draft.\r\n\r\nIt is in the draft. It says you ignore ESNIConfigs you don't understand.",
          "createdAt": "2019-11-06T17:02:26Z",
          "updatedAt": "2019-11-06T17:02:26Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Discussed in Singapore; no objections. Will merge.",
          "createdAt": "2019-11-21T10:16:39Z",
          "updatedAt": "2019-11-21T10:16:39Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzE3MjQ0NDQw",
          "commit": {
            "abbreviatedOid": "72711a8"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-11-14T20:38:24Z",
          "updatedAt": "2019-11-14T20:38:24Z",
          "comments": []
        }
      ],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "8395959ed6e17e3b6b91aa132fbce93652ad2ef1",
      "headRepository": "davidben/draft-ietf-tls-esni",
      "headRefName": "esni-configs-2",
      "headRefOid": "72711a8959dcf8f9b63c5c7e041a17b969f5f9ce",
      "mergeCommit": {
        "oid": "d45d404dd2000740ddef3d7a8a537c7c3b55e7a8"
      }
    },
    {
      "number": 201,
      "id": "MDExOlB1bGxSZXF1ZXN0MzM3NDI5NTUx",
      "title": "Flatten ESNI negotiation mechanisms",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/201",
      "state": "MERGED",
      "author": "davidben",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "[This was split out of #199 as the possibly more controversial idea. It's a simplification but does make configs larger. Also it sits on top of #198 and #200. Ignore the first two comments to look at it in isolation.]\r\n\r\nWe have two layers of parameter negotiation. Multiple KeyShareEntry values in an ESNIConfig, and multiple ESNIConfig values in an ESNIConfigs. We only need one mechanism, so store only one KeyShareEntry in an ESNIConfig.\r\n\r\nThis simplifies representing client and server configuration, which simplies implementation internals as well as interchange formats. Right now, on the server, configuration has two layers of lists, something like list(tuple(ESNIConfig, list(PrivateKey))). Now the server maintains list(tuple(ESNIConfig, PrivateKey)).\r\n\r\nNote also that draft-farrell-tls-pemesni-00 has this oddity around what to do if the ESNIKeys contains multiple keys. This is particularly a nuisance because a single standalone PRIVATE KEY / ESNIKEY pair is not usable because the server has committed to answering to *all* keys in the ESNIKeys. The server must consume multiple PEM files, match up the ESNIKeyses, and then assert that it has a complete set.\r\n\r\nThe downside is that, in the likely case that the server only supports one version and one set of extensions, the non-key ESNI config bits (notably the public name; the rest is small) are repeated for every named group. However, the public name should not be that large and servers should only need one or two groups (see https://www.imperialviolet.org/2016/05/16/agility.html).",
      "createdAt": "2019-11-06T15:44:17Z",
      "updatedAt": "2020-02-23T13:49:02Z",
      "closedAt": "2020-02-23T13:49:01Z",
      "mergedAt": "2020-02-23T13:49:01Z",
      "mergedBy": "chris-wood",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzE3MjQ1NzI3",
          "commit": {
            "abbreviatedOid": "67a2e15"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "This LGTM -- thanks, David!",
          "createdAt": "2019-11-14T20:40:45Z",
          "updatedAt": "2019-11-14T20:40:45Z",
          "comments": []
        }
      ],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "8395959ed6e17e3b6b91aa132fbce93652ad2ef1",
      "headRepository": "davidben/draft-ietf-tls-esni",
      "headRefName": "esni-configs-flatten",
      "headRefOid": "67a2e15076a4e95c03b125d54e5d1888663e2605",
      "mergeCommit": {
        "oid": "4d2aa537160d22456a8bc1db9cf7a0295055963c"
      }
    },
    {
      "number": 203,
      "id": "MDExOlB1bGxSZXF1ZXN0MzQxMDkzMTY5",
      "title": "Remove ESNI RRType Considerations",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/203",
      "state": "MERGED",
      "author": "mrsylerpowers",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #202 ",
      "createdAt": "2019-11-14T17:31:37Z",
      "updatedAt": "2019-11-14T20:35:25Z",
      "closedAt": "2019-11-14T20:35:25Z",
      "mergedAt": "2019-11-14T20:35:25Z",
      "mergedBy": "chris-wood",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzE3MjQyOTM3",
          "commit": {
            "abbreviatedOid": "e9c66fc"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-11-14T20:35:20Z",
          "updatedAt": "2019-11-14T20:35:20Z",
          "comments": []
        }
      ],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "8395959ed6e17e3b6b91aa132fbce93652ad2ef1",
      "headRepository": "mrsylerpowers/draft-ietf-tls-esni",
      "headRefName": "patch-1",
      "headRefOid": "e9c66fcbe8756a2c86461b70c56975ec71616c55",
      "mergeCommit": {
        "oid": "811def0f5f7f858a42a2c51cbf70baf0c2562202"
      }
    },
    {
      "number": 207,
      "id": "MDExOlB1bGxSZXF1ZXN0Mzg1MjA5NDIy",
      "title": "ESNI -> ECHO",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/207",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This change implements the ESNI -> ECHO design discussed in Singapore. There a couple pending TODOs, particularly around cross-CH HRR binding, but the meat is what's currently being analyzed. \r\n\r\ncc @davidben, @grittygrease, @martinthomson, @karthikbhargavan ",
      "createdAt": "2020-03-08T00:30:29Z",
      "updatedAt": "2020-03-09T21:57:43Z",
      "closedAt": "2020-03-09T21:57:43Z",
      "mergedAt": "2020-03-09T21:57:43Z",
      "mergedBy": "chris-wood",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcxNTU2Mzk3",
          "commit": {
            "abbreviatedOid": "42c6c48"
          },
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "This still seems a bit rough, but I think better in the spec than out.",
          "createdAt": "2020-03-09T21:56:12Z",
          "updatedAt": "2020-03-09T21:56:12Z",
          "comments": []
        }
      ],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "f13e0c956c1b42e4121ee41904a77af1bacebf18",
      "headRepository": "chris-wood/draft-ietf-tls-esni",
      "headRefName": "caw/tunnel",
      "headRefOid": "42c6c489a9bfa7bdceb4b9b8b6c34415dae3ca68",
      "mergeCommit": {
        "oid": "7d53f5b6985242c18e1a988104090dc1f08a4d74"
      }
    },
    {
      "number": 208,
      "id": "MDExOlB1bGxSZXF1ZXN0Mzg3MzI4NjE2",
      "title": "Align client GREASE section with ClientEncryptedCH definition.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/208",
      "state": "MERGED",
      "author": "dmcardle",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Also define the length of the randomly-generated \"encrypted_ch\" field.",
      "createdAt": "2020-03-12T16:02:12Z",
      "updatedAt": "2020-03-18T15:17:19Z",
      "closedAt": "2020-03-18T15:17:19Z",
      "mergedAt": "2020-03-18T15:17:18Z",
      "mergedBy": "chris-wood",
      "comments": [
        {
          "author": "dmcardle",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@davidben @dvorak42",
          "createdAt": "2020-03-12T16:04:57Z",
          "updatedAt": "2020-03-12T16:04:57Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzczNjkwNzcy",
          "commit": {
            "abbreviatedOid": "2dd6ff2"
          },
          "author": "dmcardle",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-12T16:03:19Z",
          "updatedAt": "2020-03-12T16:03:19Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "Is `padded_length` supposed to be the length for \"encrypted_ch\"? I was unclear on this.",
              "createdAt": "2020-03-12T16:03:19Z",
              "updatedAt": "2020-03-13T15:18:41Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzczNzU3Mjc4",
          "commit": {
            "abbreviatedOid": "2dd6ff2"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-12T17:25:35Z",
          "updatedAt": "2020-03-12T17:25:35Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "We should probably table this until we figure out the padding strategy. (Apparently that's still up in the air!) It also occurs to me that the first bullet in this list is obsolete -- we don't have a named group anymore or padded_length anymore:\r\n\r\n```\r\n      struct {\r\n          CipherSuite suite;\r\n          opaque record_digest<0..2^16-1>;\r\n          opaque enc<1..2^16-1>;\r\n          opaque encrypted_ch<1..2^16-1>;\r\n      } ClientEncryptedCH;\r\n```\r\n\r\nCan we just say something like the following? \r\n\r\n\"Set the \"suite\" field to a supported cipher suite. This selection SHOULD vary to exercise all supported configurations, but MAY be constant for successive connections to the same server in the same session.\"",
              "createdAt": "2020-03-12T17:25:35Z",
              "updatedAt": "2020-03-13T15:18:41Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc0MzczMzA1",
          "commit": {
            "abbreviatedOid": "2dd6ff2"
          },
          "author": "dmcardle",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-13T15:04:11Z",
          "updatedAt": "2020-03-13T15:04:12Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "Ah, ok. I'll bring the [TODO] back for the length of encrypted_ch.",
              "createdAt": "2020-03-13T15:04:11Z",
              "updatedAt": "2020-03-13T15:18:41Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc2OTY1NTcw",
          "commit": {
            "abbreviatedOid": "750477a"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-03-18T15:17:12Z",
          "updatedAt": "2020-03-18T15:17:12Z",
          "comments": []
        }
      ],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "7d53f5b6985242c18e1a988104090dc1f08a4d74",
      "headRepository": "dmcardle/draft-ietf-tls-esni",
      "headRefName": "dan-clean-up-grease",
      "headRefOid": "750477aad3b5b19c56d8c1975806309147adfc8f",
      "mergeCommit": {
        "oid": "db1d9a793c0640f03750612a4fd2be7bfe8f30b5"
      }
    },
    {
      "number": 209,
      "id": "MDExOlB1bGxSZXF1ZXN0Mzg4NDM5NjA1",
      "title": "padding scheme text",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/209",
      "state": "MERGED",
      "author": "sftcd",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "I've tried to capture what I think is a reasonable way to handle padding now we've changed from ESNI->ECHO.  If we could do something like this, that'd be better than what's in -06.\r\n\r\nNote that I'd be even happier if we entirely eliminated ECHOConfig.minimum_inner_length - I don't think it actually adds any value and it represents yet another way to get a configuration wrong.  ",
      "createdAt": "2020-03-14T21:05:06Z",
      "updatedAt": "2020-05-03T23:58:42Z",
      "closedAt": "2020-05-03T23:58:42Z",
      "mergedAt": "2020-05-03T23:58:42Z",
      "mergedBy": "chris-wood",
      "comments": [
        {
          "author": "sftcd",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thanks for the fixes. \r\nOn the general point, I think that *if* we keep the flexibility for the client to vary the inner/outer CH however it chooses, then we will also have to depend on clients to figure out how to pad well for whatever they do. If we constrain the inner/outer variance a lot, then we could do better.\r\nIt also strikes me that the minimum_inner_length is sort of in tension with the idea of compression - if a server has to set the minimum_inner_length to 300ish to handle clients that don't compress, then clients that do compress either don't get the benefit or have to ignore the minimum_inner_length.",
          "createdAt": "2020-03-16T15:01:18Z",
          "updatedAt": "2020-03-16T15:03:37Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I don't think this PR works. The server does not have enough information to report a useful value, and the value the server reports is not useful to maintain good anonymity sets.\r\n\r\nThe server does not know that the client supports some large extension or key share type (or lots of cipher suites, ALPN protocols, etc). [Post-quantum key shares](https://www.imperialviolet.org/2018/12/12/cecpq2.html) are especially fun. It also doesn't know which extensions the client will compress from the outer ClientHello and which it will reencode.\r\n\r\nConversely, the value the server sets isn't useful. If the client implementation has a smaller baseline compression and extensions, we waste bytes without much benefit. Worse, if the client implementation has a larger baseline compression and extensions, this PR regresses anonymity. The ClientHello will then exceed `minimum_inner_length` and we don't hide the lengths of the sensitive bits.\r\n\r\nStepping back, we want to hide the distribution of ClientHelloInner lengths within some anonymity set. Most of the contributors to that length come from local client configuration: how many ciphers you support, what ALPN protocols, etc. The client is the one that knows, e.g., it sometimes asks servers for protocols A and B and sometimes for A and C. It largely has enough information to pad itself.\r\n\r\nThe main exception is the server name. Realistically we need to trim anonymity sets down to colocated services, and the client doesn't know that distribution of names. Thus, we want servers to report the value in ECHOConfig. Maybe we'll need more such statistics later, which is what extensions are for. It's annoying this is a bit complicated, but we've signing up to encrypt far more things now.\r\n\r\nI should note this presumes an anonymity set of similarly-configured clients. I think, realistically, that's all we can say rigorous things about. It's nice to reduce visible artifacts of configuration, which is why we *additionally* round up to multiples of 16, but that's something we can burn into the protocol without ECHOConfig support.",
          "createdAt": "2020-03-16T16:02:07Z",
          "updatedAt": "2020-03-16T16:03:17Z"
        },
        {
          "author": "sftcd",
          "authorAssociation": "CONTRIBUTOR",
          "body": "\nHiya,\n\nOn 16/03/2020 16:02, David Benjamin wrote:\n> I don't think this PR works. The server does not have enough\n> information to report a useful value, and the value the server\n> reports is not useful to maintain good anonymity sets.\n> \n> The server does not know that the client supports some large\n> extension or key share type (or lots of cipher suites, ALPN\n> protocols, etc). It also doesn't know which extensions the client\n> will compress from the outer ClientHello and which it will reencode.\n> \n> Conversely, the value the server sets isn't useful. If the client\n> implementation has a smaller baseline compression and extensions, we\n> waste bytes without much benefit. Worse, if the client implementation\n> has a larger baseline compression and extensions, this PR regresses\n> anonymity. The ClientHello will then exceed `minimum_inner_length`\n> and we don't hide the lengths of the sensitive bits.\n\nSorry, not seeing that last. The PR just says (or was\nmeant to say) to pad to some multiple of 16 in that\ncase which I agree isn't much guidance, but does allow\ndoing something that works. (As well as allowing things\nthat don't work well;-)\n\n> \n> Stepping back, we want to hide the distribution of ClientHelloInner\n> lengths within some anonymity set. Most of the contributors to that\n> length come from local client configuration: how many ciphers you\n> support, what ALPN protocols, etc. The client is the one that knows,\n> e.g., it sometimes asks servers for protocols A and B and sometimes\n> for A and C. It largely has enough information to pad itself.\n\nI agree that all this really needs to be driven by the\nclient.\n\n> The main exception is the server name. Realistically we need to trim\n> anonymity sets down to colocated services, and the client doesn't\n> know that distribution of names. \n\nWell, yes and no. I don't believe a server config is\nuseful for that, (as I've argued before and still do;-)\nISTM the max server name value will almost always be\nset to 254. May as well tell the client to pad as do\nthat IMO.\n\n> Thus, we want servers to report the\n> value in ECHOConfig. Maybe we'll need more such statistics later,\n> which is what extensions are for. It's annoying this is a bit\n> complicated, but we've signing up to encrypt far more things now.\n> \n> I should note this presumes an anonymity set of similarly-configured\n> clients. I think, realistically, that's all we can say rigorous\n> things about. It's nice to reduce visible artifacts of configuration,\n> which is why we *additionally* round up to multiples of 16, but\n> that's something we can burn into the protocol without ECHOConfig\n> support.\n\nNot quite sure if I agree with that last para or not TBH!\n\nS.\n\n\n> \n",
          "createdAt": "2020-03-16T21:46:18Z",
          "updatedAt": "2020-03-16T21:46:18Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> > Conversely, the value the server sets isn't useful. If the client\r\n> > implementation has a smaller baseline compression and extensions, we\r\n> >  waste bytes without much benefit. Worse, if the client implementation\r\n> > has a larger baseline compression and extensions, this PR regresses\r\n> > anonymity. The ClientHello will then exceed `minimum_inner_length`\r\n> > and we don't hide the lengths of the sensitive bits.\r\n>\r\n> Sorry, not seeing that last. The PR just says (or was\r\n> meant to say) to pad to some multiple of 16 in that\r\n> case which I agree isn't much guidance, but does allow\r\n> doing something that works. (As well as allowing things\r\n> that don't work well;-)\r\n\r\nWell, if we were satisfied just padding names to a multiple of 16, we wouldn't need any of this. We'd just say to pad to a multiple 16 and move on. :-) In the current name-focused spelling, the client is always able to apply a smarter padding decision based on the server's knowledge of the name distribution. With this PR, clients whose local configuration exceeds or is near `minimum_inner_length` lose this and hit the baseline multiple of 16 behavior. Clients whose local configuration is decently below `minimum_inner_length` do hide the name distribution, but using many more bytes than they would with the current text.\r\n\r\n> > The main exception is the server name. Realistically we need to trim\r\n> > anonymity sets down to colocated services, and the client doesn't\r\n> > know that distribution of names.\r\n>\r\n> Well, yes and no. I don't believe a server config is\r\n> useful for that, (as I've argued before and still do;-)\r\n> ISTM the max server name value will almost always be\r\n> set to 254. May as well tell the client to pad as do\r\n> that IMO.\r\n\r\nWe have some metrics in Chrome on the distribution of DNS names. It's nowhere near 254. But, regardless, if you don't believe a server config is even useful for the name and agree with me that other extensions ought to be client-driven, I'm confused, why this PR? This PR seems to go in the opposite direction.\r\n\r\n> > I should note this presumes an anonymity set of similarly-configured\r\n> > clients. I think, realistically, that's all we can say rigorous\r\n> > things about. It's nice to reduce visible artifacts of configuration,\r\n> > which is why we *additionally* round up to multiples of 16, but\r\n> > that's something we can burn into the protocol without ECHOConfig\r\n> > support.\r\n>\r\n> Not quite sure if I agree with that last para or not TBH!\r\n\r\nHehe. Which part?",
          "createdAt": "2020-03-16T22:13:18Z",
          "updatedAt": "2020-03-16T22:13:18Z"
        },
        {
          "author": "sftcd",
          "authorAssociation": "CONTRIBUTOR",
          "body": "\nHIya,\n\nOn 16/03/2020 22:13, David Benjamin wrote:\n>>> Conversely, the value the server sets isn't useful. If the\n>>> client implementation has a smaller baseline compression and\n>>> extensions, we waste bytes without much benefit. Worse, if the\n>>> client implementation has a larger baseline compression and\n>>> extensions, this PR regresses anonymity. The ClientHello will\n>>> then exceed `minimum_inner_length` and we don't hide the lengths\n>>> of the sensitive bits.\n>> \n>> Sorry, not seeing that last. The PR just says (or was meant to say)\n>> to pad to some multiple of 16 in that case which I agree isn't much\n>> guidance, but does allow doing something that works. (As well as\n>> allowing things that don't work well;-)\n> \n> Well, if we were satisfied just padding names to a multiple of 16, we\n> wouldn't need any of this. We'd just say to pad to a multiple 16 and\n> move on. :-) In the current name-focused spelling, the client is\n> always able to apply a smarter padding decision based on the server's\n> knowledge of the name distribution. With this PR, clients whose local\n> configuration exceeds or is near `minimum_inner_length` lose this and\n> hit the baseline multiple of 16 behavior. Clients whose local\n> configuration is decently below `minimum_inner_length` do hide the\n> name distribution, but using many more bytes than they would with the\n> current text.\n\nYes. That's IMO the downside of having any server config.\n(To answer your question below, I prefer not having any\nserver config at all but proposed this as I think it's\nbetter than draft-06.)\n\n> \n>>> The main exception is the server name. Realistically we need to\n>>> trim anonymity sets down to colocated services, and the client\n>>> doesn't know that distribution of names.\n>> \n>> Well, yes and no. I don't believe a server config is useful for\n>> that, (as I've argued before and still do;-) ISTM the max server\n>> name value will almost always be set to 254. May as well tell the\n>> client to pad as do that IMO.\n> \n> We have some metrics in Chrome on the distribution of DNS names. It's\n> nowhere near 254. \n\nHaving also looked at some passive DNS stuff, I fully\nagree. But ISTM for many scenarios the entity that\ngenerates the ECHOConfig won't know the distribution\nof names in use (e.g. whoever configures OpenSSL won't,\nsame with Apache etc.) so it's likely they'll have to\ngo for whatever is the max (i.e. 254). Same is true\nfor anyone with a wild-card server cert in play\nsomewhere.\n\n> But, regardless, if you don't believe a server\n> config is even useful for the name and agree with me that other\n> extensions ought to be client-driven, I'm confused, why this PR? This\n> PR seems to go in the opposite direction.\n\nSee above. I'm trying for either a modest improvement\nover draft-06 or for us all to arrive at a real\nimprovement by ditching the server config entirely:-)\n\n> \n>>> I should note this presumes an anonymity set of\n>>> similarly-configured clients. I think, realistically, that's all\n>>> we can say rigorous things about. It's nice to reduce visible\n>>> artifacts of configuration, which is why we *additionally* round\n>>> up to multiples of 16, but that's something we can burn into the\n>>> protocol without ECHOConfig support.\n>> \n>> Not quite sure if I agree with that last para or not TBH!\n> \n> Hehe. Which part?\n\nI like the last sentence. I think I dislike the 1st:-)\n\nCheers,\nS.\n\n> \n",
          "createdAt": "2020-03-16T22:28:24Z",
          "updatedAt": "2020-03-16T22:28:24Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> > [...] With this PR, clients whose local configuration exceeds or is near `minimum_inner_length` lose this and hit the baseline multiple of 16 behavior.  [...trimmed for brevity, but please let me know if I've misinterpreted what 'That' referred to!]\r\n>\r\n> Yes. That's IMO the downside of having any server config.\r\n> (To answer your question below, I prefer not having any\r\n> server config at all but proposed this as I think it's\r\n> better than draft-06.)\r\n\r\nIt's not a downside of the draft-06 formulation, is it? The client learns something targeted to the name and can pad accordingly.\r\n\r\n> >  We have some metrics in Chrome on the distribution of DNS names. It's nowhere near 254.\r\n>\r\n> Having also looked at some passive DNS stuff, I fully\r\n> agree. But ISTM for many scenarios the entity that\r\n> generates the ECHOConfig won't know the distribution\r\n> of names in use (e.g. whoever configures OpenSSL won't,\r\n> same with Apache etc.) so it's likely they'll have to\r\n> go for whatever is the max (i.e. 254). Same is true\r\n> for anyone with a wild-card server cert in play\r\n> somewhere.\r\n\r\nEven with a wildcard server cert, the server should still know the distribution. For instance, `*.github.io` isn't going to see anything terribly long most of the time. (Looks like the registration limit is 39 characters.) For reference, this is how long a 254-character hostname is:\r\n\r\naaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\r\n\r\nIn order to enjoy wide adoption, ECHO can't be too much of a waste of resources.  I think it thus makes sense to target a different maximum here.\r\n\r\n> See above. I'm trying for either a modest improvement\r\n> over draft-06 or for us all to arrive at a real\r\n> improvement by ditching the server config entirely:-)\r\n\r\nI guess my view is that, because of this issue above, this is a regression over the draft-06 formulation, even though it looks more general.",
          "createdAt": "2020-03-17T19:32:10Z",
          "updatedAt": "2020-03-17T19:32:10Z"
        },
        {
          "author": "sftcd",
          "authorAssociation": "CONTRIBUTOR",
          "body": "\nHiya,\n\nOn 17/03/2020 19:32, David Benjamin wrote:\n>>> [...] With this PR, clients whose local configuration exceeds or\n>>> is near `minimum_inner_length` lose this and hit the baseline\n>>> multiple of 16 behavior.  [...trimmed for brevity, but please let\n>>> me know if I've misinterpreted what 'That' referred to!]\n>> \n>> Yes. That's IMO the downside of having any server config. (To\n>> answer your question below, I prefer not having any server config\n>> at all but proposed this as I think it's better than draft-06.)\n> \n> It's not a downside of the draft-06 formulation, is it? The client\n> learns something targeted to the name and can pad accordingly.\n\nDraft-06 assumes that no other inner CH content has the\nproperty that server guidance will help. My claim is that\nthat guidance is useless in practice, and therefore\nunnecessary. I think the server config'd length in the PR\nis a little less useless:-)\n\n> \n>>> We have some metrics in Chrome on the distribution of DNS names.\n>>> It's nowhere near 254.\n>> \n>> Having also looked at some passive DNS stuff, I fully agree. But\n>> ISTM for many scenarios the entity that generates the ECHOConfig\n>> won't know the distribution of names in use (e.g. whoever\n>> configures OpenSSL won't, same with Apache etc.) so it's likely\n>> they'll have to go for whatever is the max (i.e. 254). Same is\n>> true for anyone with a wild-card server cert in play somewhere.\n> \n> Even with a wildcard server cert, the server should still know the\n> distribution. \n\nSome servers will. Some will not. Many (most?) server\nECHOConfig instances will make use of default settings.\nThose'll pick 254 because adding a new VirtualHost to\nan apache instance (or similar) won't be co-ordinated\nwith making a new ECHOConfig in general. And even it\nit were, (but it won't!) we get a TTL's worth of mismatch.\nIf we don't provide a way for clients to handle the case\nwhere the server config is too short, again servers will\npublish 254.\n\n> For instance, `*.github.io` isn't going to see anything\n> terribly long most of the time. \n\nI am more interested in random smaller web sites/hosters\nmyself. I think ECHO should work for those as well as we\ncan make it, (albeit with smaller anonymity sets), and\nthis tie between web server config and ECHOConfig is just\na bad plan for such.\n\n> (Looks like the registration limit is\n> 39 characters.) For reference, this is how long a 254-character\n> hostname is:\n> \n> aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n>\n>  In order to enjoy wide adoption, ECHO can't be too much of a waste\n> of resources. \n\nAFAIK, all current deployments do just that. To be fair,\nthat's largely driven by CF's draft-02 deployment, but\nI think that backs up my argument that if there's a max,\nthat'll almost always be chosen, which implies it's a\nuseless field that leads to the inefficiency you note.\n\n> I think it thus makes sense to target a different\n> maximum here.\n\nThen it can't be the max:-) The 254 value matches the\nmax for server_name IIRC.\n\n> \n>> See above. I'm trying for either a modest improvement over draft-06\n>> or for us all to arrive at a real improvement by ditching the\n>> server config entirely:-)\n> \n> I guess my view is that, because of this issue above, this is a\n> regression over the draft-06 formulation, even though it looks more\n> general.\n\nOk. We disagree. But what do you think the client should\ndo? Draft-06 is IMO plainly incorrect in that it says to\npad in a way that'd expose other lengths should those be\nsensitive. If your answer were pad the SNI to at least\nECHOConfig.maximum_name_length and then make the overall\na multiple of 16, with as many added 16 octets blocks as\nthe client chooses, then a) that's != draft-06 and b) is\nquite close to this PR and c) just failing if the actual\nSNI in the inner CH is longer than the config setting\nseems quite wrong to me and d) hardcodes the assumption\nthat SNI is the only thing where the server may know\nbetter.\n\nCheers,\nS.\n\n\n> \n",
          "createdAt": "2020-03-17T20:06:49Z",
          "updatedAt": "2020-03-17T20:06:49Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Draft-06 assumes that no other inner CH content has the\r\n> property that server guidance will help. My claim is that\r\n> that guidance is useless in practice, and therefore\r\n> unnecessary. I think the server config'd length in the PR\r\n> is a little less useless:-)\r\n\r\nIf we come up with other places where server guidance is useful, that can be addressed with extensions. But, gotcha, I suppose that is where we disagree. I think server guidance on the overall ClientHello size is entirely useless, while server guidance on the name is may be useful.\r\n\r\n> I am more interested in random smaller web sites/hosters\r\n> myself. I think ECHO should work for those as well as we\r\n> can make it, (albeit with smaller anonymity sets), and\r\n> this tie between web server config and ECHOConfig is just\r\n> a bad plan for such.\r\n\r\nAgreed that it should also work for smaller things. I don't follow how this PR helps in that regard. It seems they still need to come up with a random value or a default, but now it's even less clear how to set it well.\r\n\r\n>> I think it thus makes sense to target a different\r\n>> maximum here.\r\n>\r\n> Then it can't be the max:-) The 254 value matches the\r\n> max for server_name IIRC.\r\n\r\nEr, yes, sorry I meant to say target a different public length. That is, 254 is so far from the maximum domain name in practice (As it should be! Hard length limits ought to be comfortably away from the actual requirement.), so padding up to it is wasteful. I think it would be better to pad up to a tighter value and, if we exceed it, accept that we only have the fallback multiple of 16 padding. (Or maybe a different strategy.) It does result in smaller anonymity sets in edge cases, but I think that a reasonable default tradeoff given other desires like broader deployment and not wasting too much of users' data.\r\n\r\n> Ok. We disagree. But what do you think the client should\r\n> do? Draft-06 is IMO plainly incorrect in that it says to\r\n> pad in a way that'd expose other lengths should those be\r\n> sensitive. If your answer were pad the SNI to at least\r\n> ECHOConfig.maximum_name_length and then make the overall\r\n> a multiple of 16, with as many added 16 octets blocks as\r\n> the client chooses, then a) that's != draft-06 and b) is\r\n> quite close to this PR and c) just failing if the actual\r\n> SNI in the inner CH is longer than the config setting\r\n> seems quite wrong to me and d) hardcodes the assumption\r\n> that SNI is the only thing where the server may know\r\n> better.\r\n\r\nI'm thinking something along the lines of:\r\n\r\n1. For each field, determine how much it makes sense to pad given what kinds of things it sends. If it varies ALPN, maybe round up to the largest of those. Most of this can be determined without server help.\r\n2. For fields where server help is useful, like the name, apply that help. Right now it's simply a `max` function. I'm also open to other strategies.\r\n3. Sum all that padding together.\r\n4. In order to generally reduce entropy across different kinds of clients, maybe apply some additional overall padding, like rounding up to a multiple of 16, which cuts down the state space by 16x and doesn't cost much. (Or maybe we should round up to the nearest `int(64 * 1.1**i)`? That avoids higher resolution on longer values while bounding the fraction of bytes wasted by this step.) That said, it's worth keeping in mind that clients already vary quite a bit in the cleartext portions of the ClientHello. There's a bit of tension between wanting to look like the other clients and wanting to ship new security improvements.\r\n\r\nThis is different from this PR because this PR asks the server to report a value including things it doesn't know anything about (how large the client-controlled parameters are). I don't quite follow (c). It seems this PR and the above proposal has roughly the same failure modes when something is too long. The difference is that `maximum_name_length`'s failure mode is only tripped on particular long names (something the server knows the distribution of), while this PR's equivalent failure mode is based on factors outside the server control, yet the server is responsible for the value.",
          "createdAt": "2020-03-17T22:02:45Z",
          "updatedAt": "2020-03-17T22:02:45Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> For each field\r\n\r\nClarification: this is for each field where the client doesn't reference the outer ClientHello. If the client wishes to do that, it means the client doesn't consider that field secret so there isn't anything to pad.",
          "createdAt": "2020-03-17T22:03:58Z",
          "updatedAt": "2020-03-17T22:03:58Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "I like @davidben's suggested algorithm, as an ideal padding function requires input from both the client and server. (Ideally, servers would send padding recommendations for each extension that might vary specifically for them, such as the server name. They don't have insight into anything else, so clients need to make padding decisions based on local configuration.)\r\n\r\n@sftcd, what do you think?",
          "createdAt": "2020-03-18T15:26:40Z",
          "updatedAt": "2020-03-18T15:26:40Z"
        },
        {
          "author": "sftcd",
          "authorAssociation": "CONTRIBUTOR",
          "body": "\n\nOn 18/03/2020 15:26, Christopher Wood wrote:\n> I like @davidben's suggested algorithm, as an ideal padding function\n> requires input from both the client and server. (Ideally, servers\n> would send padding recommendations for each extension that might vary\n> specifically for them, such as the server name. They don't have\n> insight into anything else, so clients need to make padding decisions\n> based on local configuration.)\n> \n> @sftcd, what do you think?\n\nCould live with it, but still prefer no server config.\nI'm looking a bit at some numbers and will try make a\nconcrete suggestion later today. If I don't get that\ndone, it seems fair to accept @davidben's algo and move\non.\n\nCheers,\nS.\n\n> \n",
          "createdAt": "2020-03-18T15:29:25Z",
          "updatedAt": "2020-03-18T15:29:25Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "If we can get away with no server config, I'm also entirely happy with that. Fewer moving parts is always great. We certainly could do that by saying names are padded up to 254, but I think that's too wasteful. But if we're happy with some global set of buckets that makes everyone happy (be it multiples of 16, some funny exponential thing), great!",
          "createdAt": "2020-03-18T15:57:47Z",
          "updatedAt": "2020-03-18T15:57:47Z"
        },
        {
          "author": "sftcd",
          "authorAssociation": "CONTRIBUTOR",
          "body": "\n(trimming violently and responding slowly:-)\n\nOn 17/03/2020 22:02, David Benjamin wrote:\n> I'm thinking something along the lines of:\n\nSo your steps 1-6 is a better scheme than draft-06.\n\nI still think step 2 would be better as something like:\n\n2. ECHOConfig contains max_name_len as before but we\nRECOMMEND it be zero and a) if the name to be padded is\nlonger than max_name_len, then names will be padded as\nfollows: P=32-(len(name)%32)+heads_or_tails*32, or b)\nif the name to be padded is shorter than max_name_len\nthen we just do as the server asked and pad to that\nlength.\n\nThat (hopefully:-) means a default of \"pad out to the\nnext multiple of 32, then toss a coin and add another\n32 if the coin landed as heads.\"\n\nIf we landed somewhere there, I'd be happy to make this\nPR say that or to make a new one or whatever.\n\nAccording to some data I have the CDFs for names and\nfor these padded lengths would be as follows:\n\nLen, CDF, Padded-CDF\n32, 81.28, 40.64\n64, 97.87, 89.57\n96, 99.31, 98.59\n128, 99.87, 99.59\n\nThat means that 81.28 of names are <32 octets long\nand 40.64% of name+name_padding will be 32 octets\nlong. 97.87% of names are <64 octets and 89.57% of\nname+name_padding are 64 octets long.\n\nI think we should RECOMMEND setting max_name_len to\nzero unless an ESNI key generator has a specific\nreason to set it to a non-zero value. ISTM the use-case\nfor non-zero values is where the anonymity set has only\na few very long names that with length differences of\n>32 octets for which it is considered important to use\nECHO. I'm basically fine that we default to not\nserving that use-case wellmby default, as I don't\nbelieve it's real. (But I could be wrong;-)\n\n\nCheers,\nS.\n\n\n\n\n\n\n",
          "createdAt": "2020-03-20T11:34:52Z",
          "updatedAt": "2020-03-20T11:34:52Z"
        },
        {
          "author": "sayrer",
          "authorAssociation": "NONE",
          "body": "Could the sender always pad their packets to at least 1200 bytes or something, using an encrypted extension in the ClientHello?\r\n\r\nI don't understand the focus on server input to a padding function that would ideally fill out one packet.",
          "createdAt": "2020-03-21T02:49:10Z",
          "updatedAt": "2020-03-21T06:31:55Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@sftcd what's the value in adding zero or one 32B blocks after rounding? Why not just stick with what was done, say, in RFC8467? (We could make it read something like, \"clients may add zero or one blocks.\" Either way, I'm more or less fine with the suggested change. Would you mind updating this PR to match?)",
          "createdAt": "2020-03-22T16:31:39Z",
          "updatedAt": "2020-03-22T16:34:58Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> I don't understand the focus on server input to a padding function that would ideally fill out one packet.\r\n\r\nPer [David's comment](https://github.com/tlswg/draft-ietf-tls-esni/pull/209#issuecomment-600322366) above, clients *could* use help from servers in choosing appropriate padding lengths. (Only servers know their name anonymity set.)",
          "createdAt": "2020-03-22T16:33:49Z",
          "updatedAt": "2020-03-22T16:33:49Z"
        },
        {
          "author": "sftcd",
          "authorAssociation": "CONTRIBUTOR",
          "body": "\nHiya,\n\nOn 22/03/2020 16:32, Christopher Wood wrote:\n> @sftcd what's the value in adding zero or one 32B blocks after\n> rounding? Why not just stick with what was done, say, in RFC8467?\n>\n\nSay if the anonymity set has lots of names <32 length\n(~81% of names in the data I have) but a small number\nbetween 32 and 64 (~16% in my data). Then this should\ndisguise the use of the longer names at the expense\nof sending more octets. Would be v. happy to know if\nthat made sense to others.\n\nCheers,\nS.\n\n",
          "createdAt": "2020-03-22T16:39:07Z",
          "updatedAt": "2020-03-22T16:39:07Z"
        },
        {
          "author": "sftcd",
          "authorAssociation": "CONTRIBUTOR",
          "body": "\nA friendly amendment below (but one I think is\nimportant)...\n\nOn 22/03/2020 16:34, Christopher Wood wrote:\n>> I don't understand the focus on server input to a padding function\n>> that would ideally fill out one packet.\n> \n> Per [David's\n> comment](https://github.com/tlswg/draft-ietf-tls-esni/pull/209#issuecomment-600322366)\n> above, clients *could* use help from servers in choosing appropriate\n> padding lengths. (Only servers know their name anonymity set.)\n> \n\nI think that last really needs to be \"Only servers can know\ntheir name anonymity set. But many servers will not know\nthat, either due to wildcard certs or because names/vhosts\nare added and removed all the time independent of whatever\nis in the DNS.\"\n\nCheers,\nS.\n",
          "createdAt": "2020-03-22T16:41:47Z",
          "updatedAt": "2020-03-22T16:41:47Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> Would be v. happy to know if that made sense to others.\r\n\r\nIt makes sense, I'm just not not sure it's worth the cost. That said, this will always be an imperfect solution, so I'm happy either way.\r\n",
          "createdAt": "2020-03-22T16:44:11Z",
          "updatedAt": "2020-03-22T16:44:20Z"
        },
        {
          "author": "sftcd",
          "authorAssociation": "CONTRIBUTOR",
          "body": "\n\nOn 22/03/2020 16:44, Christopher Wood wrote:\n>> Would be v. happy to know if that made sense to others.\n> \n> It makes sense, I'm just not not sure it's worth the cost. \n\nYep. Me neither. It is cheaper than padding to 254 octets\nfor everyone though;-)\n\nPartly, I'm not that sympathetic towards anyone who\nwants to hide a crazily-long server_name. OTOH, I guess\nthere may be a few who can't easily change names so we\nprobably ought try do something for 'em.\n\nCheers,\nS.\n\n> That said,\n> this will always be an imperfect solution, so I'm happy either way.\n> \n> \n",
          "createdAt": "2020-03-22T16:48:26Z",
          "updatedAt": "2020-03-22T16:48:26Z"
        },
        {
          "author": "sayrer",
          "authorAssociation": "NONE",
          "body": "> > I don't understand the focus on server input to a padding function that would ideally fill out one packet.\r\n> \r\n> Per [David's comment](https://github.com/tlswg/draft-ietf-tls-esni/pull/209#issuecomment-600322366) above, clients _could_ use help from servers in choosing appropriate padding lengths. (Only servers know their name anonymity set.)\r\n\r\nAgree that only servers could know their name anonymity set. But what is the cost of always padding out the ClientHello so it approaches the MTU? Just trying to understand why the spec attempts to economize on the number of bytes in the ClientHello packet.",
          "createdAt": "2020-03-24T00:19:13Z",
          "updatedAt": "2020-03-24T00:19:13Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> But what is the cost of always padding out the ClientHello so it approaches the MTU?\r\n\r\nAs far as I know, there's no reason other than folks might not want to always \"waste\" these bytes.",
          "createdAt": "2020-03-24T20:34:31Z",
          "updatedAt": "2020-03-24T20:34:31Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Padding the ClientHello up to an MTU isn't free. See the numbers here on what a 400-byte increase costs.\r\nhttps://www.imperialviolet.org/2018/04/11/pqconftls.html\r\n\r\nLikewise, also from that post and a [later experiment](https://www.imperialviolet.org/2019/10/30/pqsivssl.html), post-quantum key shares will likely exceed a packet anyway. I think our padding scheme should be designed with that expectation in mind (e.g., the `minimum_inner_length` mechanism fails this because a PQ key share in the inner ClientHello will blow past the built-in server assumptions on client behavior). Canary builds of Chrome already have code for such a thing behind a flag.\r\n\r\nEdit: Added a link to the later experiment, which I'd forgotten was a separate post.",
          "createdAt": "2020-03-24T21:04:12Z",
          "updatedAt": "2020-03-24T21:07:37Z"
        },
        {
          "author": "sayrer",
          "authorAssociation": "NONE",
          "body": "> Padding the ClientHello up to an MTU isn't free. See the numbers here on what a 400-byte increase costs.\r\n> https://www.imperialviolet.org/2018/04/11/pqconftls.html\r\n\r\nIt's not quite clear what's going on in those results. For example, the mobile results are close to zero. Without seeing confidence intervals, and the distributions of the full packet sizes, I don't think this experiment settles this issue (although it could, with more detail). Also, is there a theory on /why/ 400 bytes might add latency?\r\n\r\n> Likewise, also from that post and a [later experiment](https://www.imperialviolet.org/2019/10/30/pqsivssl.html), post-quantum key shares will likely exceed a packet anyway. \r\n\r\nIf we're going to design the padding mechanism with PQ key shares in mind, but not conventional ones, that should be in the document.\r\n",
          "createdAt": "2020-03-25T03:49:27Z",
          "updatedAt": "2020-03-25T03:49:27Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> It's not quite clear what's going on in those results. For example, the mobile results are close to zero. Without seeing confidence intervals, and the distributions of the full packet sizes, I don't think this experiment settles this issue (although it could, with more detail). Also, is there a theory on /why/ 400 bytes might add latency?\r\n\r\n@agl would know the details of that experiment, but I don't think the idea that sending more bytes takes more time would be terribly surprising! :-P\r\n\r\n> If we're going to design the padding mechanism with PQ key shares in mind, but not conventional ones, that should be in the document.\r\n\r\nI don't think anyone's suggested designing without conventional key shares in mind. They are what's deployed today, after all. However, we shouldn't design *only* for a small unpadded ClientHello. PQ key shares will need larger ones. Session tickets also go in the ClientHello, and it's common for TLS servers to stick client certificates inside tickets, so you can already get large ones today already.",
          "createdAt": "2020-03-25T18:06:08Z",
          "updatedAt": "2020-03-25T18:06:08Z"
        },
        {
          "author": "sayrer",
          "authorAssociation": "NONE",
          "body": "> > It's not quite clear what's going on in those results. For example, the mobile results are close to zero. Without seeing confidence intervals, and the distributions of the full packet sizes, I don't think this experiment settles this issue (although it could, with more detail). Also, is there a theory on /why/ 400 bytes might add latency?\r\n> \r\n> @agl would know the details of that experiment, but I don't think the idea that sending more bytes takes more time would be terribly surprising! :-P\r\n\r\nLet's assume the results for \"SI\" in the first link actually do show a significant delta. The question is whether per-packet costs dominate or per-byte costs do, and whether the experiment sometimes increased the number of packets (e.g. by sometimes bumping the ultimate ClientHello size above 1280). See Section 5.1 in https://www.usenix.org/system/files/conference/atc12/atc12-final186.pdf for device performance metrics on bytes vs packets.\r\n\r\nLooking at the ClientHello traffic on my computer, I can see that Safari is sending ClientHello messages that are about 500-600 bytes. My copy of Chrome seems to be sending CurveCECPQ2 (16696?) shares, and its ClientHello messages are fragmented.",
          "createdAt": "2020-03-25T19:36:23Z",
          "updatedAt": "2020-03-25T19:36:23Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@sftcd will you be able to update this as above?",
          "createdAt": "2020-03-27T17:42:48Z",
          "updatedAt": "2020-03-27T17:42:48Z"
        },
        {
          "author": "sayrer",
          "authorAssociation": "NONE",
          "body": "would the spec allow me to put an arbitrarily-sized extension in the encrypted part of the ClientHello? if so, I don't care about the padding schemes.",
          "createdAt": "2020-03-29T05:32:52Z",
          "updatedAt": "2020-03-29T05:32:52Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> would the spec allow me to put an arbitrarily-sized extension in the encrypted part of the ClientHello? if so, I don't care about the padding schemes.\r\n\r\nYes, of course! The padding policies described here are guidance at best.",
          "createdAt": "2020-03-29T15:39:55Z",
          "updatedAt": "2020-03-29T15:39:55Z"
        },
        {
          "author": "sftcd",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I've updated the PR to try reflect the discussion above. Please take a peek and see if it seems useful now.",
          "createdAt": "2020-04-02T13:53:26Z",
          "updatedAt": "2020-04-02T13:53:26Z"
        },
        {
          "author": "sayrer",
          "authorAssociation": "NONE",
          "body": "This looks like the right idea. I'll review this again as well, but it's probably better to wait for @chris-wood's suggestions to be addressed.",
          "createdAt": "2020-04-04T21:17:46Z",
          "updatedAt": "2020-04-04T21:17:46Z"
        },
        {
          "author": "sftcd",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thanks for all the changes Chris. I think I've actioned all those as requested. If not, I tried, but failed:-)",
          "createdAt": "2020-04-04T21:33:38Z",
          "updatedAt": "2020-04-04T21:33:38Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@sftcd do you need any help moving this forward?",
          "createdAt": "2020-04-07T13:46:51Z",
          "updatedAt": "2020-04-07T13:46:51Z"
        },
        {
          "author": "sftcd",
          "authorAssociation": "CONTRIBUTOR",
          "body": "\n\nOn 07/04/2020 14:47, Christopher Wood wrote:\n> @sftcd do you need any help moving this forward?\n>\nDoing other stuff today but feel free to take the text\nand then do more edits. Or I can look at it tomorrow.\nEither's fine by me.\n\nS.\n",
          "createdAt": "2020-04-07T13:51:12Z",
          "updatedAt": "2020-04-07T13:51:12Z"
        },
        {
          "author": "sayrer",
          "authorAssociation": "NONE",
          "body": "> On 07/04/2020 14:47, Christopher Wood wrote: @sftcd do you need any help moving this forward?\r\n> Doing other stuff today but feel free to take the text and then do more edits. \r\n\r\nThanks for taking the time. None of my comments are strongly-held opinions (meaning they only need to be addressed at all if others agree that the issues are important).\r\n\r\n",
          "createdAt": "2020-04-08T00:02:47Z",
          "updatedAt": "2020-04-08T00:02:47Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Strong +1 to @sayrer -- thank you for the work here, @sftcd!",
          "createdAt": "2020-04-08T00:27:26Z",
          "updatedAt": "2020-04-08T00:27:26Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@sftcd can you please resolve conflicts? @ekr @kazuho can you please review?",
          "createdAt": "2020-04-23T21:27:32Z",
          "updatedAt": "2020-04-23T21:27:32Z"
        },
        {
          "author": "sftcd",
          "authorAssociation": "CONTRIBUTOR",
          "body": "\n\nOn 24/04/2020 16:07, ekr wrote:\n> @ekr commented on this pull request.\n> \n> I am generally fine with this, with the exception of the random\n> padding, which I think should be omitted. It's hard to analyze and\n> the value is unclear. In particular, many clients will retry if they\n> receive TCP errors, and so the attacker can learn information about\n> the true minimum value by forging TCP RSTs and looking at the new\n> CH.\n\nFair point. The argument I'd make for keeping this\nis that if an anonymity set has ~80% of names <32\noctets, then if we do nothing, passive observation\nwill probably reveal when the server name is in\nthe longest ~20%. And I'd guess that only a few\nnames in that set would be popular/common, so we\ncould be giving away the game whenever an ECHO\nis 32 octets longer than the usual. The random\npadding could mitigate that passive attack but\nyes would be vulnerable to an active reset based\ncounter.\n\nI'd also be fine with just living with the issue\nin which case we might want to note that using\nECHO with uncommonly long names is a bad idea.\n\n> \n>> +and randomly add another 32 octets 50% of the time and then\n>> include that amount\n> +of additional padding.\n> \n> I actually don't think we should recommend the random padding. Let's\n> do the minimum here.\n> \n\n",
          "createdAt": "2020-04-24T15:15:50Z",
          "updatedAt": "2020-04-24T15:15:50Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Let's just drop the random addition. Servers don't (can't) do a padding check anyway, so clients can always choose to make this longer if desired.",
          "createdAt": "2020-04-24T16:38:05Z",
          "updatedAt": "2020-04-24T16:38:05Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@sftcd can you update this PR and resolve the conflicts?",
          "createdAt": "2020-04-24T16:38:18Z",
          "updatedAt": "2020-04-24T16:38:18Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "\"Fair point. The argument I'd make for keeping this\r\nis that if an anonymity set has ~80% of names <32\r\noctets, then if we do nothing, passive observation\r\nwill probably reveal when the server name is in\r\nthe longest ~20%. \"\r\n\r\nWhich is precisely why we want the server to provide the longest name, so the client can pad to it.\r\n",
          "createdAt": "2020-04-24T16:52:49Z",
          "updatedAt": "2020-04-24T16:52:49Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "As discussed on today's call, let's do the following:\r\n\r\n1. Resolve merge conflicts.\r\n2. Drop random padding for the SNI. And add text which says that if the client's name is larger than max_name_length, it rounds up to the nearest 32B or 64B boundary.\r\n\r\n@sftcd do you need, or would you like, any help with this?",
          "createdAt": "2020-04-27T21:49:56Z",
          "updatedAt": "2020-04-27T21:49:56Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc0ODUwNDM4",
          "commit": {
            "abbreviatedOid": "18d5638"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "I think that this approach is generally better, but it runs afoul of divergence in client configuration that could dominate the calculation.  For instance, a client that sends two key shares will have very different padding requirements to one that sends only one.  For that to work, we need to assume that implementation-/deployment-specific variation of the inner CH is largely eliminated as a result of the compression scheme we adopt.  That also assumes that these variations in client behaviour are not privacy-sensitive.  \r\n\r\nI think that we should be directly acknowledging those assumptions if that is indeed the case.\r\n\r\nIf there is a significant variation in size due to client-specific measures, then we're in a bit of an awkward position.  That might render any similarly simple scheme ineffective.  For instance, a client that later supports a set of ALPN identifiers that could vary in length depending on context cannot use this signal directly. It has to apply its own logic about the padding of that extension.  That a client is doing this won't be known to a server that deploys this today. In that case, the advice from the server (which knows most about the anonymity set across which it is hoping to spread the resulting CH), isn't going to be forced through an additional filter at the client.  The results are unlikely to be good without a great deal of care.",
          "createdAt": "2020-03-16T00:11:26Z",
          "updatedAt": "2020-03-16T00:23:38Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "```suggestion\r\nthe plaintext is at least this long.\r\n```",
              "createdAt": "2020-03-16T00:11:27Z",
              "updatedAt": "2020-04-12T19:30:12Z"
            },
            {
              "originalPosition": 42,
              "body": "```suggestion\r\nGiven that extensions could be defined in the future that reveal sensitive information\r\nthrough their length, we cannot describe all the ways in which length information\r\n```",
              "createdAt": "2020-03-16T00:13:15Z",
              "updatedAt": "2020-04-12T19:30:12Z"
            },
            {
              "originalPosition": 54,
              "body": "```suggestion\r\n  of the plaintext encoding of ClienHelloInner is greater than\r\n```",
              "createdAt": "2020-03-16T00:14:05Z",
              "updatedAt": "2020-04-12T19:30:12Z"
            },
            {
              "originalPosition": 59,
              "body": "What about the converse?  Is it an error to send something that is not padded to the minimum length?",
              "createdAt": "2020-03-16T00:14:43Z",
              "updatedAt": "2020-04-12T19:30:12Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc1Mjk4Mzk4",
          "commit": {
            "abbreviatedOid": "18d5638"
          },
          "author": "sftcd",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-16T14:58:33Z",
          "updatedAt": "2020-03-16T14:58:33Z",
          "comments": [
            {
              "originalPosition": 59,
              "body": "I think I'd say no, that's maybe better not treated as an error. But I could be convinced otherwise.",
              "createdAt": "2020-03-16T14:58:33Z",
              "updatedAt": "2020-04-12T19:30:12Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg3NzA0OTQ0",
          "commit": {
            "abbreviatedOid": "9103fde"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "Thanks for the update! This looks like generally what we want. I left some recommendations for editorial improvements. ",
          "createdAt": "2020-04-04T14:39:33Z",
          "updatedAt": "2020-04-04T15:13:08Z",
          "comments": [
            {
              "originalPosition": 30,
              "body": "Could we move this paragraph to the security considerations? ",
              "createdAt": "2020-04-04T14:39:33Z",
              "updatedAt": "2020-04-12T19:30:12Z"
            },
            {
              "originalPosition": 32,
              "body": "Could we move this content to its own sub-section, perhaps with the title, \"Recommended Padding Scheme,\" to reflect the fact that it's optional?",
              "createdAt": "2020-04-04T14:43:05Z",
              "updatedAt": "2020-04-12T19:30:12Z"
            },
            {
              "originalPosition": 36,
              "body": "```suggestion\r\nFuture extensions could reveal sensitive information through their length. Consequently, \r\npadding should be flexible and support arbitrary extension changes. \r\n```",
              "createdAt": "2020-04-04T14:54:38Z",
              "updatedAt": "2020-04-12T19:30:12Z"
            },
            {
              "originalPosition": 42,
              "body": "```suggestion\r\nThe target padding length of most ClientHello extensions can be determined without server help.\r\n```",
              "createdAt": "2020-04-04T14:55:28Z",
              "updatedAt": "2020-04-12T19:30:12Z"
            },
            {
              "originalPosition": 48,
              "body": "```suggestion\r\nHowever, the \"server_name\" extension could benefit from server input (ECHOConfig.maximum_name_length). \r\nClients SHOULD compute the padding for this extension as follows:\r\n\r\n1. If ECHOConfig.maximum_name_length is longer than the actual server_name then \r\nclients SHOULD add padding to make up that difference.\r\n2. Otherwise, if ECHOConfig.maximum_name_length is zero or less than the length \r\nof the actual server_name then round the server_name up to a multiple of 32 octets \r\nand randomly add another 32 octets 50% of the time and then include that amount\r\nof additional padding.\r\n```",
              "createdAt": "2020-04-04T15:09:07Z",
              "updatedAt": "2020-04-12T19:30:12Z"
            },
            {
              "originalPosition": 52,
              "body": "```suggestion\r\nThe amount of padding applied to the ClientHello is then computed as the sum of \r\nall per-extension padding values, rounded up to the nearest multiple of 32. \r\n(This additional rounding step aims to hide variance across different client\r\nimplementations.)\r\n```",
              "createdAt": "2020-04-04T15:09:19Z",
              "updatedAt": "2020-04-12T19:30:12Z"
            },
            {
              "originalPosition": 58,
              "body": "```suggestion\r\nIn addition to padding ClientHelloInner, clients and servers will also need\r\nto pad all other handshake messages that have sensitive-length fields. For\r\nexample, if a client proposes ALPN values in ClientHelloInner, the\r\nserver-selected value will be returned in an EncryptedExtension, so that\r\nhandshake message also needs to be padded using TLS record layer padding.\r\n```",
              "createdAt": "2020-04-04T15:09:32Z",
              "updatedAt": "2020-04-12T19:30:12Z"
            },
            {
              "originalPosition": 11,
              "body": "```suggestion\r\nadded or removed from the anonymity set during the lifetime of a particular\r\n```",
              "createdAt": "2020-04-04T15:10:29Z",
              "updatedAt": "2020-04-12T19:30:12Z"
            },
            {
              "originalPosition": 42,
              "body": "Can we also merge this paragraph with the preceding one?",
              "createdAt": "2020-04-04T15:12:35Z",
              "updatedAt": "2020-04-12T19:30:12Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg3NzYyMzQ2",
          "commit": {
            "abbreviatedOid": "d4fe6f3"
          },
          "author": "sayrer",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-04-04T21:59:52Z",
          "updatedAt": "2020-04-04T22:06:15Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "nit: this is a run-on sentence. Suggest breaking at \"...then this value can be set to zero. In that case, ...\"",
              "createdAt": "2020-04-04T21:59:52Z",
              "updatedAt": "2020-04-12T19:30:12Z"
            },
            {
              "originalPosition": 42,
              "body": "Is this part right? Do clients need to consider padding for each field, or just the entire encrypted ClientHelloInner?",
              "createdAt": "2020-04-04T22:01:01Z",
              "updatedAt": "2020-04-12T19:30:12Z"
            },
            {
              "originalPosition": 53,
              "body": "Suggest: \"add at least another 32 octets\".",
              "createdAt": "2020-04-04T22:03:44Z",
              "updatedAt": "2020-04-12T19:30:12Z"
            },
            {
              "originalPosition": 75,
              "body": "Suggest: \"Variations in the length of the ClientHelloInner ciphertext...\"",
              "createdAt": "2020-04-04T22:05:44Z",
              "updatedAt": "2020-04-12T19:30:12Z"
            },
            {
              "originalPosition": 64,
              "body": "Is there a good reference for \"TLS record layer padding\"? I think I know what this means, but it could be clearer.",
              "createdAt": "2020-04-04T22:05:49Z",
              "updatedAt": "2020-04-12T19:30:12Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg4MjgwMTEy",
          "commit": {
            "abbreviatedOid": "d4fe6f3"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-04-06T14:02:29Z",
          "updatedAt": "2020-04-06T14:02:29Z",
          "comments": [
            {
              "originalPosition": 64,
              "body": "It's defined in Section 5.4 of RFC8446: https://tools.ietf.org/html/rfc8446#section-5.4",
              "createdAt": "2020-04-06T14:02:29Z",
              "updatedAt": "2020-04-12T19:30:12Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg4MjgwODI4",
          "commit": {
            "abbreviatedOid": "d4fe6f3"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-04-06T14:03:14Z",
          "updatedAt": "2020-04-06T14:03:14Z",
          "comments": [
            {
              "originalPosition": 42,
              "body": "Yep -- this is what was discussed way up above in this PR. ",
              "createdAt": "2020-04-06T14:03:14Z",
              "updatedAt": "2020-04-12T19:30:12Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg4ODk0ODM3",
          "commit": {
            "abbreviatedOid": "d4fe6f3"
          },
          "author": "sayrer",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-04-07T08:27:18Z",
          "updatedAt": "2020-04-07T08:27:18Z",
          "comments": [
            {
              "originalPosition": 42,
              "body": "Ok, I will re-read this PR, since I don't get it.\r\n\r\nBut, even so, I think this section needs a rationale. It says \"clients need to determine how much to pad given the semantics of that field\", but there is no reason given.",
              "createdAt": "2020-04-07T08:27:18Z",
              "updatedAt": "2020-04-12T19:30:12Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg4OTAzODcx",
          "commit": {
            "abbreviatedOid": "d4fe6f3"
          },
          "author": "sayrer",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-04-07T08:39:05Z",
          "updatedAt": "2020-04-07T08:39:06Z",
          "comments": [
            {
              "originalPosition": 64,
              "body": "Maybe that reference suggests a terminology issue. It says \"All encrypted TLS records can be padded to inflate the size of the TLSCiphertext.\" Does ECHO define things in terms of TLSCiphertext?\r\n\r\nI don't necessarily think there is a problem here, but in the two code bases I've read (rustls and NSS), the encrypted SNI or ClientHello haven't fit in all that cleanly.\r\n\r\nIt seems like the properties of the ClientHelloInner encryption are bit hand-wavy. I understand what's trying to be accomplished (and support that effort), but I think more explanatory text could be called for.\r\n",
              "createdAt": "2020-04-07T08:39:05Z",
              "updatedAt": "2020-04-12T19:30:12Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg5MDYwMTA0",
          "commit": {
            "abbreviatedOid": "d4fe6f3"
          },
          "author": "jhoyla",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-04-07T12:22:06Z",
          "updatedAt": "2020-04-07T12:28:11Z",
          "comments": [
            {
              "originalPosition": 53,
              "body": "Or \"add one or more blocks of 32 octets\" just to exclude behaviours that undo the effect of rounding the padding to a multiple of 32 octets.  ",
              "createdAt": "2020-04-07T12:22:06Z",
              "updatedAt": "2020-04-12T19:30:12Z"
            },
            {
              "originalPosition": 109,
              "body": "Do we need to update GREASE if we are rounding the packet sizes to multiples of 32 octets? If we want GREASE to look like ECHO then it should have the same external properties. ",
              "createdAt": "2020-04-07T12:26:53Z",
              "updatedAt": "2020-04-12T19:30:12Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg5MTE3OTc2",
          "commit": {
            "abbreviatedOid": "d4fe6f3"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-04-07T13:31:42Z",
          "updatedAt": "2020-04-07T13:31:42Z",
          "comments": [
            {
              "originalPosition": 53,
              "body": "\ud83d\udc4d to N >= 1 blocks. Clients can choose the distribution from which they want to sample N.",
              "createdAt": "2020-04-07T13:31:42Z",
              "updatedAt": "2020-04-12T19:30:12Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg5MTMxODI2",
          "commit": {
            "abbreviatedOid": "d4fe6f3"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-04-07T13:46:36Z",
          "updatedAt": "2020-04-07T13:46:36Z",
          "comments": [
            {
              "originalPosition": 109,
              "body": "Yep -- there's a TODO in the GREASE section.",
              "createdAt": "2020-04-07T13:46:36Z",
              "updatedAt": "2020-04-12T19:30:12Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg5MTQzMzQ5",
          "commit": {
            "abbreviatedOid": "d4fe6f3"
          },
          "author": "jhoyla",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-04-07T13:58:26Z",
          "updatedAt": "2020-04-07T13:58:27Z",
          "comments": [
            {
              "originalPosition": 53,
              "body": "On second thoughts, we should probably match what's done in encrypted DNS, because otherwise we could create a potential leak from correlating the DNS request length with the ECHO length. ",
              "createdAt": "2020-04-07T13:58:26Z",
              "updatedAt": "2020-04-12T19:30:12Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkxODg3NzEw",
          "commit": {
            "abbreviatedOid": "d4fe6f3"
          },
          "author": "sftcd",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-04-12T19:19:52Z",
          "updatedAt": "2020-04-12T19:19:52Z",
          "comments": [
            {
              "originalPosition": 42,
              "body": "I moved that rationale down to the security considerations section as suggested earlier. It could be moved back up, but basically anything where the length could be sensitive may need padding.",
              "createdAt": "2020-04-12T19:19:52Z",
              "updatedAt": "2020-04-12T19:30:12Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkxODg4MjQx",
          "commit": {
            "abbreviatedOid": "d4fe6f3"
          },
          "author": "sftcd",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-04-12T19:27:03Z",
          "updatedAt": "2020-04-12T19:27:04Z",
          "comments": [
            {
              "originalPosition": 53,
              "body": "Don't think copying DNS is correct. RFC 8467 calls for queries to be padded to a multiple of 128 octets and could be that the server-name is not the only sensitive name. \r\n\r\nI'm not sure there's a point in recommending against zero additional blocks of 32 - so long as you don't do zero too often it'd be ok. If you look back to the name lengths seen in the data I have it may be that zero additional blocks 50% of the time is ok. \r\n\r\nBut mainly, I'd say we may be better to wait 'till we have a few implementations and then see what makes best sense.",
              "createdAt": "2020-04-12T19:27:04Z",
              "updatedAt": "2020-04-12T19:30:12Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkxODk5MTAz",
          "commit": {
            "abbreviatedOid": "abd6637"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-04-12T22:09:36Z",
          "updatedAt": "2020-04-12T22:09:36Z",
          "comments": [
            {
              "originalPosition": 53,
              "body": "> Don't think copying DNS is correct. RFC 8467 calls for queries to be padded to a multiple of 128 octets and could be that the server-name is not the only sensitive name.\r\n\r\nCan you show that there is no information leakage if the two aren't in sync?\r\n\r\n> I'm not sure there's a point in recommending against zero additional blocks of 32 - so long as you don't do zero too often it'd be ok. If you look back to the name lengths seen in the data I have it may be that zero additional blocks 50% of the time is ok.\r\n\r\nThe proposal above suggests N >= 1, not zero. In any case, as you suggest, spinning our wheels on something for which there is no backing data or analysis (yet) seems premature.",
              "createdAt": "2020-04-12T22:09:36Z",
              "updatedAt": "2020-04-12T22:09:36Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk5NTQ0NTky",
          "commit": {
            "abbreviatedOid": "d4fe6f3"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-04-23T23:26:45Z",
          "updatedAt": "2020-04-23T23:26:45Z",
          "comments": [
            {
              "originalPosition": 53,
              "body": "Hmm, is this resolved?",
              "createdAt": "2020-04-23T23:26:45Z",
              "updatedAt": "2020-04-23T23:26:45Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAwMDMwMTE3",
          "commit": {
            "abbreviatedOid": "abd6637"
          },
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "I am generally fine with this, with the exception of the random padding, which I think should be omitted. It's hard to analyze and the value is unclear. In particular, many clients will retry if they receive TCP errors, and so the attacker can learn information about the true minimum value by forging TCP RSTs and looking at the new CH.",
          "createdAt": "2020-04-24T15:05:26Z",
          "updatedAt": "2020-04-24T15:07:01Z",
          "comments": [
            {
              "originalPosition": 53,
              "body": "I actually don't think we should recommend the random padding. Let's do the minimum here.",
              "createdAt": "2020-04-24T15:05:26Z",
              "updatedAt": "2020-04-24T15:07:01Z"
            }
          ]
        }
      ],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "7d53f5b6985242c18e1a988104090dc1f08a4d74",
      "headRepository": "sftcd/draft-ietf-tls-esni",
      "headRefName": "master",
      "headRefOid": "abd6637cd2910dae0d3001a1d3edd41779dc4be4",
      "mergeCommit": {
        "oid": "aa15d6e4d5ec406d9c0c8f782284df5b543d0510"
      }
    },
    {
      "number": 210,
      "id": "MDExOlB1bGxSZXF1ZXN0MzkxMTE4OTgz",
      "title": "Fix lingering encrypted_server_name extension references.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/210",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-03-19T16:50:19Z",
      "updatedAt": "2020-03-19T16:50:56Z",
      "closedAt": "2020-03-19T16:50:56Z",
      "mergedAt": "2020-03-19T16:50:56Z",
      "mergedBy": "ekr",
      "comments": [],
      "reviews": [],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "db1d9a793c0640f03750612a4fd2be7bfe8f30b5",
      "headRepository": "chris-wood/draft-ietf-tls-esni",
      "headRefName": "caw/nits",
      "headRefOid": "fd4d0004abb16ecc0ec50b73019d5cae342d64ed",
      "mergeCommit": {
        "oid": "9dab0e191c85d2043a5a5c835fae0abed30625da"
      }
    },
    {
      "number": 211,
      "id": "MDExOlB1bGxSZXF1ZXN0MzkyNDczNzIz",
      "title": "Remove OPEN ISSUE regarding an explicit ECHO negotiated signal.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/211",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-03-23T15:57:23Z",
      "updatedAt": "2020-03-24T21:26:14Z",
      "closedAt": "2020-03-24T21:26:14Z",
      "mergedAt": "2020-03-24T21:26:14Z",
      "mergedBy": "chris-wood",
      "comments": [],
      "reviews": [],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "9dab0e191c85d2043a5a5c835fae0abed30625da",
      "headRepository": "tlswg/draft-ietf-tls-esni",
      "headRefName": "caw/require-trial-decryption",
      "headRefOid": "f9ec40b7d40313da6a4da55abb5d9fca39e56696",
      "mergeCommit": {
        "oid": "4f57a871f670c2b291652ed5bca4c77ec5913f19"
      }
    },
    {
      "number": 212,
      "id": "MDExOlB1bGxSZXF1ZXN0MzkyNTY5NDA2",
      "title": "Bind CHOuter to CHInner",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/212",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This makes it so that changes to the outer CH do not affect the inner. If anything does change that might muck with the binder or decryption, then ECHO is ignored. (This should help GREASE.)",
      "createdAt": "2020-03-23T18:43:59Z",
      "updatedAt": "2020-05-20T15:59:57Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "9dab0e191c85d2043a5a5c835fae0abed30625da",
      "headRepository": "tlswg/draft-ietf-tls-esni",
      "headRefName": "caw/outer-binder",
      "headRefOid": "0c351a6651eb9b2319b5c3e97b82a2226417e713",
      "closedAt": "2020-05-20T15:59:57Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc5NzY5Nzky",
          "commit": {
            "abbreviatedOid": "867f908"
          },
          "author": "dmcardle",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-23T19:47:56Z",
          "updatedAt": "2020-03-23T19:47:56Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "Just noticed this \"and and\"",
              "createdAt": "2020-03-23T19:47:56Z",
              "updatedAt": "2020-03-23T20:18:04Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc5Nzg5NTcz",
          "commit": {
            "abbreviatedOid": "867f908"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-23T20:17:28Z",
          "updatedAt": "2020-03-23T20:17:28Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "Thanks :)",
              "createdAt": "2020-03-23T20:17:28Z",
              "updatedAt": "2020-03-23T20:18:04Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgwNzM1MzU0",
          "commit": {
            "abbreviatedOid": "0c351a6"
          },
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-24T22:14:14Z",
          "updatedAt": "2020-03-24T22:21:13Z",
          "comments": [
            {
              "originalPosition": 54,
              "body": "This probably wants an extra sentence that you add the identity and binder to the PSK extension. At first I was confused what you did with the binder.",
              "createdAt": "2020-03-24T22:14:15Z",
              "updatedAt": "2020-03-24T22:21:13Z"
            },
            {
              "originalPosition": 43,
              "body": "(Hah. Nice!)",
              "createdAt": "2020-03-24T22:20:47Z",
              "updatedAt": "2020-03-24T22:21:13Z"
            }
          ]
        }
      ]
    },
    {
      "number": 213,
      "id": "MDExOlB1bGxSZXF1ZXN0NDAwMTY3MDgz",
      "title": "README: fix links to WG docs",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/213",
      "state": "MERGED",
      "author": "Lekensteyn",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-04-07T10:03:56Z",
      "updatedAt": "2020-04-13T15:04:03Z",
      "closedAt": "2020-04-13T15:04:03Z",
      "mergedAt": "2020-04-13T15:04:03Z",
      "mergedBy": "chris-wood",
      "comments": [],
      "reviews": [],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "4f57a871f670c2b291652ed5bca4c77ec5913f19",
      "headRepository": "Lekensteyn/draft-ietf-tls-esni",
      "headRefName": "pwu/readme-fixes",
      "headRefOid": "0106d1fe3ee5b249ff67fe883fa64c05d3a43e65",
      "mergeCommit": {
        "oid": "fef6612491aca10725d7ca7f9e1b7a3af8af5aa0"
      }
    },
    {
      "number": 221,
      "id": "MDExOlB1bGxSZXF1ZXN0NDA2NjQ4ODE0",
      "title": "Rearrange sentences for better readability",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/221",
      "state": "MERGED",
      "author": "d1vyank",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-04-21T12:41:38Z",
      "updatedAt": "2020-04-24T18:55:04Z",
      "closedAt": "2020-04-24T18:55:04Z",
      "mergedAt": "2020-04-24T18:55:04Z",
      "mergedBy": "chris-wood",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAwMTk1MjYx",
          "commit": {
            "abbreviatedOid": "bdab7ed"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-04-24T18:54:58Z",
          "updatedAt": "2020-04-24T18:54:58Z",
          "comments": []
        }
      ],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "fef6612491aca10725d7ca7f9e1b7a3af8af5aa0",
      "headRepository": "d1vyank/draft-ietf-tls-esni",
      "headRefName": "master",
      "headRefOid": "bdab7ede73b13362fff475c8f7783e8578ade1a6",
      "mergeCommit": {
        "oid": "6858521382b4c14d6ce1ef4d0b211eab90a45b63"
      }
    },
    {
      "number": 222,
      "id": "MDExOlB1bGxSZXF1ZXN0NDA3MDM5MzQ4",
      "title": "Fix outdated references to ESNIConfig",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/222",
      "state": "MERGED",
      "author": "d1vyank",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-04-22T04:33:39Z",
      "updatedAt": "2020-04-23T21:26:33Z",
      "closedAt": "2020-04-23T21:26:33Z",
      "mergedAt": "2020-04-23T21:26:33Z",
      "mergedBy": "chris-wood",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk5NDg5MDk2",
          "commit": {
            "abbreviatedOid": "c0fff68"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-04-23T21:26:26Z",
          "updatedAt": "2020-04-23T21:26:26Z",
          "comments": []
        }
      ],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "fef6612491aca10725d7ca7f9e1b7a3af8af5aa0",
      "headRepository": "d1vyank/draft-ietf-tls-esni",
      "headRefName": "nits",
      "headRefOid": "c0fff68851844847d14165fa0d1c1b6e75df5e0a",
      "mergeCommit": {
        "oid": "188c6a13fe29f468762542aea79f33ccc08170e6"
      }
    },
    {
      "number": 224,
      "id": "MDExOlB1bGxSZXF1ZXN0NDEwMzE3ODA5",
      "title": "Replace ECHOConfig TLS ciphersuites with HPKE code points.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/224",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Addresses #218.\r\n\r\nA given ECHOConfig now lists a single HPKE public key, with the corresponding\r\nKEM identifier, and a list of acceptable AEAD and KDF algorithm identifiers.\r\nClients may then choose their preferred AEAD and KDF algorithms for ClientHello\r\nencryption.\r\n\r\nWe may need to provide some guidance, either here or in the HPKE document, about acceptable (KEM, KDF, AEAD) tuples. \r\n\r\ncc @bifurcation",
      "createdAt": "2020-04-28T19:36:29Z",
      "updatedAt": "2020-05-04T20:38:25Z",
      "closedAt": "2020-05-01T23:34:07Z",
      "mergedAt": "2020-05-01T23:34:07Z",
      "mergedBy": "ekr",
      "comments": [
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "I hadn't realized these were separate IDs. Oh well.",
          "createdAt": "2020-05-01T23:33:47Z",
          "updatedAt": "2020-05-01T23:33:47Z"
        },
        {
          "author": "ocheron",
          "authorAssociation": "NONE",
          "body": "HpkeCipherSuite should also be used in ClientEncryptedCH.",
          "createdAt": "2020-05-04T20:26:10Z",
          "updatedAt": "2020-05-04T20:26:10Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Oops -- thanks, @ocheron! Fixed here: https://github.com/tlswg/draft-ietf-tls-esni/pull/231.",
          "createdAt": "2020-05-04T20:38:16Z",
          "updatedAt": "2020-05-04T20:38:25Z"
        }
      ],
      "reviews": [],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "6858521382b4c14d6ce1ef4d0b211eab90a45b63",
      "headRepository": "tlswg/draft-ietf-tls-esni",
      "headRefName": "caw/hpke-codepoints",
      "headRefOid": "e7c73326b7c507ef455a0edea3eb24fac73594ce",
      "mergeCommit": {
        "oid": "1b80857a4c0c7c64c6b2deba4f58574209a25a92"
      }
    },
    {
      "number": 225,
      "id": "MDExOlB1bGxSZXF1ZXN0NDEyMzg0NTYz",
      "title": "Deterministic padding",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/225",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This builds on #209, but removes the probabilistic pieces. I created a fresh PR to make review easier. \r\n\r\ncc @sftcd",
      "createdAt": "2020-05-02T02:04:54Z",
      "updatedAt": "2020-05-03T23:58:40Z",
      "closedAt": "2020-05-03T23:58:40Z",
      "mergedAt": "2020-05-03T23:58:40Z",
      "mergedBy": "chris-wood",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA0NjU1MDI3",
          "commit": {
            "abbreviatedOid": "4cc7421"
          },
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2020-05-03T20:35:28Z",
          "updatedAt": "2020-05-03T20:41:35Z",
          "comments": [
            {
              "originalPosition": 63,
              "body": "This text seems a bit confusing because clients typically offer a fixed set of ALPNs for a given application.  Perhaps:\r\n\r\n\"Clients typically support a small number of application profiles. For instance, a browser might support HTTP with ALPN values [\"http/1.1, \"h2\"] and WebRTC media with ALPNs [\"webrtc\", \"c-webrtc\"]. Clients SHOULD pad this extension by rounding up to the total size of the longest ALPN extension across all application profiles\".\r\n",
              "createdAt": "2020-05-03T20:35:28Z",
              "updatedAt": "2020-05-03T23:54:28Z"
            },
            {
              "originalPosition": 78,
              "body": "Say we just padded SNI and L = 0 and D = 10. We then compute the per-extension padding value as 22, but because of this paragraph we pad by 32? If so, I don't think this works, because if D was 11, we would also pad by 32, so now we are leaking the length of D.",
              "createdAt": "2020-05-03T20:40:26Z",
              "updatedAt": "2020-05-03T23:54:28Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA0NjYzNzM3",
          "commit": {
            "abbreviatedOid": "4cc7421"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-03T22:31:51Z",
          "updatedAt": "2020-05-03T22:31:51Z",
          "comments": [
            {
              "originalPosition": 78,
              "body": "Discussed offline -- will remove and consider later on, as this exists to mask fixed-length values across different stacks, and fingerprinting stacks is already pretty trivial.",
              "createdAt": "2020-05-03T22:31:51Z",
              "updatedAt": "2020-05-03T23:54:28Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA0NjY0NDQ0",
          "commit": {
            "abbreviatedOid": "82e87bc"
          },
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "LGTM",
          "createdAt": "2020-05-03T22:41:05Z",
          "updatedAt": "2020-05-03T22:41:05Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA0NjcwMDEy",
          "commit": {
            "abbreviatedOid": "82e87bc"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-03T23:50:59Z",
          "updatedAt": "2020-05-03T23:50:59Z",
          "comments": [
            {
              "originalPosition": 63,
              "body": "This might be a little narrow a view.  In a browser, we have a bunch of things we might do.  But that is because the browser is platform.  But the anonymity set on a different platform (say you used the system TLS stack) is potentially wider (all apps) and cannot make the same claim about application profiles.",
              "createdAt": "2020-05-03T23:50:59Z",
              "updatedAt": "2020-05-03T23:54:28Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA0NjcwMDcx",
          "commit": {
            "abbreviatedOid": "82e87bc"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-03T23:51:39Z",
          "updatedAt": "2020-05-03T23:53:50Z",
          "comments": [
            {
              "originalPosition": 74,
              "body": "```suggestion\r\nhint, i.e., ECHOConfig.maximum_name_length.\r\n```",
              "createdAt": "2020-05-03T23:51:39Z",
              "updatedAt": "2020-05-03T23:54:28Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA0NjcwMjk3",
          "commit": {
            "abbreviatedOid": "82e87bc"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-03T23:54:13Z",
          "updatedAt": "2020-05-03T23:54:13Z",
          "comments": [
            {
              "originalPosition": 63,
              "body": "The point is that the \"platform,\" be it the stack used in the browser or in the OS, typically defines the set of values here and should pad accordingly. I'm fine with using the browser as an example here, as it's just a specific instance of that platform.",
              "createdAt": "2020-05-03T23:54:13Z",
              "updatedAt": "2020-05-03T23:54:28Z"
            }
          ]
        }
      ],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "1b80857a4c0c7c64c6b2deba4f58574209a25a92",
      "headRepository": "tlswg/draft-ietf-tls-esni",
      "headRefName": "caw/padding",
      "headRefOid": "fd78562ba6c9b8f6dd088ce51539dd2af461a04e",
      "mergeCommit": {
        "oid": "2f891d33205621199ef8e946a6416a9bee470006"
      }
    },
    {
      "number": 226,
      "id": "MDExOlB1bGxSZXF1ZXN0NDEyNTE0MTY4",
      "title": "Provide guidance on ECHOConfig extension usage.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/226",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This addresses #216.\r\n\r\ncc @davidben, @bemasc, @mikebishop, @sftcd, @enygren",
      "createdAt": "2020-05-02T22:01:51Z",
      "updatedAt": "2020-05-07T18:43:33Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "1b80857a4c0c7c64c6b2deba4f58574209a25a92",
      "headRepository": "tlswg/draft-ietf-tls-esni",
      "headRefName": "caw/ext-policy",
      "headRefOid": "de1eb1297d5f9375ae15586a8cb38cd2eb32ab98",
      "closedAt": "2020-05-07T18:43:32Z",
      "mergedAt": "2020-05-07T18:43:32Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "f238f70420dbbab6085f959ce970e77d34e506e3"
      },
      "comments": [
        {
          "author": "MikeBishop",
          "authorAssociation": "NONE",
          "body": "This looks fine, though I'll note that since an HTTPSSVC record is public and the outer ClientHello record is public, it's not unreasonable to pull values from there to put in the public fields since the observer already knows (or can get) them.  Restricting them to come only from the ECHOConfig seems unnecessary.\r\n\r\nI think the key observation in this PR is that the outer ClientHello isn't _really_ offering to establish a TLS connection -- it's a not-crazy-looking wrapper for the actual ClientHello inside the ECHO extension, and the vehicle for the recovery flow.  The only things a server can legitimately do are respond to the inner ClientHello or do a recovery handshake.  Thus, most of the things you might set on the outer ClientHello are irrelevant; they can be chosen to look innocuous, chosen at random, or copied from the inner ClientHello as the implementation chooses.",
          "createdAt": "2020-05-04T18:55:14Z",
          "updatedAt": "2020-05-04T18:55:14Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@davidben, does this seem reasonable to you?",
          "createdAt": "2020-05-05T18:32:16Z",
          "updatedAt": "2020-05-05T18:32:16Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA0NTc0Mjgx",
          "commit": {
            "abbreviatedOid": "fc838d2"
          },
          "author": "bemasc",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-05-03T01:45:14Z",
          "updatedAt": "2020-05-03T01:45:14Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA0NjY4MDgy",
          "commit": {
            "abbreviatedOid": "fc838d2"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-03T23:27:52Z",
          "updatedAt": "2020-05-03T23:30:25Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "features or protections",
              "createdAt": "2020-05-03T23:27:53Z",
              "updatedAt": "2020-05-05T20:29:15Z"
            },
            {
              "originalPosition": 19,
              "body": "Comma",
              "createdAt": "2020-05-03T23:28:17Z",
              "updatedAt": "2020-05-05T20:29:15Z"
            },
            {
              "originalPosition": 38,
              "body": "SHOULD? ",
              "createdAt": "2020-05-03T23:28:58Z",
              "updatedAt": "2020-05-05T20:29:15Z"
            },
            {
              "originalPosition": 43,
              "body": "Except, as we have discussed, the length, though I guess that is a part of the outer, too.",
              "createdAt": "2020-05-03T23:30:20Z",
              "updatedAt": "2020-05-05T20:29:15Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA0NjcwNDA0",
          "commit": {
            "abbreviatedOid": "fc838d2"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-03T23:55:10Z",
          "updatedAt": "2020-05-03T23:55:11Z",
          "comments": [
            {
              "originalPosition": 43,
              "body": "Yep, I'm considering that part of the outer.",
              "createdAt": "2020-05-03T23:55:10Z",
              "updatedAt": "2020-05-05T20:29:15Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA0NjcwNDQ1",
          "commit": {
            "abbreviatedOid": "fc838d2"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-03T23:55:40Z",
          "updatedAt": "2020-05-03T23:55:40Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "Isn't protection a feature?",
              "createdAt": "2020-05-03T23:55:40Z",
              "updatedAt": "2020-05-05T20:29:15Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA0NjcwNjA0",
          "commit": {
            "abbreviatedOid": "fc838d2"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-03T23:57:21Z",
          "updatedAt": "2020-05-03T23:57:22Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "Will fix here and elsewhere!",
              "createdAt": "2020-05-03T23:57:22Z",
              "updatedAt": "2020-05-05T20:29:15Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA0NjcwNjI4",
          "commit": {
            "abbreviatedOid": "fc838d2"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-03T23:57:39Z",
          "updatedAt": "2020-05-03T23:57:40Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "I read them both the same, so that works for me.",
              "createdAt": "2020-05-03T23:57:40Z",
              "updatedAt": "2020-05-05T20:29:15Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA2MTE0MzQ3",
          "commit": {
            "abbreviatedOid": "27dcc7b"
          },
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-05T20:03:20Z",
          "updatedAt": "2020-05-05T20:05:39Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "functionality?",
              "createdAt": "2020-05-05T20:03:20Z",
              "updatedAt": "2020-05-05T20:29:15Z"
            },
            {
              "originalPosition": 66,
              "body": "Or, I guess, as ECHOConfigV2, right?",
              "createdAt": "2020-05-05T20:05:05Z",
              "updatedAt": "2020-05-05T20:29:15Z"
            },
            {
              "originalPosition": 73,
              "body": "I'm not sure there is a need to be this directive here. Why not leave this for future work.\r\n\r\nAlso, hypothetically, suppose that the extension was like \"make the nonce twice as long\"\r\n\r\n",
              "createdAt": "2020-05-05T20:05:34Z",
              "updatedAt": "2020-05-05T20:29:15Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA2MTE5MzMz",
          "commit": {
            "abbreviatedOid": "27dcc7b"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-05T20:11:05Z",
          "updatedAt": "2020-05-05T20:11:06Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "Functionality is a bit more general -- let's go with that!",
              "createdAt": "2020-05-05T20:11:06Z",
              "updatedAt": "2020-05-05T20:29:15Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA2MTIyNjY1",
          "commit": {
            "abbreviatedOid": "27dcc7b"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-05T20:16:04Z",
          "updatedAt": "2020-05-05T20:16:04Z",
          "comments": [
            {
              "originalPosition": 66,
              "body": "Yeah, I'll add that: \"as ECHOConfig extensions, or an entirely new version of ECHOConfig.\"",
              "createdAt": "2020-05-05T20:16:04Z",
              "updatedAt": "2020-05-05T20:29:15Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA2MTMzMDI2",
          "commit": {
            "abbreviatedOid": "de1eb12"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-05T20:32:14Z",
          "updatedAt": "2020-05-05T20:32:15Z",
          "comments": [
            {
              "originalPosition": 73,
              "body": "That's fair (and a good point). It is a bit... restrictive. I just removed the sentence.",
              "createdAt": "2020-05-05T20:32:15Z",
              "updatedAt": "2020-05-05T20:32:15Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA3NzM4NDA3",
          "commit": {
            "abbreviatedOid": "de1eb12"
          },
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Seems reasonable.",
          "createdAt": "2020-05-07T18:41:03Z",
          "updatedAt": "2020-05-07T18:41:03Z",
          "comments": []
        }
      ]
    },
    {
      "number": 227,
      "id": "MDExOlB1bGxSZXF1ZXN0NDEyNTE2Mzc3",
      "title": "Clarify \"do not stick out\" signals.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/227",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Addresses #215.\r\n\r\ncc @grittygrease ",
      "createdAt": "2020-05-02T22:23:28Z",
      "updatedAt": "2020-05-05T20:09:07Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "1b80857a4c0c7c64c6b2deba4f58574209a25a92",
      "headRepository": "tlswg/draft-ietf-tls-esni",
      "headRefName": "caw/signals",
      "headRefOid": "6285d8fc9f4268146fdc6a4ae71f2589021c8641",
      "closedAt": "2020-05-05T20:09:07Z",
      "mergedAt": "2020-05-05T20:09:07Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "1337c6915b0de26ddb98c4c44324d2572dead76f"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA2MTE2MTQw",
          "commit": {
            "abbreviatedOid": "30f0e72"
          },
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-05-05T20:06:03Z",
          "updatedAt": "2020-05-05T20:06:36Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "```suggestion\r\nsignal indicating use or negotiation of ECHO. Clients MAY GREASE the\r\n```",
              "createdAt": "2020-05-05T20:06:04Z",
              "updatedAt": "2020-05-05T20:08:57Z"
            },
            {
              "originalPosition": 21,
              "body": "This sentence is pretty long. Also, I would not use \"suspicious\" but rather \"unusual\" or \"meaningful\"",
              "createdAt": "2020-05-05T20:06:32Z",
              "updatedAt": "2020-05-05T20:08:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA2MTE3NTQ5",
          "commit": {
            "abbreviatedOid": "63dccdc"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-05T20:08:15Z",
          "updatedAt": "2020-05-05T20:08:15Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "Will fix!",
              "createdAt": "2020-05-05T20:08:15Z",
              "updatedAt": "2020-05-05T20:08:57Z"
            }
          ]
        }
      ]
    },
    {
      "number": 228,
      "id": "MDExOlB1bGxSZXF1ZXN0NDEyNTE3MDc5",
      "title": "Clarify need for optional record digests.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/228",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Addresses #205.\r\n\r\ncc @huitema ",
      "createdAt": "2020-05-02T22:30:52Z",
      "updatedAt": "2020-05-03T23:31:40Z",
      "closedAt": "2020-05-03T14:05:08Z",
      "mergedAt": "2020-05-03T14:05:07Z",
      "mergedBy": "chris-wood",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA0NTY2MTUy",
          "commit": {
            "abbreviatedOid": "3fac6b3"
          },
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Works for me.",
          "createdAt": "2020-05-02T22:45:05Z",
          "updatedAt": "2020-05-02T22:45:05Z",
          "comments": []
        }
      ],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "1b80857a4c0c7c64c6b2deba4f58574209a25a92",
      "headRepository": "tlswg/draft-ietf-tls-esni",
      "headRefName": "caw/optional-digests",
      "headRefOid": "3fac6b33e11b9e7e88de96b6c2ca55eaba337598",
      "mergeCommit": {
        "oid": "02b26097b42890c7273216c196b33d4050565920"
      }
    },
    {
      "number": 230,
      "id": "MDExOlB1bGxSZXF1ZXN0NDEyNTE4NDc0",
      "title": "Add information about per-client tracking via unique ECHOConfig structures",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/230",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Addresses #146.",
      "createdAt": "2020-05-02T22:45:49Z",
      "updatedAt": "2020-05-05T20:10:26Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "1b80857a4c0c7c64c6b2deba4f58574209a25a92",
      "headRepository": "tlswg/draft-ietf-tls-esni",
      "headRefName": "caw/tracking",
      "headRefOid": "e3df7ba582baa1cfdfd6e910d1b47bba0cc8ea4e",
      "closedAt": "2020-05-05T20:10:26Z",
      "mergedAt": "2020-05-05T20:10:25Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "e8f1fa948d271428e33493e962680fee4adca5e0"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA0NjY3NzE3",
          "commit": {
            "abbreviatedOid": "0f32404"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-03T23:23:19Z",
          "updatedAt": "2020-05-03T23:27:12Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "A paragraph break here might be good. You jump from description of the attack to a description of mitigating factors without segue. ",
              "createdAt": "2020-05-03T23:23:19Z",
              "updatedAt": "2020-05-05T20:10:17Z"
            },
            {
              "originalPosition": 13,
              "body": "I don't think the v6 example is good. And none of these are especially strong, except perhaps the DNS one. \r\n\r\nFor me, the question is how targeted the delivery could be, and whether the client can then do anything about that. For instance, a client might decide to flush its ECHO config cache if it moves and wants to be unlinkable.",
              "createdAt": "2020-05-03T23:27:07Z",
              "updatedAt": "2020-05-05T20:10:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA0NjcxMDU0",
          "commit": {
            "abbreviatedOid": "0f32404"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-04T00:02:27Z",
          "updatedAt": "2020-05-04T00:02:27Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "@martinthomson I'll remove the last sentence, not because of v6 (which I do think is a good example), but because it can probably bite us in the future when someone does turn it into a threat. :)\r\n\r\nOn the latter points, how about the following:\r\n\r\nThe cost of this type of attack scales linearly with the desired number of target clients. DNS caching behavior makes targeting individual users for extended periods of time, e.g., using per-client ECHOConfig structures delivered via HTTPSSVC RRs with high TTLs, challenging. Moreover, clients can flush any ECHOConfig state upon changing networks to mitigate potential linkability problems.",
              "createdAt": "2020-05-04T00:02:27Z",
              "updatedAt": "2020-05-05T20:10:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA2MDA3MDA4",
          "commit": {
            "abbreviatedOid": "7a5943b"
          },
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-05T17:32:07Z",
          "updatedAt": "2020-05-05T17:32:08Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "Is the thinking here that the client might have some ECHOConfig state outside the DNS cache, or is this just saying the client could flush its DNS cache on network change? An attacker that can distribute per-client ECHOConfigs in DNS could just as easily distribute per-client A/AAAA records in DNS. (Well, A may be hard due to address scarcity, but AAAA should be doable.) So if you're concerned about this attack, you probably want to treat this as a DNS-wide issue and drop the entire DNS cache.",
              "createdAt": "2020-05-05T17:32:07Z",
              "updatedAt": "2020-05-05T20:10:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA2MDE0ODc4",
          "commit": {
            "abbreviatedOid": "7a5943b"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-05T17:42:41Z",
          "updatedAt": "2020-05-05T17:42:41Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "Indeed -- in practice it'll likely be the entire cache. I didn't want to include other state (V4 or V6) to make any assumption on what the cache might contain, be it the DNS cache or something else. Is this just too generic for your taste?",
              "createdAt": "2020-05-05T17:42:41Z",
              "updatedAt": "2020-05-05T20:10:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA2MDIyMjAw",
          "commit": {
            "abbreviatedOid": "7a5943b"
          },
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-05T17:52:31Z",
          "updatedAt": "2020-05-05T17:52:31Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "Mostly a clarifying question. Though perhaps we should say \"flushing any DNS state\" instead of flushing any ECHOConfig state\". Or perhaps \"flushing any DNS or ECHOConfig state\". Or maybe we leave it along because too many words. :-)",
              "createdAt": "2020-05-05T17:52:31Z",
              "updatedAt": "2020-05-05T20:10:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA2MDI4NTk2",
          "commit": {
            "abbreviatedOid": "7a5943b"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-05T18:00:46Z",
          "updatedAt": "2020-05-05T18:00:47Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "I'm fine with \"flushing any DNS or ECHOConfig state\"!",
              "createdAt": "2020-05-05T18:00:46Z",
              "updatedAt": "2020-05-05T20:10:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA2MDQyODY3",
          "commit": {
            "abbreviatedOid": "7a5943b"
          },
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-05T18:20:10Z",
          "updatedAt": "2020-05-05T18:20:10Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "SGTM",
              "createdAt": "2020-05-05T18:20:10Z",
              "updatedAt": "2020-05-05T20:10:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA2MTE2ODY5",
          "commit": {
            "abbreviatedOid": "bb6c1a3"
          },
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-05T20:07:13Z",
          "updatedAt": "2020-05-05T20:07:14Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "```suggestion\r\nRRs with high TTLs, challenging. Clients can help mitigate this problem by\r\n```",
              "createdAt": "2020-05-05T20:07:13Z",
              "updatedAt": "2020-05-05T20:10:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA2MTE2OTEy",
          "commit": {
            "abbreviatedOid": "bb6c1a3"
          },
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-05-05T20:07:16Z",
          "updatedAt": "2020-05-05T20:07:16Z",
          "comments": []
        }
      ]
    },
    {
      "number": 231,
      "id": "MDExOlB1bGxSZXF1ZXN0NDEzMTcyMzA3",
      "title": "Fix remaining HPKE issues.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/231",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-05-04T20:38:06Z",
      "updatedAt": "2020-05-04T20:38:32Z",
      "closedAt": "2020-05-04T20:38:32Z",
      "mergedAt": "2020-05-04T20:38:31Z",
      "mergedBy": "chris-wood",
      "comments": [],
      "reviews": [],
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "2f891d33205621199ef8e946a6416a9bee470006",
      "headRepository": "tlswg/draft-ietf-tls-esni",
      "headRefName": "caw/hpke-nits",
      "headRefOid": "a5a9ce65e9e196c4e4584fd88c0768fbb8f1688b",
      "mergeCommit": {
        "oid": "f00e1f070cd55813ac56fc9f6c4ac22ab5cb5b56"
      }
    },
    {
      "number": 234,
      "id": "MDExOlB1bGxSZXF1ZXN0NDE2NDEyMjk1",
      "title": "Describe known active attacks",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/234",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Addresses #229.\r\n\r\nThis is for motivating some of our design decisions (and documenting what we know along the way). I meant to do this a while ago, but never got around to it. In particular, it describes why we have the following three bindings:\r\n\r\n1. Transcript to ECHO secret (to prevent client reaction attacks).\r\n2. CH1 to CH2 (to prevent HRR oracles).\r\n3. ClientHello to resumption PSK binder (to prevent resumption oracles).\r\n\r\nI'm *sure* the language and presentation can be improved, so suggestions to that effect are very much welcome!\r\n\r\ncc @martinthomson, @davidben, @dmcardle, @jhoyla, @kazuho, @karthikbhargavan, @grittygrease ",
      "createdAt": "2020-05-12T00:09:56Z",
      "updatedAt": "2020-05-21T13:07:55Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "f238f70420dbbab6085f959ce970e77d34e506e3",
      "headRepository": "tlswg/draft-ietf-tls-esni",
      "headRefName": "caw/active-attacks",
      "headRefOid": "df869d1ceac0fcfc951e710006cf078bb06dac3a",
      "closedAt": "2020-05-21T13:07:55Z",
      "mergedAt": "2020-05-21T13:07:55Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "1e7e0d9ef6fc33984240891b0f30cf139c45a193"
      },
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks for the feedback! I incorporated your suggestions and clarified a few more things. I'm merging as-is since they seemed mostly editorial.",
          "createdAt": "2020-05-21T13:07:32Z",
          "updatedAt": "2020-05-21T13:07:32Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE1ODI4Mjk4",
          "commit": {
            "abbreviatedOid": "7eb76ae"
          },
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2020-05-21T01:53:59Z",
          "updatedAt": "2020-05-21T02:04:24Z",
          "comments": [
            {
              "originalPosition": 36,
              "body": "```suggestion\r\nThis section describes the rationale for ECHO properties and mechanics as defenses\r\n```",
              "createdAt": "2020-05-21T01:53:59Z",
              "updatedAt": "2020-05-21T13:06:11Z"
            },
            {
              "originalPosition": 37,
              "body": "```suggestion\r\nagainst active attacks. In all the attacks below, the attacker is on-path between\r\n```",
              "createdAt": "2020-05-21T01:54:10Z",
              "updatedAt": "2020-05-21T13:06:11Z"
            },
            {
              "originalPosition": 39,
              "body": "```suggestion\r\nabout the inner ClientHello, such as the true SNI value.\r\n```",
              "createdAt": "2020-05-21T01:54:24Z",
              "updatedAt": "2020-05-21T13:06:11Z"
            },
            {
              "originalPosition": 43,
              "body": "```suggestion\r\nThis attack uses the client's reaction to an incorrect certificate as an oracle.\r\n```",
              "createdAt": "2020-05-21T01:54:52Z",
              "updatedAt": "2020-05-21T13:06:11Z"
            },
            {
              "originalPosition": 44,
              "body": "```suggestion\r\nThe attacker intercepts a legitimate ClientHello and replies with a\r\n```",
              "createdAt": "2020-05-21T01:55:14Z",
              "updatedAt": "2020-05-21T13:06:11Z"
            },
            {
              "originalPosition": 52,
              "body": "This isn't the attack I was thinking of. Rather, you withhold CV and so any client which does cert verification first will fail.",
              "createdAt": "2020-05-21T01:58:26Z",
              "updatedAt": "2020-05-21T13:06:11Z"
            },
            {
              "originalPosition": 75,
              "body": "```suggestion\r\nto decrypt the Certificate and abort the connection.\r\n```",
              "createdAt": "2020-05-21T02:00:35Z",
              "updatedAt": "2020-05-21T13:06:11Z"
            },
            {
              "originalPosition": 83,
              "body": "I think you need to say something about how this had to legitimately be an HRR case. Or can the attacker force it?",
              "createdAt": "2020-05-21T02:01:50Z",
              "updatedAt": "2020-05-21T13:06:11Z"
            },
            {
              "originalPosition": 85,
              "body": "Note that this only works if the server (arguably incorrectly) stores the SNI from CH1.",
              "createdAt": "2020-05-21T02:02:27Z",
              "updatedAt": "2020-05-21T13:06:11Z"
            },
            {
              "originalPosition": 85,
              "body": "```suggestion\r\nand HelloRetryRequest exchange with the result that the server encrypts the certificate to the attacker.\r\n```",
              "createdAt": "2020-05-21T02:02:57Z",
              "updatedAt": "2020-05-21T13:06:11Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE1ODM1MTA2",
          "commit": {
            "abbreviatedOid": "7eb76ae"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-21T02:17:25Z",
          "updatedAt": "2020-05-21T02:17:25Z",
          "comments": [
            {
              "originalPosition": 52,
              "body": "That seems like a different variation, so I'll just note it. Thanks!",
              "createdAt": "2020-05-21T02:17:25Z",
              "updatedAt": "2020-05-21T13:06:11Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE1ODM1MjE3",
          "commit": {
            "abbreviatedOid": "7eb76ae"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-21T02:17:49Z",
          "updatedAt": "2020-05-21T02:17:49Z",
          "comments": [
            {
              "originalPosition": 83,
              "body": "Good point. I'll call out that assumption explicitly.",
              "createdAt": "2020-05-21T02:17:49Z",
              "updatedAt": "2020-05-21T13:06:11Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE1ODM1Mjcy",
          "commit": {
            "abbreviatedOid": "7eb76ae"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-21T02:18:00Z",
          "updatedAt": "2020-05-21T02:18:00Z",
          "comments": [
            {
              "originalPosition": 85,
              "body": "Yep! I'll note that, too. ",
              "createdAt": "2020-05-21T02:18:00Z",
              "updatedAt": "2020-05-21T13:06:11Z"
            }
          ]
        }
      ]
    },
    {
      "number": 235,
      "id": "MDExOlB1bGxSZXF1ZXN0NDE4Njg3Nzc4",
      "title": "Suggest size of GREASE encrypted_ch extension value.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/235",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This assumes the GREASE threat model is a misbehaving and lazy middlebox. That is, we aim to prevent ossification. It does nothing more to prevent an active attacker from learning whether or not a particular connection used GREASE. (That problem is probably better suited to something like MASQUE.)\r\n\r\ncc @davidben @ekr @martinthomson",
      "createdAt": "2020-05-15T16:29:25Z",
      "updatedAt": "2020-05-20T15:58:32Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "f238f70420dbbab6085f959ce970e77d34e506e3",
      "headRepository": "tlswg/draft-ietf-tls-esni",
      "headRefName": "caw/grease-size",
      "headRefOid": "cab69382afbc78bfd4df71f3004d1bc47017b303",
      "closedAt": "2020-05-20T15:58:32Z",
      "mergedAt": "2020-05-20T15:58:32Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "5005670f318da0a19868a8858dc4c473e8bc3825"
      },
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Merging for now. We can come back later and address followup extensions if needed!",
          "createdAt": "2020-05-20T15:58:28Z",
          "updatedAt": "2020-05-20T15:58:28Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDEyODA2NDQ1",
          "commit": {
            "abbreviatedOid": "cab6938"
          },
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-05-15T16:44:03Z",
          "updatedAt": "2020-05-15T16:44:03Z",
          "comments": []
        }
      ]
    },
    {
      "number": 236,
      "id": "MDExOlB1bGxSZXF1ZXN0NDIxNTQ1NDg5",
      "title": "s/ECHO/ECH",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/236",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #232.",
      "createdAt": "2020-05-21T19:44:27Z",
      "updatedAt": "2020-05-22T03:12:05Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "1e7e0d9ef6fc33984240891b0f30cf139c45a193",
      "headRepository": "tlswg/draft-ietf-tls-esni",
      "headRefName": "caw/ech",
      "headRefOid": "4a37e99a9db136efe1941e2c54b962dbe6f72a77",
      "closedAt": "2020-05-21T19:49:50Z",
      "mergedAt": "2020-05-21T19:49:50Z",
      "mergedBy": "ekr",
      "mergeCommit": {
        "oid": "c4d4b7f531f85d72f7bb50755d1106f51287bfdc"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE2NDgyNjAw",
          "commit": {
            "abbreviatedOid": "4a37e99"
          },
          "author": "tfpauly",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-21T20:51:08Z",
          "updatedAt": "2020-05-21T20:51:09Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "TLS Encrypted ClientHello \u2014> TECH!\r\n\r\n(Kidding, kidding)",
              "createdAt": "2020-05-21T20:51:09Z",
              "updatedAt": "2020-05-21T20:51:09Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE2NTM4ODY0",
          "commit": {
            "abbreviatedOid": "4a37e99"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-21T22:36:29Z",
          "updatedAt": "2020-05-21T22:36:30Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Hah!",
              "createdAt": "2020-05-21T22:36:29Z",
              "updatedAt": "2020-05-21T22:36:30Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE2NjE2NDY3",
          "commit": {
            "abbreviatedOid": "4a37e99"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-22T02:52:55Z",
          "updatedAt": "2020-05-22T02:52:56Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Seeing this, I think that you should remove 1.3 from the title.  Sure, this is 1.3 only, but I think that this design is fine for 1.4 also.  If it isn't, I'm sure we can deal with that eventually.  I don't want to find that we ship a 1.4 (or 4) that is compatible with this and have people tell me that it isn't compatible.",
              "createdAt": "2020-05-22T02:52:56Z",
              "updatedAt": "2020-05-22T02:52:56Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE2NjIxNjQw",
          "commit": {
            "abbreviatedOid": "4a37e99"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-22T03:12:04Z",
          "updatedAt": "2020-05-22T03:12:05Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "That's a fair point. I'll make that change in a separate PR!",
              "createdAt": "2020-05-22T03:12:05Z",
              "updatedAt": "2020-05-22T03:12:05Z"
            }
          ]
        }
      ]
    },
    {
      "number": 238,
      "id": "MDExOlB1bGxSZXF1ZXN0NDIzNDY3MjE4",
      "title": "Remove TLS 1.3 from the title, and re-categorize as a ST document.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/238",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Seeing no pushback on the list, this moves the draft from Experimental to ST.",
      "createdAt": "2020-05-26T21:14:10Z",
      "updatedAt": "2020-05-26T21:17:19Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "c4d4b7f531f85d72f7bb50755d1106f51287bfdc",
      "headRepository": "tlswg/draft-ietf-tls-esni",
      "headRefName": "caw/retitle-and-recategorize",
      "headRefOid": "d86a8ea8f1c23a6d4e67f384c94dbad3dd3a4268",
      "closedAt": "2020-05-26T21:17:19Z",
      "mergedAt": "2020-05-26T21:17:19Z",
      "mergedBy": "ekr",
      "mergeCommit": {
        "oid": "a522e66aab86f9db0ce73edb999339887fa5a8ff"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE4Njg0ODA0",
          "commit": {
            "abbreviatedOid": "a4fc9e8"
          },
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-26T21:15:34Z",
          "updatedAt": "2020-05-26T21:15:34Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "If we are going to change the title, let's make it match the abbrev\r\n\r\n\"TLS Encrypted Client Hello\"",
              "createdAt": "2020-05-26T21:15:34Z",
              "updatedAt": "2020-05-26T21:16:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE4Njg0OTIx",
          "commit": {
            "abbreviatedOid": "a4fc9e8"
          },
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-05-26T21:15:45Z",
          "updatedAt": "2020-05-26T21:15:45Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE4Njg1MzA4",
          "commit": {
            "abbreviatedOid": "a4fc9e8"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-26T21:16:24Z",
          "updatedAt": "2020-05-26T21:16:24Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "Works for me!",
              "createdAt": "2020-05-26T21:16:24Z",
              "updatedAt": "2020-05-26T21:16:44Z"
            }
          ]
        }
      ]
    },
    {
      "number": 239,
      "id": "MDExOlB1bGxSZXF1ZXN0NDIzNDc1ODk1",
      "title": "Specify encrypted_client_hello and outer_extension codepoints.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/239",
      "state": "OPEN",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Once we have some implementations that interop, we'll go ahead with early\r\ncodepoint allocation.\r\n\r\nThe new version matches -07, which will be the next draft version we submit.\r\n\r\ncc @martinthomson @grittygrease \r\n\r\nCloses #220.",
      "createdAt": "2020-05-26T21:34:38Z",
      "updatedAt": "2020-05-26T21:42:52Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "a522e66aab86f9db0ce73edb999339887fa5a8ff",
      "headRepository": "tlswg/draft-ietf-tls-esni",
      "headRefName": "caw/codepoints",
      "headRefOid": "16070b4d44fdf7a350765ecbe65ef58fe495ba34",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": []
    }
  ]
}